From 8a6effaa440873347c4d60bb0b31214bbf56b9de Mon Sep 17 00:00:00 2001
From: "lff@Snode" <junzhao.liang@spacemit.com>
Date: Wed, 27 Mar 2024 16:19:34 +0800
Subject: [PATCH] [RVV] optimized jpeg-turbo gcc version

---
 BUILDING.md                                   |  18 +-
 CMakeLists.txt                                | 105 +-
 ChangeLog.md                                  |  83 +-
 LICENSE.md                                    |   2 +-
 cmakescripts/BuildPackages.cmake              |   2 +-
 cmyk.h                                        |   1 -
 djpeg.c                                       |   2 +
 doc/html/group___turbo_j_p_e_g.html           | 379 +++----
 doc/html/search/all_6.js                      |  14 +-
 doc/html/search/functions_0.js                |  12 +-
 doc/html/structtjtransform.html               |   6 +-
 java/TJBench.java                             | 111 +-
 java/TJExample.java                           |  13 +-
 java/TJUnitTest.java                          |  76 +-
 java/doc/index-all.html                       | 176 ++--
 java/doc/org/libjpegturbo/turbojpeg/TJ.html   | 168 +--
 .../libjpegturbo/turbojpeg/TJCompressor.html  | 169 +--
 .../turbojpeg/TJCustomFilter.html             |   2 +-
 .../turbojpeg/TJDecompressor.html             | 348 ++++---
 .../libjpegturbo/turbojpeg/TJTransform.html   |  39 +-
 .../libjpegturbo/turbojpeg/TJTransformer.html |  81 +-
 .../org/libjpegturbo/turbojpeg/YUVImage.html  | 166 +--
 .../turbojpeg/package-summary.html            |   2 +-
 java/doc/serialized-form.html                 |   5 +-
 java/org/libjpegturbo/turbojpeg/TJ.java       | 143 +--
 .../libjpegturbo/turbojpeg/TJCompressor.java  | 141 +--
 .../turbojpeg/TJCustomFilter.java             |   4 +-
 .../turbojpeg/TJDecompressor.java             | 313 +++---
 .../libjpegturbo/turbojpeg/TJTransform.java   |  28 +-
 .../libjpegturbo/turbojpeg/TJTransformer.java |  66 +-
 java/org/libjpegturbo/turbojpeg/YUVImage.java | 161 +--
 jccolext.c                                    |  14 +-
 jccolor.c                                     |  21 +-
 jchuff.c                                      |   1 -
 jchuff.h                                      |  12 +-
 jcmaster.c                                    |   1 -
 jcphuff.c                                     |  37 +-
 jdapimin.c                                    |   1 -
 jdcolext.c                                    |  14 +-
 jdcolor.c                                     |   1 -
 jdmainct.c                                    |   1 -
 jdmerge.c                                     |   1 -
 jdmrgext.c                                    |  20 +-
 jdsample.c                                    |   2 +-
 jpegtran.1                                    |   2 +-
 jsimd.h                                       |   8 +-
 jsimd_none.c                                  |   8 +-
 jversion.h.in                                 |   4 +-
 rdppm.c                                       |  20 +-
 simd/CMakeLists.txt                           |  56 +-
 simd/arm/aarch32/jsimd.c                      |  12 +-
 simd/arm/aarch64/jsimd.c                      |  17 +-
 simd/arm/jcphuff-neon.c                       | 187 ++--
 simd/arm/jdcolor-neon.c                       |   1 -
 simd/arm/jdmerge-neon.c                       |   1 -
 simd/arm/jidctint-neon.c                      |   1 -
 simd/i386/jsimd.c                             |  84 +-
 simd/jsimd.h                                  | 177 +++-
 simd/mips/jsimd.c                             |  12 +-
 simd/mips64/jsimd.c                           |  12 +-
 simd/powerpc/jsimd.c                          |  12 +-
 simd/rvv/jccolext-rvv.c                       | 145 +++
 simd/rvv/jccolor-rvv.c                        | 118 +++
 simd/rvv/jcgray-rvv.c                         | 112 ++
 simd/rvv/jcgryext-rvv.c                       | 104 ++
 simd/rvv/jcsample-rvv.c                       | 149 +++
 simd/rvv/jcsample.h                           |  59 ++
 simd/rvv/jdcolext-rvv.c                       | 170 ++++
 simd/rvv/jdcolor-rvv.c                        | 122 +++
 simd/rvv/jdmerge-rvv.c                        | 136 +++
 simd/rvv/jdmrgext-rvv.c                       | 235 +++++
 simd/rvv/jdsample-rvv.c                       | 460 +++++++++
 simd/rvv/jfdctfst-rvv.c                       | 155 +++
 simd/rvv/jfdctint-rvv.c                       | 250 +++++
 simd/rvv/jidctfst-rvv.c                       | 315 ++++++
 simd/rvv/jidctint-rvv.c                       | 360 +++++++
 simd/rvv/jidctred-rvv.c                       | 353 +++++++
 simd/rvv/jquanti-rvv.c                        | 132 +++
 simd/rvv/jsimd.c                              | 940 +++++++++++++++++
 simd/rvv/jsimd_rvv.h                          |  39 +
 simd/x86_64/jsimd.c                           |  60 +-
 tjbench.c                                     | 117 ++-
 tjexample.c                                   |  11 +-
 tjunittest.c                                  |  75 +-
 transupp.c                                    |   2 +-
 turbojpeg-jni.c                               |  31 +-
 turbojpeg-mapfile                             |   8 +-
 turbojpeg-mapfile.jni                         |   8 +-
 turbojpeg.c                                   | 164 +--
 turbojpeg.h                                   | 962 +++++++++---------
 win/jpeg.rc.in                                |   2 +-
 win/turbojpeg.rc.in                           |   2 +-
 wizard.txt                                    |  10 +-
 93 files changed, 7188 insertions(+), 2194 deletions(-)
 create mode 100644 simd/rvv/jccolext-rvv.c
 create mode 100644 simd/rvv/jccolor-rvv.c
 create mode 100644 simd/rvv/jcgray-rvv.c
 create mode 100644 simd/rvv/jcgryext-rvv.c
 create mode 100644 simd/rvv/jcsample-rvv.c
 create mode 100644 simd/rvv/jcsample.h
 create mode 100644 simd/rvv/jdcolext-rvv.c
 create mode 100644 simd/rvv/jdcolor-rvv.c
 create mode 100644 simd/rvv/jdmerge-rvv.c
 create mode 100644 simd/rvv/jdmrgext-rvv.c
 create mode 100644 simd/rvv/jdsample-rvv.c
 create mode 100644 simd/rvv/jfdctfst-rvv.c
 create mode 100644 simd/rvv/jfdctint-rvv.c
 create mode 100644 simd/rvv/jidctfst-rvv.c
 create mode 100644 simd/rvv/jidctint-rvv.c
 create mode 100644 simd/rvv/jidctred-rvv.c
 create mode 100644 simd/rvv/jquanti-rvv.c
 create mode 100644 simd/rvv/jsimd.c
 create mode 100644 simd/rvv/jsimd_rvv.h

diff --git a/BUILDING.md b/BUILDING.md
index 2ce65d6..b965b5e 100644
--- a/BUILDING.md
+++ b/BUILDING.md
@@ -25,9 +25,9 @@ Build Requirements
     variable or the `ASM_NASM` environment variable.  On Windows, use forward
     slashes rather than backslashes in the path (for example,
     **c:/nasm/nasm.exe**).
-  * NASM and Yasm are located in the CRB (Code Ready Builder) repository on
-    Red Hat Enterprise Linux 8 and in the PowerTools repository on RHEL
-    derivatives, which is not enabled by default.
+  * NASM and Yasm are located in the CRB (Code Ready Builder) or PowerTools
+    repository on Red Hat Enterprise Linux 8+ and derivatives, which is not
+    enabled by default.
 
 ### Un*x Platforms (including Linux, Mac, FreeBSD, Solaris, and Cygwin)
 
@@ -372,9 +372,13 @@ located (usually **/usr/bin**.)  Next, execute the following commands:
 
     cd {build_directory}
     cmake -G"Unix Makefiles" -DCMAKE_TOOLCHAIN_FILE=toolchain.cmake \
+      -DCMAKE_INSTALL_PREFIX={install_path} \
       [additional CMake flags] {source_directory}
     make
 
+*{install\_path}* is the path under which the libjpeg-turbo binaries should be
+installed.
+
 
 ### 64-bit MinGW Build on Un*x (including Mac and Cygwin)
 
@@ -391,9 +395,13 @@ located (usually **/usr/bin**.)  Next, execute the following commands:
 
     cd {build_directory}
     cmake -G"Unix Makefiles" -DCMAKE_TOOLCHAIN_FILE=toolchain.cmake \
+      -DCMAKE_INSTALL_PREFIX={install_path} \
       [additional CMake flags] {source_directory}
     make
 
+*{install\_path}* is the path under which the libjpeg-turbo binaries should be
+installed.
+
 
 Building libjpeg-turbo for iOS
 ------------------------------
@@ -429,6 +437,10 @@ iPhone 5S/iPad Mini 2/iPad Air and newer.
       [additional CMake flags] {source_directory}
     make
 
+Replace `iPhoneOS` with `iPhoneSimulator` and `-miphoneos-version-min` with
+`-miphonesimulator-version-min` to build libjpeg-turbo for the iOS simulator on
+Macs with Apple silicon CPUs.
+
 
 Building libjpeg-turbo for Android
 ----------------------------------
diff --git a/CMakeLists.txt b/CMakeLists.txt
index cca2966..0eea262 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -10,8 +10,8 @@ if(CMAKE_EXECUTABLE_SUFFIX)
 endif()
 
 project(libjpeg-turbo C)
-set(VERSION 2.1.4)
-set(COPYRIGHT_YEAR "1991-2022")
+set(VERSION 2.1.5)
+set(COPYRIGHT_YEAR "1991-2023")
 string(REPLACE "." ";" VERSION_TRIPLET ${VERSION})
 list(GET VERSION_TRIPLET 0 VERSION_MAJOR)
 list(GET VERSION_TRIPLET 1 VERSION_MINOR)
@@ -40,7 +40,16 @@ set(LIBJPEG_TURBO_VERSION_NUMBER ${VERSION_MAJOR}${VERSION_MINOR}${VERSION_REVIS
 # application bundles would break our iOS packages.)
 set(CMAKE_MACOSX_BUNDLE FALSE)
 
-string(TIMESTAMP DEFAULT_BUILD "%Y%m%d")
+get_property(GENERATOR_IS_MULTI_CONFIG GLOBAL PROPERTY
+  GENERATOR_IS_MULTI_CONFIG)
+# If the GENERATOR_IS_MULTI_CONFIG property doesn't exist (CMake < 3.9), then
+# set the GENERATOR_IS_MULTI_CONFIG variable manually if the generator is
+# Visual Studio or Xcode (the only multi-config generators in CMake < 3.9).
+if(NOT GENERATOR_IS_MULTI_CONFIG AND (MSVC_IDE OR XCODE))
+  set(GENERATOR_IS_MULTI_CONFIG TRUE)
+endif()
+
+string(TIMESTAMP DEFAULT_BUILD "%Y%m%d" UTC)
 set(BUILD ${DEFAULT_BUILD} CACHE STRING "Build string (default: ${DEFAULT_BUILD})")
 
 # NOTE: On Windows, this does nothing except when using MinGW or Cygwin.
@@ -236,10 +245,6 @@ endif()
 report_option(ENABLE_SHARED "Shared libraries")
 report_option(ENABLE_STATIC "Static libraries")
 
-if(ENABLE_SHARED)
-  set(CMAKE_INSTALL_RPATH ${CMAKE_INSTALL_FULL_LIBDIR})
-endif()
-
 if(WITH_JPEG8 OR WITH_JPEG7)
   set(WITH_ARITH_ENC 1)
   set(WITH_ARITH_DEC 1)
@@ -287,6 +292,16 @@ if(NOT WITH_JPEG8)
   report_option(WITH_MEM_SRCDST "In-memory source/destination managers")
 endif()
 
+# 0: Original libjpeg v6b/v7/v8 API/ABI
+#
+# libjpeg v6b/v7 API/ABI emulation:
+# 1: + In-memory source/destination managers (libjpeg-turbo 1.3.x)
+# 2: + Partial image decompression functions (libjpeg-turbo 1.5.x)
+# 3: + ICC functions (libjpeg-turbo 2.0.x)
+#
+# libjpeg v8 API/ABI emulation:
+# 1: + Partial image decompression functions (libjpeg-turbo 1.5.x)
+# 2: + ICC functions (libjpeg-turbo 2.0.x)
 set(SO_AGE 2)
 if(WITH_MEM_SRCDST)
   set(SO_AGE 3)
@@ -337,8 +352,19 @@ message(STATUS "libjpeg API shared library version = ${SO_MAJOR_VERSION}.${SO_AG
 # names of functions whenever they are modified in a backward-incompatible
 # manner, it is always backward-ABI-compatible with itself, so the major and
 # minor SO versions don't change.  However, we increase the middle number (the
-# SO "age") whenever functions are added to the API.
+# SO "age") whenever functions are added to the API, because adding functions
+# affects forward API/ABI compatibility.
 set(TURBOJPEG_SO_MAJOR_VERSION 0)
+# 0: TurboJPEG 1.3.x API
+# 1: TurboJPEG 1.4.x API
+#    The TurboJPEG 1.5.x API modified some of the function prototypes, adding
+#    the const keyword in front of pointers to unmodified buffers, but that did
+#    not affect forward API/ABI compatibility.
+# 2: TurboJPEG 2.0.x API
+#    The TurboJPEG 2.1.x API modified the behavior of the tjDecompressHeader3()
+#    function so that it accepts "abbreviated table specification" (AKA
+#    "tables-only") datastreams as well as JPEG images, but that did not affect
+#    forward API/ABI compatibility.
 set(TURBOJPEG_SO_AGE 2)
 set(TURBOJPEG_SO_VERSION 0.${TURBOJPEG_SO_AGE}.0)
 
@@ -713,7 +739,7 @@ add_executable(strtest strtest.c)
 
 add_subdirectory(md5)
 
-if(MSVC_IDE OR XCODE)
+if(GENERATOR_IS_MULTI_CONFIG)
   set(OBJDIR "\${CTEST_CONFIGURATION_TYPE}/")
 else()
   set(OBJDIR "")
@@ -946,23 +972,30 @@ if(FLOATTEST)
   endif()
 endif()
 
+message(STATUS "CMAKE_CROSSCOMPILING_EMULATOR=${CMAKE_CROSSCOMPILING_EMULATOR}")
+message(STATUS "CPU_PARAMETERS=${CPU_PARAMETERS}")
+if(CPU_PARAMETERS)
+  set(EMULATOR_CPU "-cpu")
+endif()
+message(STATUS "EMULATOR_CPU=${EMULATOR_CPU}")
+
 foreach(libtype ${TEST_LIBTYPES})
   if(libtype STREQUAL "static")
     set(suffix -static)
   endif()
   if(WITH_TURBOJPEG)
     add_test(tjunittest-${libtype}
-      ${CMAKE_CROSSCOMPILING_EMULATOR} tjunittest${suffix})
+      ${CMAKE_CROSSCOMPILING_EMULATOR} ${EMULATOR_CPU} ${CPU_PARAMETERS} tjunittest${suffix})
     add_test(tjunittest-${libtype}-alloc
-      ${CMAKE_CROSSCOMPILING_EMULATOR} tjunittest${suffix} -alloc)
+      ${CMAKE_CROSSCOMPILING_EMULATOR} ${EMULATOR_CPU} ${CPU_PARAMETERS} tjunittest${suffix} -alloc)
     add_test(tjunittest-${libtype}-yuv
-      ${CMAKE_CROSSCOMPILING_EMULATOR} tjunittest${suffix} -yuv)
+      ${CMAKE_CROSSCOMPILING_EMULATOR} ${EMULATOR_CPU} ${CPU_PARAMETERS} tjunittest${suffix} -yuv)
     add_test(tjunittest-${libtype}-yuv-alloc
-      ${CMAKE_CROSSCOMPILING_EMULATOR} tjunittest${suffix} -yuv -alloc)
+      ${CMAKE_CROSSCOMPILING_EMULATOR} ${EMULATOR_CPU} ${CPU_PARAMETERS} tjunittest${suffix} -yuv -alloc)
     add_test(tjunittest-${libtype}-yuv-nopad
-      ${CMAKE_CROSSCOMPILING_EMULATOR} tjunittest${suffix} -yuv -noyuvpad)
+      ${CMAKE_CROSSCOMPILING_EMULATOR} ${EMULATOR_CPU} ${CPU_PARAMETERS} tjunittest${suffix} -yuv -noyuvpad)
     add_test(tjunittest-${libtype}-bmp
-      ${CMAKE_CROSSCOMPILING_EMULATOR} tjunittest${suffix} -bmp)
+      ${CMAKE_CROSSCOMPILING_EMULATOR} ${EMULATOR_CPU} ${CPU_PARAMETERS} tjunittest${suffix} -bmp)
 
     set(MD5_PPM_GRAY_TILE 89d3ca21213d9d864b50b4e4e7de4ca6)
     set(MD5_PPM_420_8x8_TILE 847fceab15c5b7b911cb986cf0f71de3)
@@ -987,23 +1020,23 @@ foreach(libtype ${TEST_LIBTYPES})
       ${CMAKE_COMMAND} -E copy_if_different ${TESTIMAGES}/testorig.ppm
         testout_tile.ppm)
     add_test(tjbench-${libtype}-tile
-      ${CMAKE_CROSSCOMPILING_EMULATOR} tjbench${suffix} testout_tile.ppm 95
+      ${CMAKE_CROSSCOMPILING_EMULATOR} ${EMULATOR_CPU} ${CPU_PARAMETERS} tjbench${suffix} testout_tile.ppm 95
         -rgb -quiet -tile -benchtime 0.01 -warmup 0)
     set_tests_properties(tjbench-${libtype}-tile
       PROPERTIES DEPENDS tjbench-${libtype}-tile-cp)
 
     foreach(tile 8 16 32 64 128)
       add_test(tjbench-${libtype}-tile-gray-${tile}x${tile}-cmp
-        ${CMAKE_CROSSCOMPILING_EMULATOR} ${MD5CMP} ${MD5_PPM_GRAY_TILE}
+        ${CMAKE_CROSSCOMPILING_EMULATOR} ${EMULATOR_CPU} ${CPU_PARAMETERS} ${MD5CMP} ${MD5_PPM_GRAY_TILE}
           testout_tile_GRAY_Q95_${tile}x${tile}.ppm)
       foreach(subsamp 420 422)
         add_test(tjbench-${libtype}-tile-${subsamp}-${tile}x${tile}-cmp
-          ${CMAKE_CROSSCOMPILING_EMULATOR} ${MD5CMP}
+          ${CMAKE_CROSSCOMPILING_EMULATOR} ${EMULATOR_CPU} ${CPU_PARAMETERS} ${MD5CMP}
             ${MD5_PPM_${subsamp}_${tile}x${tile}_TILE}
             testout_tile_${subsamp}_Q95_${tile}x${tile}.ppm)
       endforeach()
       add_test(tjbench-${libtype}-tile-444-${tile}x${tile}-cmp
-        ${CMAKE_CROSSCOMPILING_EMULATOR} ${MD5CMP} ${MD5_PPM_444_TILE}
+        ${CMAKE_CROSSCOMPILING_EMULATOR} ${EMULATOR_CPU} ${CPU_PARAMETERS} ${MD5CMP} ${MD5_PPM_444_TILE}
           testout_tile_444_Q95_${tile}x${tile}.ppm)
       foreach(subsamp gray 420 422 444)
         set_tests_properties(tjbench-${libtype}-tile-${subsamp}-${tile}x${tile}-cmp
@@ -1015,21 +1048,21 @@ foreach(libtype ${TEST_LIBTYPES})
       ${CMAKE_COMMAND} -E copy_if_different ${TESTIMAGES}/testorig.ppm
         testout_tilem.ppm)
     add_test(tjbench-${libtype}-tilem
-      ${CMAKE_CROSSCOMPILING_EMULATOR} tjbench${suffix} testout_tilem.ppm 95
+      ${CMAKE_CROSSCOMPILING_EMULATOR} ${EMULATOR_CPU} ${CPU_PARAMETERS} tjbench${suffix} testout_tilem.ppm 95
         -rgb -fastupsample -quiet -tile -benchtime 0.01 -warmup 0)
     set_tests_properties(tjbench-${libtype}-tilem
       PROPERTIES DEPENDS tjbench-${libtype}-tilem-cp)
 
     add_test(tjbench-${libtype}-tile-420m-8x8-cmp
-      ${CMAKE_CROSSCOMPILING_EMULATOR} ${MD5CMP} ${MD5_PPM_420M_8x8_TILE}
+      ${CMAKE_CROSSCOMPILING_EMULATOR} ${EMULATOR_CPU} ${CPU_PARAMETERS} ${MD5CMP} ${MD5_PPM_420M_8x8_TILE}
         testout_tilem_420_Q95_8x8.ppm)
     add_test(tjbench-${libtype}-tile-422m-8x8-cmp
-      ${CMAKE_CROSSCOMPILING_EMULATOR} ${MD5CMP} ${MD5_PPM_422M_8x8_TILE}
+      ${CMAKE_CROSSCOMPILING_EMULATOR} ${EMULATOR_CPU} ${CPU_PARAMETERS} ${MD5CMP} ${MD5_PPM_422M_8x8_TILE}
         testout_tilem_422_Q95_8x8.ppm)
     foreach(tile 16 32 64 128)
       foreach(subsamp 420 422)
         add_test(tjbench-${libtype}-tile-${subsamp}m-${tile}x${tile}-cmp
-          ${CMAKE_CROSSCOMPILING_EMULATOR} ${MD5CMP}
+          ${CMAKE_CROSSCOMPILING_EMULATOR} ${EMULATOR_CPU} ${CPU_PARAMETERS} ${MD5CMP}
             ${MD5_PPM_${subsamp}M_TILE}
             testout_tilem_${subsamp}_Q95_${tile}x${tile}.ppm)
       endforeach()
@@ -1048,10 +1081,10 @@ foreach(libtype ${TEST_LIBTYPES})
 
   macro(add_bittest PROG NAME ARGS OUTFILE INFILE MD5SUM)
     add_test(${PROG}-${libtype}-${NAME}
-      ${CMAKE_CROSSCOMPILING_EMULATOR} ${PROG}${suffix} ${ARGS}
+      ${CMAKE_CROSSCOMPILING_EMULATOR} ${EMULATOR_CPU} ${CPU_PARAMETERS} ${PROG}${suffix} ${ARGS}
         -outfile ${OUTFILE} ${INFILE})
     add_test(${PROG}-${libtype}-${NAME}-cmp
-      ${CMAKE_CROSSCOMPILING_EMULATOR} ${MD5CMP} ${MD5SUM} ${OUTFILE})
+      ${CMAKE_CROSSCOMPILING_EMULATOR} ${EMULATOR_CPU} ${CPU_PARAMETERS} ${MD5CMP} ${MD5SUM} ${OUTFILE})
     set_tests_properties(${PROG}-${libtype}-${NAME}-cmp PROPERTIES
       DEPENDS ${PROG}-${libtype}-${NAME})
     if(${ARGC} GREATER 6)
@@ -1072,7 +1105,7 @@ foreach(libtype ${TEST_LIBTYPES})
     ${MD5_PPM_RGB_ISLOW} cjpeg-${libtype}-rgb-islow)
 
   add_test(djpeg-${libtype}-rgb-islow-icc-cmp
-    ${CMAKE_CROSSCOMPILING_EMULATOR} ${MD5CMP}
+    ${CMAKE_CROSSCOMPILING_EMULATOR} ${EMULATOR_CPU} ${CPU_PARAMETERS} ${MD5CMP}
       b06a39d730129122e85c1363ed1bbc9e testout_rgb_islow.icc)
   set_tests_properties(djpeg-${libtype}-rgb-islow-icc-cmp PROPERTIES
     DEPENDS djpeg-${libtype}-rgb-islow)
@@ -1302,7 +1335,7 @@ foreach(libtype ${TEST_LIBTYPES})
 
   # Context rows: Yes  Intra-iMCU row: No   iMCU row prefetch: No   ENT: prog huff
   add_test(cjpeg-${libtype}-420-islow-prog
-    ${CMAKE_CROSSCOMPILING_EMULATOR} cjpeg${suffix} -dct int -prog
+    ${CMAKE_CROSSCOMPILING_EMULATOR} ${EMULATOR_CPU} ${CPU_PARAMETERS} cjpeg${suffix} -dct int -prog
       -outfile testout_420_islow_prog.jpg ${TESTIMAGES}/testorig.ppm)
   add_bittest(djpeg 420-islow-prog-crop62x62_71_71
     "-dct;int;-crop;62x62+71+71;-ppm"
@@ -1319,7 +1352,7 @@ foreach(libtype ${TEST_LIBTYPES})
 
   # Context rows: No   Intra-iMCU row: Yes  ENT: huff
   add_test(cjpeg-${libtype}-444-islow
-    ${CMAKE_CROSSCOMPILING_EMULATOR} cjpeg${suffix} -dct int -sample 1x1
+    ${CMAKE_CROSSCOMPILING_EMULATOR} ${EMULATOR_CPU} ${CPU_PARAMETERS} cjpeg${suffix} -dct int -sample 1x1
       -outfile testout_444_islow.jpg ${TESTIMAGES}/testorig.ppm)
   add_bittest(djpeg 444-islow-skip1_6 "-dct;int;-skip;1,6;-ppm"
     testout_444_islow_skip1,6.ppm testout_444_islow.jpg
@@ -1327,7 +1360,7 @@ foreach(libtype ${TEST_LIBTYPES})
 
   # Context rows: No   Intra-iMCU row: No   ENT: prog huff
   add_test(cjpeg-${libtype}-444-islow-prog
-    ${CMAKE_CROSSCOMPILING_EMULATOR} cjpeg${suffix} -dct int -prog -sample 1x1
+    ${CMAKE_CROSSCOMPILING_EMULATOR} ${EMULATOR_CPU} ${CPU_PARAMETERS} cjpeg${suffix} -dct int -prog -sample 1x1
       -outfile testout_444_islow_prog.jpg ${TESTIMAGES}/testorig.ppm)
   add_bittest(djpeg 444-islow-prog-crop98x98_13_13
     "-dct;int;-crop;98x98+13+13;-ppm"
@@ -1337,7 +1370,7 @@ foreach(libtype ${TEST_LIBTYPES})
   # Context rows: No   Intra-iMCU row: No   ENT: arith
   if(WITH_ARITH_ENC)
     add_test(cjpeg-${libtype}-444-islow-ari
-      ${CMAKE_CROSSCOMPILING_EMULATOR} cjpeg${suffix} -dct int -arithmetic
+      ${CMAKE_CROSSCOMPILING_EMULATOR} ${EMULATOR_CPU} ${CPU_PARAMETERS} cjpeg${suffix} -dct int -arithmetic
         -sample 1x1 -outfile testout_444_islow_ari.jpg
         ${TESTIMAGES}/testorig.ppm)
     if(WITH_ARITH_DEC)
@@ -1392,14 +1425,15 @@ if(WITH_TURBOJPEG)
       COMMAND ${BASH} ${CMAKE_CURRENT_BINARY_DIR}/tjbenchtest.java -yuv
       COMMAND echo tjbenchtest.java -progressive
       COMMAND ${BASH} ${CMAKE_CURRENT_BINARY_DIR}/tjbenchtest.java -progressive
-      COMMAND echo tjexampletest.java -progressive -yuv
+      COMMAND echo tjbenchtest.java -progressive -yuv
       COMMAND ${BASH} ${CMAKE_CURRENT_BINARY_DIR}/tjbenchtest.java
         -progressive -yuv
       COMMAND echo tjexampletest.java
       COMMAND ${BASH} ${CMAKE_CURRENT_BINARY_DIR}/tjexampletest.java
       DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/tjbenchtest
         ${CMAKE_CURRENT_BINARY_DIR}/tjbenchtest.java
-        ${CMAKE_CURRENT_BINARY_DIR}/tjexampletest)
+        ${CMAKE_CURRENT_BINARY_DIR}/tjexampletest
+        ${CMAKE_CURRENT_BINARY_DIR}/tjexampletest.java)
   else()
     add_custom_target(tjtest
       COMMAND echo tjbenchtest
@@ -1416,7 +1450,8 @@ if(WITH_TURBOJPEG)
       COMMAND ${BASH} ${CMAKE_CURRENT_BINARY_DIR}/tjbenchtest -progressive -yuv
       COMMAND echo tjexampletest
       COMMAND ${BASH} ${CMAKE_CURRENT_BINARY_DIR}/tjexampletest
-      DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/tjbenchtest)
+      DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/tjbenchtest
+        ${CMAKE_CURRENT_BINARY_DIR}/tjexampletest)
   endif()
 endif()
 
@@ -1447,7 +1482,7 @@ if(WITH_TURBOJPEG)
       INCLUDES DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}
       ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR})
     if(NOT ENABLE_SHARED)
-      if(MSVC_IDE OR XCODE)
+      if(GENERATOR_IS_MULTI_CONFIG)
         set(DIR "${CMAKE_CURRENT_BINARY_DIR}/\${CMAKE_INSTALL_CONFIG_NAME}")
       else()
         set(DIR ${CMAKE_CURRENT_BINARY_DIR})
@@ -1465,7 +1500,7 @@ if(ENABLE_STATIC)
     INCLUDES DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}
     ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR})
   if(NOT ENABLE_SHARED)
-    if(MSVC_IDE OR XCODE)
+    if(GENERATOR_IS_MULTI_CONFIG)
       set(DIR "${CMAKE_CURRENT_BINARY_DIR}/\${CMAKE_INSTALL_CONFIG_NAME}")
     else()
       set(DIR ${CMAKE_CURRENT_BINARY_DIR})
diff --git a/ChangeLog.md b/ChangeLog.md
index b0d166e..a547522 100644
--- a/ChangeLog.md
+++ b/ChangeLog.md
@@ -1,7 +1,62 @@
+2.1.5
+=====
+
+### Significant changes relative to 2.1.4:
+
+1. Fixed issues in the build system whereby, when using the Ninja Multi-Config
+CMake generator, a static build of libjpeg-turbo (a build in which
+`ENABLE_SHARED` is `0`) could not be installed, a Windows installer could not
+be built, and the Java regression tests failed.
+
+2. Fixed a regression introduced by 2.0 beta1[15] that caused a buffer overrun
+in the progressive Huffman encoder when attempting to transform a
+specially-crafted malformed 12-bit-per-component JPEG image into a progressive
+12-bit-per-component JPEG image using a 12-bit-per-component build of
+libjpeg-turbo (`-DWITH_12BIT=1`.)  Given that the buffer overrun was fully
+contained within the progressive Huffman encoder structure and did not cause a
+segfault or other user-visible errant behavior, given that the lossless
+transformer (unlike the decompressor) is not generally exposed to arbitrary
+data exploits, and given that 12-bit-per-component builds of libjpeg-turbo are
+uncommon, this issue did not likely pose a security risk.
+
+3. Fixed an issue whereby, when using a 12-bit-per-component build of
+libjpeg-turbo (`-DWITH_12BIT=1`), passing samples with values greater than 4095
+or less than 0 to `jpeg_write_scanlines()` caused a buffer overrun or underrun
+in the RGB-to-YCbCr color converter.
+
+4. Fixed a floating point exception that occurred when attempting to use the
+jpegtran `-drop` and `-trim` options to losslessly transform a
+specially-crafted malformed JPEG image.
+
+5. Fixed an issue in `tjBufSizeYUV2()` whereby it returned a bogus result,
+rather than throwing an error, if the `align` parameter was not a power of 2.
+Fixed a similar issue in `tjCompressFromYUV()` whereby it generated a corrupt
+JPEG image in certain cases, rather than throwing an error, if the `align`
+parameter was not a power of 2.
+
+6. Fixed an issue whereby `tjDecompressToYUV2()`, which is a wrapper for
+`tjDecompressToYUVPlanes()`, used the desired YUV image dimensions rather than
+the actual scaled image dimensions when computing the plane pointers and
+strides to pass to `tjDecompressToYUVPlanes()`.  This caused a buffer overrun
+and subsequent segfault if the desired image dimensions exceeded the scaled
+image dimensions.
+
+7. Fixed an issue whereby, when decompressing a 12-bit-per-component JPEG image
+(`-DWITH_12BIT=1`) using an alpha-enabled output color space such as
+`JCS_EXT_RGBA`, the alpha channel was set to 255 rather than 4095.
+
+8. Fixed an issue whereby the Java version of TJBench did not accept a range of
+quality values.
+
+9. Fixed an issue whereby, when `-progressive` was passed to TJBench, the JPEG
+input image was not transformed into a progressive JPEG image prior to
+decompression.
+
+
 2.1.4
 =====
 
-### Significant changes relative to 2.1.3
+### Significant changes relative to 2.1.3:
 
 1. Fixed a regression introduced in 2.1.3 that caused build failures with
 Visual Studio 2010.
@@ -36,7 +91,7 @@ virtual array access") under certain circumstances.
 2.1.3
 =====
 
-### Significant changes relative to 2.1.2
+### Significant changes relative to 2.1.2:
 
 1. Fixed a regression introduced by 2.0 beta1[7] whereby cjpeg compressed PGM
 input files into full-color JPEG images unless the `-grayscale` option was
@@ -60,7 +115,7 @@ be reproduced using the libjpeg API, not using djpeg.
 2.1.2
 =====
 
-### Significant changes relative to 2.1.1
+### Significant changes relative to 2.1.1:
 
 1. Fixed a regression introduced by 2.1 beta1[13] that caused the remaining
 GAS implementations of AArch64 (Arm 64-bit) Neon SIMD functions (which are used
@@ -92,7 +147,7 @@ image contains incomplete or corrupt image data.
 2.1.1
 =====
 
-### Significant changes relative to 2.1.0
+### Significant changes relative to 2.1.0:
 
 1. Fixed a regression introduced in 2.1.0 that caused build failures with
 non-GCC-compatible compilers for Un*x/Arm platforms.
@@ -121,7 +176,7 @@ transform a specially-crafted malformed JPEG image.
 2.1.0
 =====
 
-### Significant changes relative to 2.1 beta1
+### Significant changes relative to 2.1 beta1:
 
 1. Fixed a regression introduced by 2.1 beta1[6(b)] whereby attempting to
 decompress certain progressive JPEG images with one or more component planes of
@@ -156,10 +211,10 @@ progressive JPEG format described in the report
 ["Two Issues with the JPEG Standard"](https://libjpeg-turbo.org/pmwiki/uploads/About/TwoIssueswiththeJPEGStandard.pdf).
 
 7. The PPM reader now throws an error, rather than segfaulting (due to a buffer
-overrun) or generating incorrect pixels, if an application attempts to use the
-`tjLoadImage()` function to load a 16-bit binary PPM file (a binary PPM file
-with a maximum value greater than 255) into a grayscale image buffer or to load
-a 16-bit binary PGM file into an RGB image buffer.
+overrun, CVE-2021-46822) or generating incorrect pixels, if an application
+attempts to use the `tjLoadImage()` function to load a 16-bit binary PPM file
+(a binary PPM file with a maximum value greater than 255) into a grayscale
+image buffer or to load a 16-bit binary PGM file into an RGB image buffer.
 
 8. Fixed an issue in the PPM reader that caused incorrect pixels to be
 generated when using the `tjLoadImage()` function to load a 16-bit binary PPM
@@ -325,11 +380,11 @@ methods in the TurboJPEG Java API.
 
 2. Fixed or worked around multiple issues with `jpeg_skip_scanlines()`:
 
-     - Fixed segfaults or "Corrupt JPEG data: premature end of data segment"
-errors in `jpeg_skip_scanlines()` that occurred when decompressing 4:2:2 or
-4:2:0 JPEG images using merged (non-fancy) upsampling/color conversion (that
-is, when setting `cinfo.do_fancy_upsampling` to `FALSE`.)  2.0.0[6] was a
-similar fix, but it did not cover all cases.
+     - Fixed segfaults (CVE-2020-35538) or "Corrupt JPEG data: premature end of
+data segment" errors in `jpeg_skip_scanlines()` that occurred when
+decompressing 4:2:2 or 4:2:0 JPEG images using merged (non-fancy)
+upsampling/color conversion (that is, when setting `cinfo.do_fancy_upsampling`
+to `FALSE`.)  2.0.0[6] was a similar fix, but it did not cover all cases.
      - `jpeg_skip_scanlines()` now throws an error if two-pass color
 quantization is enabled.  Two-pass color quantization never worked properly
 with `jpeg_skip_scanlines()`, and the issues could not readily be fixed.
diff --git a/LICENSE.md b/LICENSE.md
index d753e1d..bf8a7fd 100644
--- a/LICENSE.md
+++ b/LICENSE.md
@@ -91,7 +91,7 @@ best of our understanding.
 The Modified (3-clause) BSD License
 ===================================
 
-Copyright (C)2009-2022 D. R. Commander.  All Rights Reserved.<br>
+Copyright (C)2009-2023 D. R. Commander.  All Rights Reserved.<br>
 Copyright (C)2015 Viktor Szathmáry.  All Rights Reserved.
 
 Redistribution and use in source and binary forms, with or without
diff --git a/cmakescripts/BuildPackages.cmake b/cmakescripts/BuildPackages.cmake
index 7d6fa2c..2e0170f 100644
--- a/cmakescripts/BuildPackages.cmake
+++ b/cmakescripts/BuildPackages.cmake
@@ -90,7 +90,7 @@ if(WITH_JAVA)
   set(INST_DEFS ${INST_DEFS} -DJAVA)
 endif()
 
-if(MSVC_IDE)
+if(GENERATOR_IS_MULTI_CONFIG)
   set(INST_DEFS ${INST_DEFS} "-DBUILDDIR=${CMAKE_CFG_INTDIR}\\")
 else()
   set(INST_DEFS ${INST_DEFS} "-DBUILDDIR=")
diff --git a/cmyk.h b/cmyk.h
index 48187a8..b6ca20f 100644
--- a/cmyk.h
+++ b/cmyk.h
@@ -17,7 +17,6 @@
 #include <jinclude.h>
 #define JPEG_INTERNALS
 #include <jpeglib.h>
-#include "jconfigint.h"
 
 
 /* Fully reversible */
diff --git a/djpeg.c b/djpeg.c
index 7666e3f..c22c4ca 100644
--- a/djpeg.c
+++ b/djpeg.c
@@ -316,7 +316,9 @@ parse_switches(j_decompress_ptr cinfo, int argc, char **argv,
       if (++argn >= argc)       /* advance to next argument */
         usage();
       icc_filename = argv[argn];
+#ifdef SAVE_MARKERS_SUPPORTED
       jpeg_save_markers(cinfo, JPEG_APP0 + 2, 0xFFFF);
+#endif
 
     } else if (keymatch(arg, "map", 3)) {
       /* Quantize to a color map taken from an input file. */
diff --git a/doc/html/group___turbo_j_p_e_g.html b/doc/html/group___turbo_j_p_e_g.html
index 63d4791..39fe4d7 100644
--- a/doc/html/group___turbo_j_p_e_g.html
+++ b/doc/html/group___turbo_j_p_e_g.html
@@ -102,22 +102,22 @@ Macros</h2></td></tr>
 <tr class="memdesc:ga39f57a6fb02d9cf32e7b6890099b5a71"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of JPEG colorspaces.  <a href="group___turbo_j_p_e_g.html#ga39f57a6fb02d9cf32e7b6890099b5a71">More...</a><br /></td></tr>
 <tr class="separator:ga39f57a6fb02d9cf32e7b6890099b5a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
 <tr class="memitem:ga72ecf4ebe6eb702d3c6f5ca27455e1ec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#ga72ecf4ebe6eb702d3c6f5ca27455e1ec">TJFLAG_BOTTOMUP</a></td></tr>
-<tr class="memdesc:ga72ecf4ebe6eb702d3c6f5ca27455e1ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">The uncompressed source/destination image is stored in bottom-up (Windows, OpenGL) order, not top-down (X11) order.  <a href="group___turbo_j_p_e_g.html#ga72ecf4ebe6eb702d3c6f5ca27455e1ec">More...</a><br /></td></tr>
+<tr class="memdesc:ga72ecf4ebe6eb702d3c6f5ca27455e1ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rows in the packed-pixel source/destination image are stored in bottom-up (Windows, OpenGL) order rather than in top-down (X11) order.  <a href="group___turbo_j_p_e_g.html#ga72ecf4ebe6eb702d3c6f5ca27455e1ec">More...</a><br /></td></tr>
 <tr class="separator:ga72ecf4ebe6eb702d3c6f5ca27455e1ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
 <tr class="memitem:ga4ee4506c81177a06f77e2504a22efd2d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#ga4ee4506c81177a06f77e2504a22efd2d">TJFLAG_FASTUPSAMPLE</a></td></tr>
-<tr class="memdesc:ga4ee4506c81177a06f77e2504a22efd2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">When decompressing an image that was compressed using chrominance subsampling, use the fastest chrominance upsampling algorithm available in the underlying codec.  <a href="group___turbo_j_p_e_g.html#ga4ee4506c81177a06f77e2504a22efd2d">More...</a><br /></td></tr>
+<tr class="memdesc:ga4ee4506c81177a06f77e2504a22efd2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">When decompressing an image that was compressed using chrominance subsampling, use the fastest chrominance upsampling algorithm available.  <a href="group___turbo_j_p_e_g.html#ga4ee4506c81177a06f77e2504a22efd2d">More...</a><br /></td></tr>
 <tr class="separator:ga4ee4506c81177a06f77e2504a22efd2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
 <tr class="memitem:ga8808d403c68b62aaa58a4c1e58e98963"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#ga8808d403c68b62aaa58a4c1e58e98963">TJFLAG_NOREALLOC</a></td></tr>
-<tr class="memdesc:ga8808d403c68b62aaa58a4c1e58e98963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable buffer (re)allocation.  <a href="group___turbo_j_p_e_g.html#ga8808d403c68b62aaa58a4c1e58e98963">More...</a><br /></td></tr>
+<tr class="memdesc:ga8808d403c68b62aaa58a4c1e58e98963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable JPEG buffer (re)allocation.  <a href="group___turbo_j_p_e_g.html#ga8808d403c68b62aaa58a4c1e58e98963">More...</a><br /></td></tr>
 <tr class="separator:ga8808d403c68b62aaa58a4c1e58e98963"><td class="memSeparator" colspan="2">&#160;</td></tr>
 <tr class="memitem:gaabce235db80d3f698b27f36cbd453da2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#gaabce235db80d3f698b27f36cbd453da2">TJFLAG_FASTDCT</a></td></tr>
-<tr class="memdesc:gaabce235db80d3f698b27f36cbd453da2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the fastest DCT/IDCT algorithm available in the underlying codec.  <a href="group___turbo_j_p_e_g.html#gaabce235db80d3f698b27f36cbd453da2">More...</a><br /></td></tr>
+<tr class="memdesc:gaabce235db80d3f698b27f36cbd453da2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the fastest DCT/IDCT algorithm available.  <a href="group___turbo_j_p_e_g.html#gaabce235db80d3f698b27f36cbd453da2">More...</a><br /></td></tr>
 <tr class="separator:gaabce235db80d3f698b27f36cbd453da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
 <tr class="memitem:gacb233cfd722d66d1ccbf48a7de81f0e0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#gacb233cfd722d66d1ccbf48a7de81f0e0">TJFLAG_ACCURATEDCT</a></td></tr>
-<tr class="memdesc:gacb233cfd722d66d1ccbf48a7de81f0e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the most accurate DCT/IDCT algorithm available in the underlying codec.  <a href="group___turbo_j_p_e_g.html#gacb233cfd722d66d1ccbf48a7de81f0e0">More...</a><br /></td></tr>
+<tr class="memdesc:gacb233cfd722d66d1ccbf48a7de81f0e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the most accurate DCT/IDCT algorithm available.  <a href="group___turbo_j_p_e_g.html#gacb233cfd722d66d1ccbf48a7de81f0e0">More...</a><br /></td></tr>
 <tr class="separator:gacb233cfd722d66d1ccbf48a7de81f0e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
 <tr class="memitem:ga519cfa4ef6c18d9e5b455fdf59306a3a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#ga519cfa4ef6c18d9e5b455fdf59306a3a">TJFLAG_STOPONWARNING</a></td></tr>
-<tr class="memdesc:ga519cfa4ef6c18d9e5b455fdf59306a3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Immediately discontinue the current compression/decompression/transform operation if the underlying codec throws a warning (non-fatal error).  <a href="group___turbo_j_p_e_g.html#ga519cfa4ef6c18d9e5b455fdf59306a3a">More...</a><br /></td></tr>
+<tr class="memdesc:ga519cfa4ef6c18d9e5b455fdf59306a3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Immediately discontinue the current compression/decompression/transform operation if a warning (non-fatal error) occurs.  <a href="group___turbo_j_p_e_g.html#ga519cfa4ef6c18d9e5b455fdf59306a3a">More...</a><br /></td></tr>
 <tr class="separator:ga519cfa4ef6c18d9e5b455fdf59306a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
 <tr class="memitem:ga43b426750b46190a25d34a67ef76df1b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#ga43b426750b46190a25d34a67ef76df1b">TJFLAG_PROGRESSIVE</a></td></tr>
 <tr class="memdesc:ga43b426750b46190a25d34a67ef76df1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use progressive entropy coding in JPEG images generated by the compression and transform functions.  <a href="group___turbo_j_p_e_g.html#ga43b426750b46190a25d34a67ef76df1b">More...</a><br /></td></tr>
@@ -141,19 +141,19 @@ Macros</h2></td></tr>
 <tr class="memdesc:ga9c771a757fc1294add611906b89ab2d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This option will enable lossless cropping.  <a href="group___turbo_j_p_e_g.html#ga9c771a757fc1294add611906b89ab2d2">More...</a><br /></td></tr>
 <tr class="separator:ga9c771a757fc1294add611906b89ab2d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
 <tr class="memitem:ga3acee7b48ade1b99e5588736007c2589"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#ga3acee7b48ade1b99e5588736007c2589">TJXOPT_GRAY</a></td></tr>
-<tr class="memdesc:ga3acee7b48ade1b99e5588736007c2589"><td class="mdescLeft">&#160;</td><td class="mdescRight">This option will discard the color data in the input image and produce a grayscale output image.  <a href="group___turbo_j_p_e_g.html#ga3acee7b48ade1b99e5588736007c2589">More...</a><br /></td></tr>
+<tr class="memdesc:ga3acee7b48ade1b99e5588736007c2589"><td class="mdescLeft">&#160;</td><td class="mdescRight">This option will discard the color data in the source image and produce a grayscale destination image.  <a href="group___turbo_j_p_e_g.html#ga3acee7b48ade1b99e5588736007c2589">More...</a><br /></td></tr>
 <tr class="separator:ga3acee7b48ade1b99e5588736007c2589"><td class="memSeparator" colspan="2">&#160;</td></tr>
 <tr class="memitem:gafbf992bbf6e006705886333703ffab31"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#gafbf992bbf6e006705886333703ffab31">TJXOPT_NOOUTPUT</a></td></tr>
-<tr class="memdesc:gafbf992bbf6e006705886333703ffab31"><td class="mdescLeft">&#160;</td><td class="mdescRight">This option will prevent <a class="el" href="group___turbo_j_p_e_g.html#ga9cb8abf4cc91881e04a0329b2270be25" title="Losslessly transform a JPEG image into another JPEG image.">tjTransform()</a> from outputting a JPEG image for this particular transform (this can be used in conjunction with a custom filter to capture the transformed DCT coefficients without transcoding them.)  <a href="group___turbo_j_p_e_g.html#gafbf992bbf6e006705886333703ffab31">More...</a><br /></td></tr>
+<tr class="memdesc:gafbf992bbf6e006705886333703ffab31"><td class="mdescLeft">&#160;</td><td class="mdescRight">This option will prevent <a class="el" href="group___turbo_j_p_e_g.html#ga9cb8abf4cc91881e04a0329b2270be25" title="Losslessly transform a JPEG image into another JPEG image.">tjTransform()</a> from outputting a JPEG image for this particular transform.  <a href="group___turbo_j_p_e_g.html#gafbf992bbf6e006705886333703ffab31">More...</a><br /></td></tr>
 <tr class="separator:gafbf992bbf6e006705886333703ffab31"><td class="memSeparator" colspan="2">&#160;</td></tr>
 <tr class="memitem:gad2371c80674584ecc1a7d75e564cf026"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#gad2371c80674584ecc1a7d75e564cf026">TJXOPT_PROGRESSIVE</a></td></tr>
-<tr class="memdesc:gad2371c80674584ecc1a7d75e564cf026"><td class="mdescLeft">&#160;</td><td class="mdescRight">This option will enable progressive entropy coding in the output image generated by this particular transform.  <a href="group___turbo_j_p_e_g.html#gad2371c80674584ecc1a7d75e564cf026">More...</a><br /></td></tr>
+<tr class="memdesc:gad2371c80674584ecc1a7d75e564cf026"><td class="mdescLeft">&#160;</td><td class="mdescRight">This option will enable progressive entropy coding in the JPEG image generated by this particular transform.  <a href="group___turbo_j_p_e_g.html#gad2371c80674584ecc1a7d75e564cf026">More...</a><br /></td></tr>
 <tr class="separator:gad2371c80674584ecc1a7d75e564cf026"><td class="memSeparator" colspan="2">&#160;</td></tr>
 <tr class="memitem:ga153b468cfb905d0de61706c838986fe8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#ga153b468cfb905d0de61706c838986fe8">TJXOPT_COPYNONE</a></td></tr>
-<tr class="memdesc:ga153b468cfb905d0de61706c838986fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This option will prevent <a class="el" href="group___turbo_j_p_e_g.html#ga9cb8abf4cc91881e04a0329b2270be25" title="Losslessly transform a JPEG image into another JPEG image.">tjTransform()</a> from copying any extra markers (including EXIF and ICC profile data) from the source image to the output image.  <a href="group___turbo_j_p_e_g.html#ga153b468cfb905d0de61706c838986fe8">More...</a><br /></td></tr>
+<tr class="memdesc:ga153b468cfb905d0de61706c838986fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This option will prevent <a class="el" href="group___turbo_j_p_e_g.html#ga9cb8abf4cc91881e04a0329b2270be25" title="Losslessly transform a JPEG image into another JPEG image.">tjTransform()</a> from copying any extra markers (including EXIF and ICC profile data) from the source image to the destination image.  <a href="group___turbo_j_p_e_g.html#ga153b468cfb905d0de61706c838986fe8">More...</a><br /></td></tr>
 <tr class="separator:ga153b468cfb905d0de61706c838986fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
 <tr class="memitem:ga0aba955473315e405295d978f0c16511"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#ga0aba955473315e405295d978f0c16511">TJPAD</a>(width)</td></tr>
-<tr class="memdesc:ga0aba955473315e405295d978f0c16511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pad the given width to the nearest 32-bit boundary.  <a href="group___turbo_j_p_e_g.html#ga0aba955473315e405295d978f0c16511">More...</a><br /></td></tr>
+<tr class="memdesc:ga0aba955473315e405295d978f0c16511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pad the given width to the nearest multiple of 4.  <a href="group___turbo_j_p_e_g.html#ga0aba955473315e405295d978f0c16511">More...</a><br /></td></tr>
 <tr class="separator:ga0aba955473315e405295d978f0c16511"><td class="memSeparator" colspan="2">&#160;</td></tr>
 <tr class="memitem:ga84878bb65404204743aa18cac02781df"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#ga84878bb65404204743aa18cac02781df">TJSCALED</a>(dimension,  scalingFactor)</td></tr>
 <tr class="memdesc:ga84878bb65404204743aa18cac02781df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the scaled value of <code>dimension</code> using the given scaling factor.  <a href="group___turbo_j_p_e_g.html#ga84878bb65404204743aa18cac02781df">More...</a><br /></td></tr>
@@ -240,20 +240,20 @@ Functions</h2></td></tr>
 <tr class="memdesc:ga9d63a05fc6d813f4aae06107041a37e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a TurboJPEG compressor instance.  <a href="group___turbo_j_p_e_g.html#ga9d63a05fc6d813f4aae06107041a37e8">More...</a><br /></td></tr>
 <tr class="separator:ga9d63a05fc6d813f4aae06107041a37e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
 <tr class="memitem:gafbdce0112fd78fd38efae841443a9bcf"><td class="memItemLeft" align="right" valign="top">DLLEXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#gafbdce0112fd78fd38efae841443a9bcf">tjCompress2</a> (<a class="el" href="group___turbo_j_p_e_g.html#ga758d2634ecb4949de7815cba621f5763">tjhandle</a> handle, const unsigned char *srcBuf, int width, int pitch, int height, int pixelFormat, unsigned char **jpegBuf, unsigned long *jpegSize, int jpegSubsamp, int jpegQual, int flags)</td></tr>
-<tr class="memdesc:gafbdce0112fd78fd38efae841443a9bcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compress an RGB, grayscale, or CMYK image into a JPEG image.  <a href="group___turbo_j_p_e_g.html#gafbdce0112fd78fd38efae841443a9bcf">More...</a><br /></td></tr>
+<tr class="memdesc:gafbdce0112fd78fd38efae841443a9bcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compress a packed-pixel RGB, grayscale, or CMYK image into a JPEG image.  <a href="group___turbo_j_p_e_g.html#gafbdce0112fd78fd38efae841443a9bcf">More...</a><br /></td></tr>
 <tr class="separator:gafbdce0112fd78fd38efae841443a9bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
-<tr class="memitem:ga7622a459b79aa1007e005b58783f875b"><td class="memItemLeft" align="right" valign="top">DLLEXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#ga7622a459b79aa1007e005b58783f875b">tjCompressFromYUV</a> (<a class="el" href="group___turbo_j_p_e_g.html#ga758d2634ecb4949de7815cba621f5763">tjhandle</a> handle, const unsigned char *srcBuf, int width, int pad, int height, int subsamp, unsigned char **jpegBuf, unsigned long *jpegSize, int jpegQual, int flags)</td></tr>
-<tr class="memdesc:ga7622a459b79aa1007e005b58783f875b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compress a YUV planar image into a JPEG image.  <a href="group___turbo_j_p_e_g.html#ga7622a459b79aa1007e005b58783f875b">More...</a><br /></td></tr>
-<tr class="separator:ga7622a459b79aa1007e005b58783f875b"><td class="memSeparator" colspan="2">&#160;</td></tr>
+<tr class="memitem:gab40f5096a72fd7e5bda9d6b58fa37e2e"><td class="memItemLeft" align="right" valign="top">DLLEXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#gab40f5096a72fd7e5bda9d6b58fa37e2e">tjCompressFromYUV</a> (<a class="el" href="group___turbo_j_p_e_g.html#ga758d2634ecb4949de7815cba621f5763">tjhandle</a> handle, const unsigned char *srcBuf, int width, int align, int height, int subsamp, unsigned char **jpegBuf, unsigned long *jpegSize, int jpegQual, int flags)</td></tr>
+<tr class="memdesc:gab40f5096a72fd7e5bda9d6b58fa37e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compress a unified planar YUV image into a JPEG image.  <a href="group___turbo_j_p_e_g.html#gab40f5096a72fd7e5bda9d6b58fa37e2e">More...</a><br /></td></tr>
+<tr class="separator:gab40f5096a72fd7e5bda9d6b58fa37e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
 <tr class="memitem:ga29ec5dfbd2d84b8724e951d6fa0d5d9e"><td class="memItemLeft" align="right" valign="top">DLLEXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#ga29ec5dfbd2d84b8724e951d6fa0d5d9e">tjCompressFromYUVPlanes</a> (<a class="el" href="group___turbo_j_p_e_g.html#ga758d2634ecb4949de7815cba621f5763">tjhandle</a> handle, const unsigned char **srcPlanes, int width, const int *strides, int height, int subsamp, unsigned char **jpegBuf, unsigned long *jpegSize, int jpegQual, int flags)</td></tr>
 <tr class="memdesc:ga29ec5dfbd2d84b8724e951d6fa0d5d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compress a set of Y, U (Cb), and V (Cr) image planes into a JPEG image.  <a href="group___turbo_j_p_e_g.html#ga29ec5dfbd2d84b8724e951d6fa0d5d9e">More...</a><br /></td></tr>
 <tr class="separator:ga29ec5dfbd2d84b8724e951d6fa0d5d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
 <tr class="memitem:ga67ac12fee79073242cb216e07c9f1f90"><td class="memItemLeft" align="right" valign="top">DLLEXPORT unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#ga67ac12fee79073242cb216e07c9f1f90">tjBufSize</a> (int width, int height, int jpegSubsamp)</td></tr>
 <tr class="memdesc:ga67ac12fee79073242cb216e07c9f1f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum size of the buffer (in bytes) required to hold a JPEG image with the given parameters.  <a href="group___turbo_j_p_e_g.html#ga67ac12fee79073242cb216e07c9f1f90">More...</a><br /></td></tr>
 <tr class="separator:ga67ac12fee79073242cb216e07c9f1f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
-<tr class="memitem:ga2be2b9969d4df9ecce9b05deed273194"><td class="memItemLeft" align="right" valign="top">DLLEXPORT unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#ga2be2b9969d4df9ecce9b05deed273194">tjBufSizeYUV2</a> (int width, int pad, int height, int subsamp)</td></tr>
-<tr class="memdesc:ga2be2b9969d4df9ecce9b05deed273194"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the buffer (in bytes) required to hold a YUV planar image with the given parameters.  <a href="group___turbo_j_p_e_g.html#ga2be2b9969d4df9ecce9b05deed273194">More...</a><br /></td></tr>
-<tr class="separator:ga2be2b9969d4df9ecce9b05deed273194"><td class="memSeparator" colspan="2">&#160;</td></tr>
+<tr class="memitem:ga5e5aac9e8bcf17049279301e2466474c"><td class="memItemLeft" align="right" valign="top">DLLEXPORT unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#ga5e5aac9e8bcf17049279301e2466474c">tjBufSizeYUV2</a> (int width, int align, int height, int subsamp)</td></tr>
+<tr class="memdesc:ga5e5aac9e8bcf17049279301e2466474c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the buffer (in bytes) required to hold a unified planar YUV image with the given parameters.  <a href="group___turbo_j_p_e_g.html#ga5e5aac9e8bcf17049279301e2466474c">More...</a><br /></td></tr>
+<tr class="separator:ga5e5aac9e8bcf17049279301e2466474c"><td class="memSeparator" colspan="2">&#160;</td></tr>
 <tr class="memitem:gab4ab7b24f6e797d79abaaa670373961d"><td class="memItemLeft" align="right" valign="top">DLLEXPORT unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#gab4ab7b24f6e797d79abaaa670373961d">tjPlaneSizeYUV</a> (int componentID, int width, int stride, int height, int subsamp)</td></tr>
 <tr class="memdesc:gab4ab7b24f6e797d79abaaa670373961d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the buffer (in bytes) required to hold a YUV image plane with the given parameters.  <a href="group___turbo_j_p_e_g.html#gab4ab7b24f6e797d79abaaa670373961d">More...</a><br /></td></tr>
 <tr class="separator:gab4ab7b24f6e797d79abaaa670373961d"><td class="memSeparator" colspan="2">&#160;</td></tr>
@@ -263,11 +263,11 @@ Functions</h2></td></tr>
 <tr class="memitem:ga1a209696c6a80748f20e134b3c64789f"><td class="memItemLeft" align="right" valign="top">DLLEXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#ga1a209696c6a80748f20e134b3c64789f">tjPlaneHeight</a> (int componentID, int height, int subsamp)</td></tr>
 <tr class="memdesc:ga1a209696c6a80748f20e134b3c64789f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The plane height of a YUV image plane with the given parameters.  <a href="group___turbo_j_p_e_g.html#ga1a209696c6a80748f20e134b3c64789f">More...</a><br /></td></tr>
 <tr class="separator:ga1a209696c6a80748f20e134b3c64789f"><td class="memSeparator" colspan="2">&#160;</td></tr>
-<tr class="memitem:gac519b922cdf446e97d0cdcba513636bf"><td class="memItemLeft" align="right" valign="top">DLLEXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#gac519b922cdf446e97d0cdcba513636bf">tjEncodeYUV3</a> (<a class="el" href="group___turbo_j_p_e_g.html#ga758d2634ecb4949de7815cba621f5763">tjhandle</a> handle, const unsigned char *srcBuf, int width, int pitch, int height, int pixelFormat, unsigned char *dstBuf, int pad, int subsamp, int flags)</td></tr>
-<tr class="memdesc:gac519b922cdf446e97d0cdcba513636bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode an RGB or grayscale image into a YUV planar image.  <a href="group___turbo_j_p_e_g.html#gac519b922cdf446e97d0cdcba513636bf">More...</a><br /></td></tr>
-<tr class="separator:gac519b922cdf446e97d0cdcba513636bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
+<tr class="memitem:ga5d619e0a02b71e05a8dffb764f6d7a64"><td class="memItemLeft" align="right" valign="top">DLLEXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#ga5d619e0a02b71e05a8dffb764f6d7a64">tjEncodeYUV3</a> (<a class="el" href="group___turbo_j_p_e_g.html#ga758d2634ecb4949de7815cba621f5763">tjhandle</a> handle, const unsigned char *srcBuf, int width, int pitch, int height, int pixelFormat, unsigned char *dstBuf, int align, int subsamp, int flags)</td></tr>
+<tr class="memdesc:ga5d619e0a02b71e05a8dffb764f6d7a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode a packed-pixel RGB or grayscale image into a unified planar YUV image.  <a href="group___turbo_j_p_e_g.html#ga5d619e0a02b71e05a8dffb764f6d7a64">More...</a><br /></td></tr>
+<tr class="separator:ga5d619e0a02b71e05a8dffb764f6d7a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
 <tr class="memitem:gae2d04c72457fe7f4d60cf78ab1b1feb1"><td class="memItemLeft" align="right" valign="top">DLLEXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#gae2d04c72457fe7f4d60cf78ab1b1feb1">tjEncodeYUVPlanes</a> (<a class="el" href="group___turbo_j_p_e_g.html#ga758d2634ecb4949de7815cba621f5763">tjhandle</a> handle, const unsigned char *srcBuf, int width, int pitch, int height, int pixelFormat, unsigned char **dstPlanes, int *strides, int subsamp, int flags)</td></tr>
-<tr class="memdesc:gae2d04c72457fe7f4d60cf78ab1b1feb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode an RGB or grayscale image into separate Y, U (Cb), and V (Cr) image planes.  <a href="group___turbo_j_p_e_g.html#gae2d04c72457fe7f4d60cf78ab1b1feb1">More...</a><br /></td></tr>
+<tr class="memdesc:gae2d04c72457fe7f4d60cf78ab1b1feb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode a packed-pixel RGB or grayscale image into separate Y, U (Cb), and V (Cr) image planes.  <a href="group___turbo_j_p_e_g.html#gae2d04c72457fe7f4d60cf78ab1b1feb1">More...</a><br /></td></tr>
 <tr class="separator:gae2d04c72457fe7f4d60cf78ab1b1feb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
 <tr class="memitem:ga52300eac3f3d9ef4bab303bc244f62d3"><td class="memItemLeft" align="right" valign="top">DLLEXPORT <a class="el" href="group___turbo_j_p_e_g.html#ga758d2634ecb4949de7815cba621f5763">tjhandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#ga52300eac3f3d9ef4bab303bc244f62d3">tjInitDecompress</a> (void)</td></tr>
 <tr class="memdesc:ga52300eac3f3d9ef4bab303bc244f62d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a TurboJPEG decompressor instance.  <a href="group___turbo_j_p_e_g.html#ga52300eac3f3d9ef4bab303bc244f62d3">More...</a><br /></td></tr>
@@ -275,23 +275,23 @@ Functions</h2></td></tr>
 <tr class="memitem:ga0595681096bba7199cc6f3533cb25f77"><td class="memItemLeft" align="right" valign="top">DLLEXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#ga0595681096bba7199cc6f3533cb25f77">tjDecompressHeader3</a> (<a class="el" href="group___turbo_j_p_e_g.html#ga758d2634ecb4949de7815cba621f5763">tjhandle</a> handle, const unsigned char *jpegBuf, unsigned long jpegSize, int *width, int *height, int *jpegSubsamp, int *jpegColorspace)</td></tr>
 <tr class="memdesc:ga0595681096bba7199cc6f3533cb25f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve information about a JPEG image without decompressing it, or prime the decompressor with quantization and Huffman tables.  <a href="group___turbo_j_p_e_g.html#ga0595681096bba7199cc6f3533cb25f77">More...</a><br /></td></tr>
 <tr class="separator:ga0595681096bba7199cc6f3533cb25f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
-<tr class="memitem:gac3854476006b10787bd128f7ede48057"><td class="memItemLeft" align="right" valign="top">DLLEXPORT <a class="el" href="structtjscalingfactor.html">tjscalingfactor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#gac3854476006b10787bd128f7ede48057">tjGetScalingFactors</a> (int *numscalingfactors)</td></tr>
-<tr class="memdesc:gac3854476006b10787bd128f7ede48057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of fractional scaling factors that the JPEG decompressor in this implementation of TurboJPEG supports.  <a href="group___turbo_j_p_e_g.html#gac3854476006b10787bd128f7ede48057">More...</a><br /></td></tr>
-<tr class="separator:gac3854476006b10787bd128f7ede48057"><td class="memSeparator" colspan="2">&#160;</td></tr>
+<tr class="memitem:ga193d0977b3b9966d53a6c402e90899b1"><td class="memItemLeft" align="right" valign="top">DLLEXPORT <a class="el" href="structtjscalingfactor.html">tjscalingfactor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#ga193d0977b3b9966d53a6c402e90899b1">tjGetScalingFactors</a> (int *numScalingFactors)</td></tr>
+<tr class="memdesc:ga193d0977b3b9966d53a6c402e90899b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of fractional scaling factors that the JPEG decompressor supports.  <a href="group___turbo_j_p_e_g.html#ga193d0977b3b9966d53a6c402e90899b1">More...</a><br /></td></tr>
+<tr class="separator:ga193d0977b3b9966d53a6c402e90899b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
 <tr class="memitem:gae9eccef8b682a48f43a9117c231ed013"><td class="memItemLeft" align="right" valign="top">DLLEXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#gae9eccef8b682a48f43a9117c231ed013">tjDecompress2</a> (<a class="el" href="group___turbo_j_p_e_g.html#ga758d2634ecb4949de7815cba621f5763">tjhandle</a> handle, const unsigned char *jpegBuf, unsigned long jpegSize, unsigned char *dstBuf, int width, int pitch, int height, int pixelFormat, int flags)</td></tr>
-<tr class="memdesc:gae9eccef8b682a48f43a9117c231ed013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompress a JPEG image to an RGB, grayscale, or CMYK image.  <a href="group___turbo_j_p_e_g.html#gae9eccef8b682a48f43a9117c231ed013">More...</a><br /></td></tr>
+<tr class="memdesc:gae9eccef8b682a48f43a9117c231ed013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompress a JPEG image into a packed-pixel RGB, grayscale, or CMYK image.  <a href="group___turbo_j_p_e_g.html#gae9eccef8b682a48f43a9117c231ed013">More...</a><br /></td></tr>
 <tr class="separator:gae9eccef8b682a48f43a9117c231ed013"><td class="memSeparator" colspan="2">&#160;</td></tr>
-<tr class="memitem:ga04d1e839ff9a0860dd1475cff78d3364"><td class="memItemLeft" align="right" valign="top">DLLEXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#ga04d1e839ff9a0860dd1475cff78d3364">tjDecompressToYUV2</a> (<a class="el" href="group___turbo_j_p_e_g.html#ga758d2634ecb4949de7815cba621f5763">tjhandle</a> handle, const unsigned char *jpegBuf, unsigned long jpegSize, unsigned char *dstBuf, int width, int pad, int height, int flags)</td></tr>
-<tr class="memdesc:ga04d1e839ff9a0860dd1475cff78d3364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompress a JPEG image to a YUV planar image.  <a href="group___turbo_j_p_e_g.html#ga04d1e839ff9a0860dd1475cff78d3364">More...</a><br /></td></tr>
-<tr class="separator:ga04d1e839ff9a0860dd1475cff78d3364"><td class="memSeparator" colspan="2">&#160;</td></tr>
+<tr class="memitem:ga5a3093e325598c17a9f004323af6fafa"><td class="memItemLeft" align="right" valign="top">DLLEXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#ga5a3093e325598c17a9f004323af6fafa">tjDecompressToYUV2</a> (<a class="el" href="group___turbo_j_p_e_g.html#ga758d2634ecb4949de7815cba621f5763">tjhandle</a> handle, const unsigned char *jpegBuf, unsigned long jpegSize, unsigned char *dstBuf, int width, int align, int height, int flags)</td></tr>
+<tr class="memdesc:ga5a3093e325598c17a9f004323af6fafa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompress a JPEG image into a unified planar YUV image.  <a href="group___turbo_j_p_e_g.html#ga5a3093e325598c17a9f004323af6fafa">More...</a><br /></td></tr>
+<tr class="separator:ga5a3093e325598c17a9f004323af6fafa"><td class="memSeparator" colspan="2">&#160;</td></tr>
 <tr class="memitem:gaa59f901a5258ada5bd0185ad59368540"><td class="memItemLeft" align="right" valign="top">DLLEXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#gaa59f901a5258ada5bd0185ad59368540">tjDecompressToYUVPlanes</a> (<a class="el" href="group___turbo_j_p_e_g.html#ga758d2634ecb4949de7815cba621f5763">tjhandle</a> handle, const unsigned char *jpegBuf, unsigned long jpegSize, unsigned char **dstPlanes, int width, int *strides, int height, int flags)</td></tr>
 <tr class="memdesc:gaa59f901a5258ada5bd0185ad59368540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompress a JPEG image into separate Y, U (Cb), and V (Cr) image planes.  <a href="group___turbo_j_p_e_g.html#gaa59f901a5258ada5bd0185ad59368540">More...</a><br /></td></tr>
 <tr class="separator:gaa59f901a5258ada5bd0185ad59368540"><td class="memSeparator" colspan="2">&#160;</td></tr>
-<tr class="memitem:ga70abbf38f77a26fd6da8813bef96f695"><td class="memItemLeft" align="right" valign="top">DLLEXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#ga70abbf38f77a26fd6da8813bef96f695">tjDecodeYUV</a> (<a class="el" href="group___turbo_j_p_e_g.html#ga758d2634ecb4949de7815cba621f5763">tjhandle</a> handle, const unsigned char *srcBuf, int pad, int subsamp, unsigned char *dstBuf, int width, int pitch, int height, int pixelFormat, int flags)</td></tr>
-<tr class="memdesc:ga70abbf38f77a26fd6da8813bef96f695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a YUV planar image into an RGB or grayscale image.  <a href="group___turbo_j_p_e_g.html#ga70abbf38f77a26fd6da8813bef96f695">More...</a><br /></td></tr>
-<tr class="separator:ga70abbf38f77a26fd6da8813bef96f695"><td class="memSeparator" colspan="2">&#160;</td></tr>
+<tr class="memitem:ga97c2cedc1e2bade15a84164c94e503c1"><td class="memItemLeft" align="right" valign="top">DLLEXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#ga97c2cedc1e2bade15a84164c94e503c1">tjDecodeYUV</a> (<a class="el" href="group___turbo_j_p_e_g.html#ga758d2634ecb4949de7815cba621f5763">tjhandle</a> handle, const unsigned char *srcBuf, int align, int subsamp, unsigned char *dstBuf, int width, int pitch, int height, int pixelFormat, int flags)</td></tr>
+<tr class="memdesc:ga97c2cedc1e2bade15a84164c94e503c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a unified planar YUV image into a packed-pixel RGB or grayscale image.  <a href="group___turbo_j_p_e_g.html#ga97c2cedc1e2bade15a84164c94e503c1">More...</a><br /></td></tr>
+<tr class="separator:ga97c2cedc1e2bade15a84164c94e503c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
 <tr class="memitem:ga10e837c07fa9d25770565b237d3898d9"><td class="memItemLeft" align="right" valign="top">DLLEXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#ga10e837c07fa9d25770565b237d3898d9">tjDecodeYUVPlanes</a> (<a class="el" href="group___turbo_j_p_e_g.html#ga758d2634ecb4949de7815cba621f5763">tjhandle</a> handle, const unsigned char **srcPlanes, const int *strides, int subsamp, unsigned char *dstBuf, int width, int pitch, int height, int pixelFormat, int flags)</td></tr>
-<tr class="memdesc:ga10e837c07fa9d25770565b237d3898d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a set of Y, U (Cb), and V (Cr) image planes into an RGB or grayscale image.  <a href="group___turbo_j_p_e_g.html#ga10e837c07fa9d25770565b237d3898d9">More...</a><br /></td></tr>
+<tr class="memdesc:ga10e837c07fa9d25770565b237d3898d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a set of Y, U (Cb), and V (Cr) image planes into a packed-pixel RGB or grayscale image.  <a href="group___turbo_j_p_e_g.html#ga10e837c07fa9d25770565b237d3898d9">More...</a><br /></td></tr>
 <tr class="separator:ga10e837c07fa9d25770565b237d3898d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
 <tr class="memitem:ga928beff6ac248ceadf01089fc6b41957"><td class="memItemLeft" align="right" valign="top">DLLEXPORT <a class="el" href="group___turbo_j_p_e_g.html#ga758d2634ecb4949de7815cba621f5763">tjhandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#ga928beff6ac248ceadf01089fc6b41957">tjInitTransform</a> (void)</td></tr>
 <tr class="memdesc:ga928beff6ac248ceadf01089fc6b41957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new TurboJPEG transformer instance.  <a href="group___turbo_j_p_e_g.html#ga928beff6ac248ceadf01089fc6b41957">More...</a><br /></td></tr>
@@ -303,16 +303,16 @@ Functions</h2></td></tr>
 <tr class="memdesc:ga75f355fa27225ba1a4ee392c852394d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a TurboJPEG compressor, decompressor, or transformer instance.  <a href="group___turbo_j_p_e_g.html#ga75f355fa27225ba1a4ee392c852394d2">More...</a><br /></td></tr>
 <tr class="separator:ga75f355fa27225ba1a4ee392c852394d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
 <tr class="memitem:gaec627dd4c5f30b7a775a7aea3bec5d83"><td class="memItemLeft" align="right" valign="top">DLLEXPORT unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#gaec627dd4c5f30b7a775a7aea3bec5d83">tjAlloc</a> (int bytes)</td></tr>
-<tr class="memdesc:gaec627dd4c5f30b7a775a7aea3bec5d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate an image buffer for use with TurboJPEG.  <a href="group___turbo_j_p_e_g.html#gaec627dd4c5f30b7a775a7aea3bec5d83">More...</a><br /></td></tr>
+<tr class="memdesc:gaec627dd4c5f30b7a775a7aea3bec5d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a byte buffer for use with TurboJPEG.  <a href="group___turbo_j_p_e_g.html#gaec627dd4c5f30b7a775a7aea3bec5d83">More...</a><br /></td></tr>
 <tr class="separator:gaec627dd4c5f30b7a775a7aea3bec5d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
 <tr class="memitem:gaffbd83c375e79f5db4b5c5d8ad4466e7"><td class="memItemLeft" align="right" valign="top">DLLEXPORT unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#gaffbd83c375e79f5db4b5c5d8ad4466e7">tjLoadImage</a> (const char *filename, int *width, int align, int *height, int *pixelFormat, int flags)</td></tr>
-<tr class="memdesc:gaffbd83c375e79f5db4b5c5d8ad4466e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load an uncompressed image from disk into memory.  <a href="group___turbo_j_p_e_g.html#gaffbd83c375e79f5db4b5c5d8ad4466e7">More...</a><br /></td></tr>
+<tr class="memdesc:gaffbd83c375e79f5db4b5c5d8ad4466e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a packed-pixel image from disk into memory.  <a href="group___turbo_j_p_e_g.html#gaffbd83c375e79f5db4b5c5d8ad4466e7">More...</a><br /></td></tr>
 <tr class="separator:gaffbd83c375e79f5db4b5c5d8ad4466e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
 <tr class="memitem:ga6f445b22d8933ae4815b3370a538d879"><td class="memItemLeft" align="right" valign="top">DLLEXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#ga6f445b22d8933ae4815b3370a538d879">tjSaveImage</a> (const char *filename, unsigned char *buffer, int width, int pitch, int height, int pixelFormat, int flags)</td></tr>
-<tr class="memdesc:ga6f445b22d8933ae4815b3370a538d879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save an uncompressed image from memory to disk.  <a href="group___turbo_j_p_e_g.html#ga6f445b22d8933ae4815b3370a538d879">More...</a><br /></td></tr>
+<tr class="memdesc:ga6f445b22d8933ae4815b3370a538d879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a packed-pixel image from memory to disk.  <a href="group___turbo_j_p_e_g.html#ga6f445b22d8933ae4815b3370a538d879">More...</a><br /></td></tr>
 <tr class="separator:ga6f445b22d8933ae4815b3370a538d879"><td class="memSeparator" colspan="2">&#160;</td></tr>
 <tr class="memitem:gaea863d2da0cdb609563aabdf9196514b"><td class="memItemLeft" align="right" valign="top">DLLEXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#gaea863d2da0cdb609563aabdf9196514b">tjFree</a> (unsigned char *buffer)</td></tr>
-<tr class="memdesc:gaea863d2da0cdb609563aabdf9196514b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free an image buffer previously allocated by TurboJPEG.  <a href="group___turbo_j_p_e_g.html#gaea863d2da0cdb609563aabdf9196514b">More...</a><br /></td></tr>
+<tr class="memdesc:gaea863d2da0cdb609563aabdf9196514b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a byte buffer previously allocated by TurboJPEG.  <a href="group___turbo_j_p_e_g.html#gaea863d2da0cdb609563aabdf9196514b">More...</a><br /></td></tr>
 <tr class="separator:gaea863d2da0cdb609563aabdf9196514b"><td class="memSeparator" colspan="2">&#160;</td></tr>
 <tr class="memitem:ga1ead8574f9f39fbafc6b497124e7aafa"><td class="memItemLeft" align="right" valign="top">DLLEXPORT char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#ga1ead8574f9f39fbafc6b497124e7aafa">tjGetErrorStr2</a> (<a class="el" href="group___turbo_j_p_e_g.html#ga758d2634ecb4949de7815cba621f5763">tjhandle</a> handle)</td></tr>
 <tr class="memdesc:ga1ead8574f9f39fbafc6b497124e7aafa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a descriptive error message explaining why the last command failed.  <a href="group___turbo_j_p_e_g.html#ga1ead8574f9f39fbafc6b497124e7aafa">More...</a><br /></td></tr>
@@ -352,8 +352,8 @@ Variables</h2></td></tr>
 <h2><a class="anchor" id="autotoc_md0"></a>
 YUV Image Format Notes</h2>
 <p>Technically, the JPEG format uses the YCbCr colorspace (which is technically not a colorspace but a color transform), but per the convention of the digital video community, the TurboJPEG API uses "YUV" to refer to an image format consisting of Y, Cb, and Cr image planes.</p>
-<p>Each plane is simply a 2D array of bytes, each byte representing the value of one of the components (Y, Cb, or Cr) at a particular location in the image. The width and height of each plane are determined by the image width, height, and level of chrominance subsampling. The luminance plane width is the image width padded to the nearest multiple of the horizontal subsampling factor (2 in the case of 4:2:0 and 4:2:2, 4 in the case of 4:1:1, 1 in the case of 4:4:4 or grayscale.) Similarly, the luminance plane height is the image height padded to the nearest multiple of the vertical subsampling factor (2 in the case of 4:2:0 or 4:4:0, 1 in the case of 4:4:4 or grayscale.) This is irrespective of any additional padding that may be specified as an argument to the various YUV functions. The chrominance plane width is equal to the luminance plane width divided by the horizontal subsampling factor, and the chrominance plane height is equal to the luminance plane height divided by the vertical subsampling factor.</p>
-<p>For example, if the source image is 35 x 35 pixels and 4:2:2 subsampling is used, then the luminance plane would be 36 x 35 bytes, and each of the chrominance planes would be 18 x 35 bytes. If you specify a line padding of 4 bytes on top of this, then the luminance plane would be 36 x 35 bytes, and each of the chrominance planes would be 20 x 35 bytes. </p>
+<p>Each plane is simply a 2D array of bytes, each byte representing the value of one of the components (Y, Cb, or Cr) at a particular location in the image. The width and height of each plane are determined by the image width, height, and level of chrominance subsampling. The luminance plane width is the image width padded to the nearest multiple of the horizontal subsampling factor (1 in the case of 4:4:4, grayscale, or 4:4:0; 2 in the case of 4:2:2 or 4:2:0; 4 in the case of 4:1:1.) Similarly, the luminance plane height is the image height padded to the nearest multiple of the vertical subsampling factor (1 in the case of 4:4:4, 4:2:2, grayscale, or 4:1:1; 2 in the case of 4:2:0 or 4:4:0.) This is irrespective of any additional padding that may be specified as an argument to the various YUV functions. The chrominance plane width is equal to the luminance plane width divided by the horizontal subsampling factor, and the chrominance plane height is equal to the luminance plane height divided by the vertical subsampling factor.</p>
+<p>For example, if the source image is 35 x 35 pixels and 4:2:2 subsampling is used, then the luminance plane would be 36 x 35 bytes, and each of the chrominance planes would be 18 x 35 bytes. If you specify a row alignment of 4 bytes on top of this, then the luminance plane would be 36 x 35 bytes, and each of the chrominance planes would be 20 x 35 bytes. </p>
 <h2 class="groupheader">Macro Definition Documentation</h2>
 <a id="ga39f57a6fb02d9cf32e7b6890099b5a71"></a>
 <h2 class="memtitle"><span class="permalink"><a href="#ga39f57a6fb02d9cf32e7b6890099b5a71">&#9670;&nbsp;</a></span>TJ_NUMCS</h2>
@@ -447,8 +447,8 @@ YUV Image Format Notes</h2>
       </table>
 </div><div class="memdoc">
 
-<p>Use the most accurate DCT/IDCT algorithm available in the underlying codec. </p>
-<p>The default if this flag is not specified is implementation-specific. For example, the implementation of TurboJPEG for libjpeg[-turbo] uses the fast algorithm by default when compressing, because this has been shown to have only a very slight effect on accuracy, but it uses the accurate algorithm when decompressing, because this has been shown to have a larger effect. </p>
+<p>Use the most accurate DCT/IDCT algorithm available. </p>
+<p>The default if this flag is not specified is implementation-specific. For example, the implementation of the TurboJPEG API in libjpeg-turbo uses the fast algorithm by default when compressing, because this has been shown to have only a very slight effect on accuracy, but it uses the accurate algorithm when decompressing, because this has been shown to have a larger effect. </p>
 
 </div>
 </div>
@@ -464,7 +464,7 @@ YUV Image Format Notes</h2>
       </table>
 </div><div class="memdoc">
 
-<p>The uncompressed source/destination image is stored in bottom-up (Windows, OpenGL) order, not top-down (X11) order. </p>
+<p>Rows in the packed-pixel source/destination image are stored in bottom-up (Windows, OpenGL) order rather than in top-down (X11) order. </p>
 
 </div>
 </div>
@@ -480,8 +480,8 @@ YUV Image Format Notes</h2>
       </table>
 </div><div class="memdoc">
 
-<p>Use the fastest DCT/IDCT algorithm available in the underlying codec. </p>
-<p>The default if this flag is not specified is implementation-specific. For example, the implementation of TurboJPEG for libjpeg[-turbo] uses the fast algorithm by default when compressing, because this has been shown to have only a very slight effect on accuracy, but it uses the accurate algorithm when decompressing, because this has been shown to have a larger effect. </p>
+<p>Use the fastest DCT/IDCT algorithm available. </p>
+<p>The default if this flag is not specified is implementation-specific. For example, the implementation of the TurboJPEG API in libjpeg-turbo uses the fast algorithm by default when compressing, because this has been shown to have only a very slight effect on accuracy, but it uses the accurate algorithm when decompressing, because this has been shown to have a larger effect. </p>
 
 </div>
 </div>
@@ -497,7 +497,7 @@ YUV Image Format Notes</h2>
       </table>
 </div><div class="memdoc">
 
-<p>When decompressing an image that was compressed using chrominance subsampling, use the fastest chrominance upsampling algorithm available in the underlying codec. </p>
+<p>When decompressing an image that was compressed using chrominance subsampling, use the fastest chrominance upsampling algorithm available. </p>
 <p>The default is to use smooth upsampling, which creates a smooth transition between neighboring chrominance components in order to reduce upsampling artifacts in the decompressed image. </p>
 
 </div>
@@ -531,8 +531,8 @@ YUV Image Format Notes</h2>
       </table>
 </div><div class="memdoc">
 
-<p>Disable buffer (re)allocation. </p>
-<p>If passed to one of the JPEG compression or transform functions, this flag will cause those functions to generate an error if the JPEG image buffer is invalid or too small rather than attempting to allocate or reallocate that buffer. This reproduces the behavior of earlier versions of TurboJPEG. </p>
+<p>Disable JPEG buffer (re)allocation. </p>
+<p>If passed to one of the JPEG compression or transform functions, this flag will cause those functions to generate an error if the JPEG destination buffer is invalid or too small, rather than attempt to allocate or reallocate that buffer. </p>
 
 </div>
 </div>
@@ -565,7 +565,7 @@ YUV Image Format Notes</h2>
       </table>
 </div><div class="memdoc">
 
-<p>Immediately discontinue the current compression/decompression/transform operation if the underlying codec throws a warning (non-fatal error). </p>
+<p>Immediately discontinue the current compression/decompression/transform operation if a warning (non-fatal error) occurs. </p>
 <p>The default behavior is to allow the operation to complete unless a fatal error is encountered. </p>
 
 </div>
@@ -586,7 +586,7 @@ YUV Image Format Notes</h2>
       </table>
 </div><div class="memdoc">
 
-<p>Pad the given width to the nearest 32-bit boundary. </p>
+<p>Pad the given width to the nearest multiple of 4. </p>
 
 </div>
 </div>
@@ -633,7 +633,7 @@ YUV Image Format Notes</h2>
       </table>
 </div><div class="memdoc">
 
-<p>This option will prevent <a class="el" href="group___turbo_j_p_e_g.html#ga9cb8abf4cc91881e04a0329b2270be25" title="Losslessly transform a JPEG image into another JPEG image.">tjTransform()</a> from copying any extra markers (including EXIF and ICC profile data) from the source image to the output image. </p>
+<p>This option will prevent <a class="el" href="group___turbo_j_p_e_g.html#ga9cb8abf4cc91881e04a0329b2270be25" title="Losslessly transform a JPEG image into another JPEG image.">tjTransform()</a> from copying any extra markers (including EXIF and ICC profile data) from the source image to the destination image. </p>
 
 </div>
 </div>
@@ -666,7 +666,7 @@ YUV Image Format Notes</h2>
       </table>
 </div><div class="memdoc">
 
-<p>This option will discard the color data in the input image and produce a grayscale output image. </p>
+<p>This option will discard the color data in the source image and produce a grayscale destination image. </p>
 
 </div>
 </div>
@@ -682,7 +682,8 @@ YUV Image Format Notes</h2>
       </table>
 </div><div class="memdoc">
 
-<p>This option will prevent <a class="el" href="group___turbo_j_p_e_g.html#ga9cb8abf4cc91881e04a0329b2270be25" title="Losslessly transform a JPEG image into another JPEG image.">tjTransform()</a> from outputting a JPEG image for this particular transform (this can be used in conjunction with a custom filter to capture the transformed DCT coefficients without transcoding them.) </p>
+<p>This option will prevent <a class="el" href="group___turbo_j_p_e_g.html#ga9cb8abf4cc91881e04a0329b2270be25" title="Losslessly transform a JPEG image into another JPEG image.">tjTransform()</a> from outputting a JPEG image for this particular transform. </p>
+<p>(This can be used in conjunction with a custom filter to capture the transformed DCT coefficients without transcoding them.) </p>
 
 </div>
 </div>
@@ -715,8 +716,8 @@ YUV Image Format Notes</h2>
       </table>
 </div><div class="memdoc">
 
-<p>This option will enable progressive entropy coding in the output image generated by this particular transform. </p>
-<p>Progressive entropy coding will generally improve compression relative to baseline entropy coding (the default), but it will reduce compression and decompression performance considerably. </p>
+<p>This option will enable progressive entropy coding in the JPEG image generated by this particular transform. </p>
+<p>Progressive entropy coding will generally improve compression relative to baseline entropy coding (the default), but it will reduce decompression performance considerably. </p>
 
 </div>
 </div>
@@ -785,19 +786,19 @@ YUV Image Format Notes</h2>
 <p>JPEG colorspaces. </p>
 <table class="fieldtable">
 <tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga4f83ad3368e0e29d1957be0efa7c3720a677cb7ccb85c4038ac41964a2e09e555"></a>TJCS_RGB&#160;</td><td class="fielddoc"><p>RGB colorspace. </p>
-<p>When compressing the JPEG image, the R, G, and B components in the source image are reordered into image planes, but no colorspace conversion or subsampling is performed. RGB JPEG images can be decompressed to any of the extended RGB pixel formats or grayscale, but they cannot be decompressed to YUV images. </p>
+<p>When compressing the JPEG image, the R, G, and B components in the source image are reordered into image planes, but no colorspace conversion or subsampling is performed. RGB JPEG images can be decompressed to packed-pixel images with any of the extended RGB or grayscale pixel formats, but they cannot be decompressed to planar YUV images. </p>
 </td></tr>
 <tr><td class="fieldname"><a id="gga4f83ad3368e0e29d1957be0efa7c3720a7389b8f65bb387ffedce3efd0d78ec75"></a>TJCS_YCbCr&#160;</td><td class="fielddoc"><p>YCbCr colorspace. </p>
-<p>YCbCr is not an absolute colorspace but rather a mathematical transformation of RGB designed solely for storage and transmission. YCbCr images must be converted to RGB before they can actually be displayed. In the YCbCr colorspace, the Y (luminance) component represents the black &amp; white portion of the original image, and the Cb and Cr (chrominance) components represent the color portion of the original image. Originally, the analog equivalent of this transformation allowed the same signal to drive both black &amp; white and color televisions, but JPEG images use YCbCr primarily because it allows the color data to be optionally subsampled for the purposes of reducing bandwidth or disk space. YCbCr is the most common JPEG colorspace, and YCbCr JPEG images can be compressed from and decompressed to any of the extended RGB pixel formats or grayscale, or they can be decompressed to YUV planar images. </p>
+<p>YCbCr is not an absolute colorspace but rather a mathematical transformation of RGB designed solely for storage and transmission. YCbCr images must be converted to RGB before they can actually be displayed. In the YCbCr colorspace, the Y (luminance) component represents the black &amp; white portion of the original image, and the Cb and Cr (chrominance) components represent the color portion of the original image. Originally, the analog equivalent of this transformation allowed the same signal to drive both black &amp; white and color televisions, but JPEG images use YCbCr primarily because it allows the color data to be optionally subsampled for the purposes of reducing network or disk usage. YCbCr is the most common JPEG colorspace, and YCbCr JPEG images can be compressed from and decompressed to packed-pixel images with any of the extended RGB or grayscale pixel formats. YCbCr JPEG images can also be compressed from and decompressed to planar YUV images. </p>
 </td></tr>
 <tr><td class="fieldname"><a id="gga4f83ad3368e0e29d1957be0efa7c3720ab3e7d6a87f695e45b81c1b5262b5a50a"></a>TJCS_GRAY&#160;</td><td class="fielddoc"><p>Grayscale colorspace. </p>
-<p>The JPEG image retains only the luminance data (Y component), and any color data from the source image is discarded. Grayscale JPEG images can be compressed from and decompressed to any of the extended RGB pixel formats or grayscale, or they can be decompressed to YUV planar images. </p>
+<p>The JPEG image retains only the luminance data (Y component), and any color data from the source image is discarded. Grayscale JPEG images can be compressed from and decompressed to packed-pixel images with any of the extended RGB or grayscale pixel formats, or they can be compressed from and decompressed to planar YUV images. </p>
 </td></tr>
 <tr><td class="fieldname"><a id="gga4f83ad3368e0e29d1957be0efa7c3720a6c8b636152ac8195b869587db315ee53"></a>TJCS_CMYK&#160;</td><td class="fielddoc"><p>CMYK colorspace. </p>
-<p>When compressing the JPEG image, the C, M, Y, and K components in the source image are reordered into image planes, but no colorspace conversion or subsampling is performed. CMYK JPEG images can only be decompressed to CMYK pixels. </p>
+<p>When compressing the JPEG image, the C, M, Y, and K components in the source image are reordered into image planes, but no colorspace conversion or subsampling is performed. CMYK JPEG images can only be decompressed to packed-pixel images with the CMYK pixel format. </p>
 </td></tr>
 <tr><td class="fieldname"><a id="gga4f83ad3368e0e29d1957be0efa7c3720a53839e0fe867b76b58d16b0a1a7c598e"></a>TJCS_YCCK&#160;</td><td class="fielddoc"><p>YCCK colorspace. </p>
-<p>YCCK (AKA "YCbCrK") is not an absolute colorspace but rather a mathematical transformation of CMYK designed solely for storage and transmission. It is to CMYK as YCbCr is to RGB. CMYK pixels can be reversibly transformed into YCCK, and as with YCbCr, the chrominance components in the YCCK pixels can be subsampled without incurring major perceptual loss. YCCK JPEG images can only be compressed from and decompressed to CMYK pixels. </p>
+<p>YCCK (AKA "YCbCrK") is not an absolute colorspace but rather a mathematical transformation of CMYK designed solely for storage and transmission. It is to CMYK as YCbCr is to RGB. CMYK pixels can be reversibly transformed into YCCK, and as with YCbCr, the chrominance components in the YCCK pixels can be subsampled without incurring major perceptual loss. YCCK JPEG images can only be compressed from and decompressed to packed-pixel images with the CMYK pixel format. </p>
 </td></tr>
 </table>
 
@@ -817,7 +818,7 @@ YUV Image Format Notes</h2>
 
 <p>Error codes. </p>
 <table class="fieldtable">
-<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggafbc17cfa57d0d5d11fea35ac025950fea342dd6e2aedb47bb257b4e7568329b59"></a>TJERR_WARNING&#160;</td><td class="fielddoc"><p>The error was non-fatal and recoverable, but the image may still be corrupt. </p>
+<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggafbc17cfa57d0d5d11fea35ac025950fea342dd6e2aedb47bb257b4e7568329b59"></a>TJERR_WARNING&#160;</td><td class="fielddoc"><p>The error was non-fatal and recoverable, but the destination image may still be corrupt. </p>
 </td></tr>
 <tr><td class="fieldname"><a id="ggafbc17cfa57d0d5d11fea35ac025950feafc9cceeada13122b09e4851e3788039a"></a>TJERR_FATAL&#160;</td><td class="fielddoc"><p>The error was fatal and non-recoverable. </p>
 </td></tr>
@@ -873,10 +874,10 @@ YUV Image Format Notes</h2>
 <p>This is the same as <a class="el" href="group___turbo_j_p_e_g.html#ggac916144e26c3817ac514e64ae5d12e2aadae996905efcfa3b42a0bb3bea7f9d84">TJPF_XRGB</a>, except that when decompressing, the X component is guaranteed to be 0xFF, which can be interpreted as an opaque alpha channel. </p>
 </td></tr>
 <tr><td class="fieldname"><a id="ggac916144e26c3817ac514e64ae5d12e2aa7f5100ec44c91994e243f1cf55553f8b"></a>TJPF_CMYK&#160;</td><td class="fielddoc"><p>CMYK pixel format. </p>
-<p>Unlike RGB, which is an additive color model used primarily for display, CMYK (Cyan/Magenta/Yellow/Key) is a subtractive color model used primarily for printing. In the CMYK color model, the value of each color component typically corresponds to an amount of cyan, magenta, yellow, or black ink that is applied to a white background. In order to convert between CMYK and RGB, it is necessary to use a color management system (CMS.) A CMS will attempt to map colors within the printer's gamut to perceptually similar colors in the display's gamut and vice versa, but the mapping is typically not 1:1 or reversible, nor can it be defined with a simple formula. Thus, such a conversion is out of scope for a codec library. However, the TurboJPEG API allows for compressing CMYK pixels into a YCCK JPEG image (see <a class="el" href="group___turbo_j_p_e_g.html#gga4f83ad3368e0e29d1957be0efa7c3720a53839e0fe867b76b58d16b0a1a7c598e" title="YCCK colorspace.">TJCS_YCCK</a>) and decompressing YCCK JPEG images into CMYK pixels. </p>
+<p>Unlike RGB, which is an additive color model used primarily for display, CMYK (Cyan/Magenta/Yellow/Key) is a subtractive color model used primarily for printing. In the CMYK color model, the value of each color component typically corresponds to an amount of cyan, magenta, yellow, or black ink that is applied to a white background. In order to convert between CMYK and RGB, it is necessary to use a color management system (CMS.) A CMS will attempt to map colors within the printer's gamut to perceptually similar colors in the display's gamut and vice versa, but the mapping is typically not 1:1 or reversible, nor can it be defined with a simple formula. Thus, such a conversion is out of scope for a codec library. However, the TurboJPEG API allows for compressing packed-pixel CMYK images into YCCK JPEG images (see <a class="el" href="group___turbo_j_p_e_g.html#gga4f83ad3368e0e29d1957be0efa7c3720a53839e0fe867b76b58d16b0a1a7c598e" title="YCCK colorspace.">TJCS_YCCK</a>) and decompressing YCCK JPEG images into packed-pixel CMYK images. </p>
 </td></tr>
 <tr><td class="fieldname"><a id="ggac916144e26c3817ac514e64ae5d12e2aa84c1a6cead7952998e2fb895844a21ed"></a>TJPF_UNKNOWN&#160;</td><td class="fielddoc"><p>Unknown pixel format. </p>
-<p>Currently this is only used by <a class="el" href="group___turbo_j_p_e_g.html#gaffbd83c375e79f5db4b5c5d8ad4466e7" title="Load an uncompressed image from disk into memory.">tjLoadImage()</a>. </p>
+<p>Currently this is only used by <a class="el" href="group___turbo_j_p_e_g.html#gaffbd83c375e79f5db4b5c5d8ad4466e7" title="Load a packed-pixel image from disk into memory.">tjLoadImage()</a>. </p>
 </td></tr>
 </table>
 
@@ -895,7 +896,7 @@ YUV Image Format Notes</h2>
 </div><div class="memdoc">
 
 <p>Chrominance subsampling options. </p>
-<p>When pixels are converted from RGB to YCbCr (see <a class="el" href="group___turbo_j_p_e_g.html#gga4f83ad3368e0e29d1957be0efa7c3720a7389b8f65bb387ffedce3efd0d78ec75" title="YCbCr colorspace.">TJCS_YCbCr</a>) or from CMYK to YCCK (see <a class="el" href="group___turbo_j_p_e_g.html#gga4f83ad3368e0e29d1957be0efa7c3720a53839e0fe867b76b58d16b0a1a7c598e" title="YCCK colorspace.">TJCS_YCCK</a>) as part of the JPEG compression process, some of the Cb and Cr (chrominance) components can be discarded or averaged together to produce a smaller image with little perceptible loss of image clarity (the human eye is more sensitive to small changes in brightness than to small changes in color.) This is called "chrominance subsampling". </p>
+<p>When pixels are converted from RGB to YCbCr (see <a class="el" href="group___turbo_j_p_e_g.html#gga4f83ad3368e0e29d1957be0efa7c3720a7389b8f65bb387ffedce3efd0d78ec75" title="YCbCr colorspace.">TJCS_YCbCr</a>) or from CMYK to YCCK (see <a class="el" href="group___turbo_j_p_e_g.html#gga4f83ad3368e0e29d1957be0efa7c3720a53839e0fe867b76b58d16b0a1a7c598e" title="YCCK colorspace.">TJCS_YCCK</a>) as part of the JPEG compression process, some of the Cb and Cr (chrominance) components can be discarded or averaged together to produce a smaller image with little perceptible loss of image clarity. (The human eye is more sensitive to small changes in brightness than to small changes in color.) This is called "chrominance subsampling". </p>
 <table class="fieldtable">
 <tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga1d047060ea80bb9820d540bb928e9074afb8da4f44197837bdec0a4f593dacae3"></a>TJSAMP_444&#160;</td><td class="fielddoc"><p>4:4:4 chrominance subsampling (no chrominance subsampling). </p>
 <p>The JPEG or YUV image will contain one chrominance component for every pixel in the source image. </p>
@@ -977,8 +978,8 @@ YUV Image Format Notes</h2>
       </table>
 </div><div class="memdoc">
 
-<p>Allocate an image buffer for use with TurboJPEG. </p>
-<p>You should always use this function to allocate the JPEG destination buffer(s) for the compression and transform functions unless you are disabling automatic buffer (re)allocation (by setting <a class="el" href="group___turbo_j_p_e_g.html#ga8808d403c68b62aaa58a4c1e58e98963" title="Disable buffer (re)allocation.">TJFLAG_NOREALLOC</a>.)</p>
+<p>Allocate a byte buffer for use with TurboJPEG. </p>
+<p>You should always use this function to allocate the JPEG destination buffer(s) for the compression and transform functions unless you are disabling automatic buffer (re)allocation (by setting <a class="el" href="group___turbo_j_p_e_g.html#ga8808d403c68b62aaa58a4c1e58e98963" title="Disable JPEG buffer (re)allocation.">TJFLAG_NOREALLOC</a>.)</p>
 <dl class="params"><dt>Parameters</dt><dd>
   <table class="params">
     <tr><td class="paramname">bytes</td><td>the number of bytes to allocate</td></tr>
@@ -986,7 +987,7 @@ YUV Image Format Notes</h2>
   </dd>
 </dl>
 <dl class="section return"><dt>Returns</dt><dd>a pointer to a newly-allocated buffer with the specified number of bytes.</dd></dl>
-<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___turbo_j_p_e_g.html#gaea863d2da0cdb609563aabdf9196514b" title="Free an image buffer previously allocated by TurboJPEG.">tjFree()</a> </dd></dl>
+<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___turbo_j_p_e_g.html#gaea863d2da0cdb609563aabdf9196514b" title="Free a byte buffer previously allocated by TurboJPEG.">tjFree()</a> </dd></dl>
 
 </div>
 </div>
@@ -1023,7 +1024,7 @@ YUV Image Format Notes</h2>
 </div><div class="memdoc">
 
 <p>The maximum size of the buffer (in bytes) required to hold a JPEG image with the given parameters. </p>
-<p>The number of bytes returned by this function is larger than the size of the uncompressed source image. The reason for this is that the JPEG format uses 16-bit coefficients, and it is thus possible for a very high-quality JPEG image with very high-frequency content to expand rather than compress when converted to the JPEG format. Such images represent a very rare corner case, but since there is no way to predict the size of a JPEG image prior to compression, the corner case has to be handled.</p>
+<p>The number of bytes returned by this function is larger than the size of the uncompressed source image. The reason for this is that the JPEG format uses 16-bit coefficients, so it is possible for a very high-quality source image with very high-frequency content to expand rather than compress when converted to the JPEG format. Such images represent very rare corner cases, but since there is no way to predict the size of a JPEG image prior to compression, the corner cases have to be handled.</p>
 <dl class="params"><dt>Parameters</dt><dd>
   <table class="params">
     <tr><td class="paramname">width</td><td>width (in pixels) of the image</td></tr>
@@ -1036,8 +1037,8 @@ YUV Image Format Notes</h2>
 
 </div>
 </div>
-<a id="ga2be2b9969d4df9ecce9b05deed273194"></a>
-<h2 class="memtitle"><span class="permalink"><a href="#ga2be2b9969d4df9ecce9b05deed273194">&#9670;&nbsp;</a></span>tjBufSizeYUV2()</h2>
+<a id="ga5e5aac9e8bcf17049279301e2466474c"></a>
+<h2 class="memtitle"><span class="permalink"><a href="#ga5e5aac9e8bcf17049279301e2466474c">&#9670;&nbsp;</a></span>tjBufSizeYUV2()</h2>
 
 <div class="memitem">
 <div class="memproto">
@@ -1052,7 +1053,7 @@ YUV Image Format Notes</h2>
           <td class="paramkey"></td>
           <td></td>
           <td class="paramtype">int&#160;</td>
-          <td class="paramname"><em>pad</em>, </td>
+          <td class="paramname"><em>align</em>, </td>
         </tr>
         <tr>
           <td class="paramkey"></td>
@@ -1074,11 +1075,11 @@ YUV Image Format Notes</h2>
       </table>
 </div><div class="memdoc">
 
-<p>The size of the buffer (in bytes) required to hold a YUV planar image with the given parameters. </p>
+<p>The size of the buffer (in bytes) required to hold a unified planar YUV image with the given parameters. </p>
 <dl class="params"><dt>Parameters</dt><dd>
   <table class="params">
     <tr><td class="paramname">width</td><td>width (in pixels) of the image</td></tr>
-    <tr><td class="paramname">pad</td><td>the width of each line in each plane of the image is padded to the nearest multiple of this number of bytes (must be a power of 2.)</td></tr>
+    <tr><td class="paramname">align</td><td>row alignment (in bytes) of the image (must be a power of 2.) Setting this parameter to n specifies that each row in each plane of the image will be padded to the nearest multiple of n bytes (1 = unpadded.)</td></tr>
     <tr><td class="paramname">height</td><td>height (in pixels) of the image</td></tr>
     <tr><td class="paramname">subsamp</td><td>level of chrominance subsampling in the image (see <a class="el" href="group___turbo_j_p_e_g.html#ga1d047060ea80bb9820d540bb928e9074">Chrominance subsampling options</a>.)</td></tr>
   </table>
@@ -1168,22 +1169,22 @@ YUV Image Format Notes</h2>
       </table>
 </div><div class="memdoc">
 
-<p>Compress an RGB, grayscale, or CMYK image into a JPEG image. </p>
+<p>Compress a packed-pixel RGB, grayscale, or CMYK image into a JPEG image. </p>
 <dl class="params"><dt>Parameters</dt><dd>
   <table class="params">
     <tr><td class="paramname">handle</td><td>a handle to a TurboJPEG compressor or transformer instance</td></tr>
-    <tr><td class="paramname">srcBuf</td><td>pointer to an image buffer containing RGB, grayscale, or CMYK pixels to be compressed</td></tr>
+    <tr><td class="paramname">srcBuf</td><td>pointer to a buffer containing a packed-pixel RGB, grayscale, or CMYK source image to be compressed</td></tr>
     <tr><td class="paramname">width</td><td>width (in pixels) of the source image</td></tr>
-    <tr><td class="paramname">pitch</td><td>bytes per line in the source image. Normally, this should be <code>width * <a class="el" href="group___turbo_j_p_e_g.html#gad77cf8fe5b2bfd3cb3f53098146abb4c" title="Pixel size (in bytes) for a given pixel format.">tjPixelSize</a>[pixelFormat]</code> if the image is unpadded, or <code><a class="el" href="group___turbo_j_p_e_g.html#ga0aba955473315e405295d978f0c16511" title="Pad the given width to the nearest 32-bit boundary.">TJPAD</a>(width * <a class="el" href="group___turbo_j_p_e_g.html#gad77cf8fe5b2bfd3cb3f53098146abb4c" title="Pixel size (in bytes) for a given pixel format.">tjPixelSize</a>[pixelFormat])</code> if each line of the image is padded to the nearest 32-bit boundary, as is the case for Windows bitmaps. You can also be clever and use this parameter to skip lines, etc. Setting this parameter to 0 is the equivalent of setting it to <code>width * <a class="el" href="group___turbo_j_p_e_g.html#gad77cf8fe5b2bfd3cb3f53098146abb4c" title="Pixel size (in bytes) for a given pixel format.">tjPixelSize</a>[pixelFormat]</code>.</td></tr>
+    <tr><td class="paramname">pitch</td><td>bytes per row in the source image. Normally this should be <code>width * <a class="el" href="group___turbo_j_p_e_g.html#gad77cf8fe5b2bfd3cb3f53098146abb4c" title="Pixel size (in bytes) for a given pixel format.">tjPixelSize</a>[pixelFormat]</code>, if the image is unpadded, or <code><a class="el" href="group___turbo_j_p_e_g.html#ga0aba955473315e405295d978f0c16511" title="Pad the given width to the nearest multiple of 4.">TJPAD</a>(width * <a class="el" href="group___turbo_j_p_e_g.html#gad77cf8fe5b2bfd3cb3f53098146abb4c" title="Pixel size (in bytes) for a given pixel format.">tjPixelSize</a>[pixelFormat])</code> if each row of the image is padded to the nearest multiple of 4 bytes, as is the case for Windows bitmaps. You can also be clever and use this parameter to skip rows, etc. Setting this parameter to 0 is the equivalent of setting it to <code>width * <a class="el" href="group___turbo_j_p_e_g.html#gad77cf8fe5b2bfd3cb3f53098146abb4c" title="Pixel size (in bytes) for a given pixel format.">tjPixelSize</a>[pixelFormat]</code>.</td></tr>
     <tr><td class="paramname">height</td><td>height (in pixels) of the source image</td></tr>
     <tr><td class="paramname">pixelFormat</td><td>pixel format of the source image (see <a class="el" href="group___turbo_j_p_e_g.html#gac916144e26c3817ac514e64ae5d12e2a">Pixel formats</a>.)</td></tr>
-    <tr><td class="paramname">jpegBuf</td><td>address of a pointer to an image buffer that will receive the JPEG image. TurboJPEG has the ability to reallocate the JPEG buffer to accommodate the size of the JPEG image. Thus, you can choose to:<ol type="1">
-<li>pre-allocate the JPEG buffer with an arbitrary size using <a class="el" href="group___turbo_j_p_e_g.html#gaec627dd4c5f30b7a775a7aea3bec5d83" title="Allocate an image buffer for use with TurboJPEG.">tjAlloc()</a> and let TurboJPEG grow the buffer as needed,</li>
+    <tr><td class="paramname">jpegBuf</td><td>address of a pointer to a byte buffer that will receive the JPEG image. TurboJPEG has the ability to reallocate the JPEG buffer to accommodate the size of the JPEG image. Thus, you can choose to:<ol type="1">
+<li>pre-allocate the JPEG buffer with an arbitrary size using <a class="el" href="group___turbo_j_p_e_g.html#gaec627dd4c5f30b7a775a7aea3bec5d83" title="Allocate a byte buffer for use with TurboJPEG.">tjAlloc()</a> and let TurboJPEG grow the buffer as needed,</li>
 <li>set <code>*jpegBuf</code> to NULL to tell TurboJPEG to allocate the buffer for you, or</li>
-<li>pre-allocate the buffer to a "worst case" size determined by calling <a class="el" href="group___turbo_j_p_e_g.html#ga67ac12fee79073242cb216e07c9f1f90" title="The maximum size of the buffer (in bytes) required to hold a JPEG image with the given parameters.">tjBufSize()</a>. This should ensure that the buffer never has to be re-allocated (setting <a class="el" href="group___turbo_j_p_e_g.html#ga8808d403c68b62aaa58a4c1e58e98963" title="Disable buffer (re)allocation.">TJFLAG_NOREALLOC</a> guarantees that it won't be.)</li>
+<li>pre-allocate the buffer to a "worst case" size determined by calling <a class="el" href="group___turbo_j_p_e_g.html#ga67ac12fee79073242cb216e07c9f1f90" title="The maximum size of the buffer (in bytes) required to hold a JPEG image with the given parameters.">tjBufSize()</a>. This should ensure that the buffer never has to be re-allocated. (Setting <a class="el" href="group___turbo_j_p_e_g.html#ga8808d403c68b62aaa58a4c1e58e98963" title="Disable JPEG buffer (re)allocation.">TJFLAG_NOREALLOC</a> guarantees that it won't be.)</li>
 </ol>
-If you choose option 1, <code>*jpegSize</code> should be set to the size of your pre-allocated buffer. In any case, unless you have set <a class="el" href="group___turbo_j_p_e_g.html#ga8808d403c68b62aaa58a4c1e58e98963" title="Disable buffer (re)allocation.">TJFLAG_NOREALLOC</a>, you should always check <code>*jpegBuf</code> upon return from this function, as it may have changed.</td></tr>
-    <tr><td class="paramname">jpegSize</td><td>pointer to an unsigned long variable that holds the size of the JPEG image buffer. If <code>*jpegBuf</code> points to a pre-allocated buffer, then <code>*jpegSize</code> should be set to the size of the buffer. Upon return, <code>*jpegSize</code> will contain the size of the JPEG image (in bytes.) If <code>*jpegBuf</code> points to a JPEG image buffer that is being reused from a previous call to one of the JPEG compression functions, then <code>*jpegSize</code> is ignored.</td></tr>
+If you choose option 1, then <code>*jpegSize</code> should be set to the size of your pre-allocated buffer. In any case, unless you have set <a class="el" href="group___turbo_j_p_e_g.html#ga8808d403c68b62aaa58a4c1e58e98963" title="Disable JPEG buffer (re)allocation.">TJFLAG_NOREALLOC</a>, you should always check <code>*jpegBuf</code> upon return from this function, as it may have changed.</td></tr>
+    <tr><td class="paramname">jpegSize</td><td>pointer to an unsigned long variable that holds the size of the JPEG buffer. If <code>*jpegBuf</code> points to a pre-allocated buffer, then <code>*jpegSize</code> should be set to the size of the buffer. Upon return, <code>*jpegSize</code> will contain the size of the JPEG image (in bytes.) If <code>*jpegBuf</code> points to a JPEG buffer that is being reused from a previous call to one of the JPEG compression functions, then <code>*jpegSize</code> is ignored.</td></tr>
     <tr><td class="paramname">jpegSubsamp</td><td>the level of chrominance subsampling to be used when generating the JPEG image (see <a class="el" href="group___turbo_j_p_e_g.html#ga1d047060ea80bb9820d540bb928e9074">Chrominance subsampling options</a>.)</td></tr>
     <tr><td class="paramname">jpegQual</td><td>the image quality of the generated JPEG image (1 = worst, 100 = best)</td></tr>
     <tr><td class="paramname">flags</td><td>the bitwise OR of one or more of the <a class="el" href="group___turbo_j_p_e_g.html#gacb233cfd722d66d1ccbf48a7de81f0e0">flags</a></td></tr>
@@ -1194,8 +1195,8 @@ If you choose option 1, <code>*jpegSize</code> should be set to the size of your
 
 </div>
 </div>
-<a id="ga7622a459b79aa1007e005b58783f875b"></a>
-<h2 class="memtitle"><span class="permalink"><a href="#ga7622a459b79aa1007e005b58783f875b">&#9670;&nbsp;</a></span>tjCompressFromYUV()</h2>
+<a id="gab40f5096a72fd7e5bda9d6b58fa37e2e"></a>
+<h2 class="memtitle"><span class="permalink"><a href="#gab40f5096a72fd7e5bda9d6b58fa37e2e">&#9670;&nbsp;</a></span>tjCompressFromYUV()</h2>
 
 <div class="memitem">
 <div class="memproto">
@@ -1222,7 +1223,7 @@ If you choose option 1, <code>*jpegSize</code> should be set to the size of your
           <td class="paramkey"></td>
           <td></td>
           <td class="paramtype">int&#160;</td>
-          <td class="paramname"><em>pad</em>, </td>
+          <td class="paramname"><em>align</em>, </td>
         </tr>
         <tr>
           <td class="paramkey"></td>
@@ -1268,22 +1269,22 @@ If you choose option 1, <code>*jpegSize</code> should be set to the size of your
       </table>
 </div><div class="memdoc">
 
-<p>Compress a YUV planar image into a JPEG image. </p>
+<p>Compress a unified planar YUV image into a JPEG image. </p>
 <dl class="params"><dt>Parameters</dt><dd>
   <table class="params">
     <tr><td class="paramname">handle</td><td>a handle to a TurboJPEG compressor or transformer instance</td></tr>
-    <tr><td class="paramname">srcBuf</td><td>pointer to an image buffer containing a YUV planar image to be compressed. The size of this buffer should match the value returned by <a class="el" href="group___turbo_j_p_e_g.html#ga2be2b9969d4df9ecce9b05deed273194" title="The size of the buffer (in bytes) required to hold a YUV planar image with the given parameters.">tjBufSizeYUV2()</a> for the given image width, height, padding, and level of chrominance subsampling. The Y, U (Cb), and V (Cr) image planes should be stored sequentially in the source buffer (refer to <a class="el" href="group___turbo_j_p_e_g.html#YUVnotes">YUV Image Format Notes</a>.)</td></tr>
-    <tr><td class="paramname">width</td><td>width (in pixels) of the source image. If the width is not an even multiple of the MCU block width (see <a class="el" href="group___turbo_j_p_e_g.html#ga9e61e7cd47a15a173283ba94e781308c" title="MCU block width (in pixels) for a given level of chrominance subsampling.">tjMCUWidth</a>), then an intermediate buffer copy will be performed within TurboJPEG.</td></tr>
-    <tr><td class="paramname">pad</td><td>the line padding used in the source image. For instance, if each line in each plane of the YUV image is padded to the nearest multiple of 4 bytes, then <code>pad</code> should be set to 4.</td></tr>
-    <tr><td class="paramname">height</td><td>height (in pixels) of the source image. If the height is not an even multiple of the MCU block height (see <a class="el" href="group___turbo_j_p_e_g.html#gabd247bb9fecb393eca57366feb8327bf" title="MCU block height (in pixels) for a given level of chrominance subsampling.">tjMCUHeight</a>), then an intermediate buffer copy will be performed within TurboJPEG.</td></tr>
+    <tr><td class="paramname">srcBuf</td><td>pointer to a buffer containing a unified planar YUV source image to be compressed. The size of this buffer should match the value returned by <a class="el" href="group___turbo_j_p_e_g.html#ga5e5aac9e8bcf17049279301e2466474c" title="The size of the buffer (in bytes) required to hold a unified planar YUV image with the given paramete...">tjBufSizeYUV2()</a> for the given image width, height, row alignment, and level of chrominance subsampling. The Y, U (Cb), and V (Cr) image planes should be stored sequentially in the buffer. (Refer to <a class="el" href="group___turbo_j_p_e_g.html#YUVnotes">YUV Image Format Notes</a>.)</td></tr>
+    <tr><td class="paramname">width</td><td>width (in pixels) of the source image. If the width is not an even multiple of the MCU block width (see <a class="el" href="group___turbo_j_p_e_g.html#ga9e61e7cd47a15a173283ba94e781308c" title="MCU block width (in pixels) for a given level of chrominance subsampling.">tjMCUWidth</a>), then an intermediate buffer copy will be performed.</td></tr>
+    <tr><td class="paramname">align</td><td>row alignment (in bytes) of the source image (must be a power of 2.) Setting this parameter to n indicates that each row in each plane of the source image is padded to the nearest multiple of n bytes (1 = unpadded.)</td></tr>
+    <tr><td class="paramname">height</td><td>height (in pixels) of the source image. If the height is not an even multiple of the MCU block height (see <a class="el" href="group___turbo_j_p_e_g.html#gabd247bb9fecb393eca57366feb8327bf" title="MCU block height (in pixels) for a given level of chrominance subsampling.">tjMCUHeight</a>), then an intermediate buffer copy will be performed.</td></tr>
     <tr><td class="paramname">subsamp</td><td>the level of chrominance subsampling used in the source image (see <a class="el" href="group___turbo_j_p_e_g.html#ga1d047060ea80bb9820d540bb928e9074">Chrominance subsampling options</a>.)</td></tr>
-    <tr><td class="paramname">jpegBuf</td><td>address of a pointer to an image buffer that will receive the JPEG image. TurboJPEG has the ability to reallocate the JPEG buffer to accommodate the size of the JPEG image. Thus, you can choose to:<ol type="1">
-<li>pre-allocate the JPEG buffer with an arbitrary size using <a class="el" href="group___turbo_j_p_e_g.html#gaec627dd4c5f30b7a775a7aea3bec5d83" title="Allocate an image buffer for use with TurboJPEG.">tjAlloc()</a> and let TurboJPEG grow the buffer as needed,</li>
+    <tr><td class="paramname">jpegBuf</td><td>address of a pointer to a byte buffer that will receive the JPEG image. TurboJPEG has the ability to reallocate the JPEG buffer to accommodate the size of the JPEG image. Thus, you can choose to:<ol type="1">
+<li>pre-allocate the JPEG buffer with an arbitrary size using <a class="el" href="group___turbo_j_p_e_g.html#gaec627dd4c5f30b7a775a7aea3bec5d83" title="Allocate a byte buffer for use with TurboJPEG.">tjAlloc()</a> and let TurboJPEG grow the buffer as needed,</li>
 <li>set <code>*jpegBuf</code> to NULL to tell TurboJPEG to allocate the buffer for you, or</li>
-<li>pre-allocate the buffer to a "worst case" size determined by calling <a class="el" href="group___turbo_j_p_e_g.html#ga67ac12fee79073242cb216e07c9f1f90" title="The maximum size of the buffer (in bytes) required to hold a JPEG image with the given parameters.">tjBufSize()</a>. This should ensure that the buffer never has to be re-allocated (setting <a class="el" href="group___turbo_j_p_e_g.html#ga8808d403c68b62aaa58a4c1e58e98963" title="Disable buffer (re)allocation.">TJFLAG_NOREALLOC</a> guarantees that it won't be.)</li>
+<li>pre-allocate the buffer to a "worst case" size determined by calling <a class="el" href="group___turbo_j_p_e_g.html#ga67ac12fee79073242cb216e07c9f1f90" title="The maximum size of the buffer (in bytes) required to hold a JPEG image with the given parameters.">tjBufSize()</a>. This should ensure that the buffer never has to be re-allocated. (Setting <a class="el" href="group___turbo_j_p_e_g.html#ga8808d403c68b62aaa58a4c1e58e98963" title="Disable JPEG buffer (re)allocation.">TJFLAG_NOREALLOC</a> guarantees that it won't be.)</li>
 </ol>
-If you choose option 1, <code>*jpegSize</code> should be set to the size of your pre-allocated buffer. In any case, unless you have set <a class="el" href="group___turbo_j_p_e_g.html#ga8808d403c68b62aaa58a4c1e58e98963" title="Disable buffer (re)allocation.">TJFLAG_NOREALLOC</a>, you should always check <code>*jpegBuf</code> upon return from this function, as it may have changed.</td></tr>
-    <tr><td class="paramname">jpegSize</td><td>pointer to an unsigned long variable that holds the size of the JPEG image buffer. If <code>*jpegBuf</code> points to a pre-allocated buffer, then <code>*jpegSize</code> should be set to the size of the buffer. Upon return, <code>*jpegSize</code> will contain the size of the JPEG image (in bytes.) If <code>*jpegBuf</code> points to a JPEG image buffer that is being reused from a previous call to one of the JPEG compression functions, then <code>*jpegSize</code> is ignored.</td></tr>
+If you choose option 1, then <code>*jpegSize</code> should be set to the size of your pre-allocated buffer. In any case, unless you have set <a class="el" href="group___turbo_j_p_e_g.html#ga8808d403c68b62aaa58a4c1e58e98963" title="Disable JPEG buffer (re)allocation.">TJFLAG_NOREALLOC</a>, you should always check <code>*jpegBuf</code> upon return from this function, as it may have changed.</td></tr>
+    <tr><td class="paramname">jpegSize</td><td>pointer to an unsigned long variable that holds the size of the JPEG buffer. If <code>*jpegBuf</code> points to a pre-allocated buffer, then <code>*jpegSize</code> should be set to the size of the buffer. Upon return, <code>*jpegSize</code> will contain the size of the JPEG image (in bytes.) If <code>*jpegBuf</code> points to a JPEG buffer that is being reused from a previous call to one of the JPEG compression functions, then <code>*jpegSize</code> is ignored.</td></tr>
     <tr><td class="paramname">jpegQual</td><td>the image quality of the generated JPEG image (1 = worst, 100 = best)</td></tr>
     <tr><td class="paramname">flags</td><td>the bitwise OR of one or more of the <a class="el" href="group___turbo_j_p_e_g.html#gacb233cfd722d66d1ccbf48a7de81f0e0">flags</a></td></tr>
   </table>
@@ -1371,18 +1372,18 @@ If you choose option 1, <code>*jpegSize</code> should be set to the size of your
 <dl class="params"><dt>Parameters</dt><dd>
   <table class="params">
     <tr><td class="paramname">handle</td><td>a handle to a TurboJPEG compressor or transformer instance</td></tr>
-    <tr><td class="paramname">srcPlanes</td><td>an array of pointers to Y, U (Cb), and V (Cr) image planes (or just a Y plane, if compressing a grayscale image) that contain a YUV image to be compressed. These planes can be contiguous or non-contiguous in memory. The size of each plane should match the value returned by <a class="el" href="group___turbo_j_p_e_g.html#gab4ab7b24f6e797d79abaaa670373961d" title="The size of the buffer (in bytes) required to hold a YUV image plane with the given parameters.">tjPlaneSizeYUV()</a> for the given image width, height, strides, and level of chrominance subsampling. Refer to <a class="el" href="group___turbo_j_p_e_g.html#YUVnotes">YUV Image Format Notes</a> for more details.</td></tr>
-    <tr><td class="paramname">width</td><td>width (in pixels) of the source image. If the width is not an even multiple of the MCU block width (see <a class="el" href="group___turbo_j_p_e_g.html#ga9e61e7cd47a15a173283ba94e781308c" title="MCU block width (in pixels) for a given level of chrominance subsampling.">tjMCUWidth</a>), then an intermediate buffer copy will be performed within TurboJPEG.</td></tr>
-    <tr><td class="paramname">strides</td><td>an array of integers, each specifying the number of bytes per line in the corresponding plane of the YUV source image. Setting the stride for any plane to 0 is the same as setting it to the plane width (see <a class="el" href="group___turbo_j_p_e_g.html#YUVnotes">YUV Image Format Notes</a>.) If <code>strides</code> is NULL, then the strides for all planes will be set to their respective plane widths. You can adjust the strides in order to specify an arbitrary amount of line padding in each plane or to create a JPEG image from a subregion of a larger YUV planar image.</td></tr>
-    <tr><td class="paramname">height</td><td>height (in pixels) of the source image. If the height is not an even multiple of the MCU block height (see <a class="el" href="group___turbo_j_p_e_g.html#gabd247bb9fecb393eca57366feb8327bf" title="MCU block height (in pixels) for a given level of chrominance subsampling.">tjMCUHeight</a>), then an intermediate buffer copy will be performed within TurboJPEG.</td></tr>
+    <tr><td class="paramname">srcPlanes</td><td>an array of pointers to Y, U (Cb), and V (Cr) image planes (or just a Y plane, if compressing a grayscale image) that contain a YUV source image to be compressed. These planes can be contiguous or non-contiguous in memory. The size of each plane should match the value returned by <a class="el" href="group___turbo_j_p_e_g.html#gab4ab7b24f6e797d79abaaa670373961d" title="The size of the buffer (in bytes) required to hold a YUV image plane with the given parameters.">tjPlaneSizeYUV()</a> for the given image width, height, strides, and level of chrominance subsampling. Refer to <a class="el" href="group___turbo_j_p_e_g.html#YUVnotes">YUV Image Format Notes</a> for more details.</td></tr>
+    <tr><td class="paramname">width</td><td>width (in pixels) of the source image. If the width is not an even multiple of the MCU block width (see <a class="el" href="group___turbo_j_p_e_g.html#ga9e61e7cd47a15a173283ba94e781308c" title="MCU block width (in pixels) for a given level of chrominance subsampling.">tjMCUWidth</a>), then an intermediate buffer copy will be performed.</td></tr>
+    <tr><td class="paramname">strides</td><td>an array of integers, each specifying the number of bytes per row in the corresponding plane of the YUV source image. Setting the stride for any plane to 0 is the same as setting it to the plane width (see <a class="el" href="group___turbo_j_p_e_g.html#YUVnotes">YUV Image Format Notes</a>.) If <code>strides</code> is NULL, then the strides for all planes will be set to their respective plane widths. You can adjust the strides in order to specify an arbitrary amount of row padding in each plane or to create a JPEG image from a subregion of a larger planar YUV image.</td></tr>
+    <tr><td class="paramname">height</td><td>height (in pixels) of the source image. If the height is not an even multiple of the MCU block height (see <a class="el" href="group___turbo_j_p_e_g.html#gabd247bb9fecb393eca57366feb8327bf" title="MCU block height (in pixels) for a given level of chrominance subsampling.">tjMCUHeight</a>), then an intermediate buffer copy will be performed.</td></tr>
     <tr><td class="paramname">subsamp</td><td>the level of chrominance subsampling used in the source image (see <a class="el" href="group___turbo_j_p_e_g.html#ga1d047060ea80bb9820d540bb928e9074">Chrominance subsampling options</a>.)</td></tr>
-    <tr><td class="paramname">jpegBuf</td><td>address of a pointer to an image buffer that will receive the JPEG image. TurboJPEG has the ability to reallocate the JPEG buffer to accommodate the size of the JPEG image. Thus, you can choose to:<ol type="1">
-<li>pre-allocate the JPEG buffer with an arbitrary size using <a class="el" href="group___turbo_j_p_e_g.html#gaec627dd4c5f30b7a775a7aea3bec5d83" title="Allocate an image buffer for use with TurboJPEG.">tjAlloc()</a> and let TurboJPEG grow the buffer as needed,</li>
+    <tr><td class="paramname">jpegBuf</td><td>address of a pointer to a byte buffer that will receive the JPEG image. TurboJPEG has the ability to reallocate the JPEG buffer to accommodate the size of the JPEG image. Thus, you can choose to:<ol type="1">
+<li>pre-allocate the JPEG buffer with an arbitrary size using <a class="el" href="group___turbo_j_p_e_g.html#gaec627dd4c5f30b7a775a7aea3bec5d83" title="Allocate a byte buffer for use with TurboJPEG.">tjAlloc()</a> and let TurboJPEG grow the buffer as needed,</li>
 <li>set <code>*jpegBuf</code> to NULL to tell TurboJPEG to allocate the buffer for you, or</li>
-<li>pre-allocate the buffer to a "worst case" size determined by calling <a class="el" href="group___turbo_j_p_e_g.html#ga67ac12fee79073242cb216e07c9f1f90" title="The maximum size of the buffer (in bytes) required to hold a JPEG image with the given parameters.">tjBufSize()</a>. This should ensure that the buffer never has to be re-allocated (setting <a class="el" href="group___turbo_j_p_e_g.html#ga8808d403c68b62aaa58a4c1e58e98963" title="Disable buffer (re)allocation.">TJFLAG_NOREALLOC</a> guarantees that it won't be.)</li>
+<li>pre-allocate the buffer to a "worst case" size determined by calling <a class="el" href="group___turbo_j_p_e_g.html#ga67ac12fee79073242cb216e07c9f1f90" title="The maximum size of the buffer (in bytes) required to hold a JPEG image with the given parameters.">tjBufSize()</a>. This should ensure that the buffer never has to be re-allocated. (Setting <a class="el" href="group___turbo_j_p_e_g.html#ga8808d403c68b62aaa58a4c1e58e98963" title="Disable JPEG buffer (re)allocation.">TJFLAG_NOREALLOC</a> guarantees that it won't be.)</li>
 </ol>
-If you choose option 1, <code>*jpegSize</code> should be set to the size of your pre-allocated buffer. In any case, unless you have set <a class="el" href="group___turbo_j_p_e_g.html#ga8808d403c68b62aaa58a4c1e58e98963" title="Disable buffer (re)allocation.">TJFLAG_NOREALLOC</a>, you should always check <code>*jpegBuf</code> upon return from this function, as it may have changed.</td></tr>
-    <tr><td class="paramname">jpegSize</td><td>pointer to an unsigned long variable that holds the size of the JPEG image buffer. If <code>*jpegBuf</code> points to a pre-allocated buffer, then <code>*jpegSize</code> should be set to the size of the buffer. Upon return, <code>*jpegSize</code> will contain the size of the JPEG image (in bytes.) If <code>*jpegBuf</code> points to a JPEG image buffer that is being reused from a previous call to one of the JPEG compression functions, then <code>*jpegSize</code> is ignored.</td></tr>
+If you choose option 1, then <code>*jpegSize</code> should be set to the size of your pre-allocated buffer. In any case, unless you have set <a class="el" href="group___turbo_j_p_e_g.html#ga8808d403c68b62aaa58a4c1e58e98963" title="Disable JPEG buffer (re)allocation.">TJFLAG_NOREALLOC</a>, you should always check <code>*jpegBuf</code> upon return from this function, as it may have changed.</td></tr>
+    <tr><td class="paramname">jpegSize</td><td>pointer to an unsigned long variable that holds the size of the JPEG buffer. If <code>*jpegBuf</code> points to a pre-allocated buffer, then <code>*jpegSize</code> should be set to the size of the buffer. Upon return, <code>*jpegSize</code> will contain the size of the JPEG image (in bytes.) If <code>*jpegBuf</code> points to a JPEG buffer that is being reused from a previous call to one of the JPEG compression functions, then <code>*jpegSize</code> is ignored.</td></tr>
     <tr><td class="paramname">jpegQual</td><td>the image quality of the generated JPEG image (1 = worst, 100 = best)</td></tr>
     <tr><td class="paramname">flags</td><td>the bitwise OR of one or more of the <a class="el" href="group___turbo_j_p_e_g.html#gacb233cfd722d66d1ccbf48a7de81f0e0">flags</a></td></tr>
   </table>
@@ -1392,8 +1393,8 @@ If you choose option 1, <code>*jpegSize</code> should be set to the size of your
 
 </div>
 </div>
-<a id="ga70abbf38f77a26fd6da8813bef96f695"></a>
-<h2 class="memtitle"><span class="permalink"><a href="#ga70abbf38f77a26fd6da8813bef96f695">&#9670;&nbsp;</a></span>tjDecodeYUV()</h2>
+<a id="ga97c2cedc1e2bade15a84164c94e503c1"></a>
+<h2 class="memtitle"><span class="permalink"><a href="#ga97c2cedc1e2bade15a84164c94e503c1">&#9670;&nbsp;</a></span>tjDecodeYUV()</h2>
 
 <div class="memitem">
 <div class="memproto">
@@ -1414,7 +1415,7 @@ If you choose option 1, <code>*jpegSize</code> should be set to the size of your
           <td class="paramkey"></td>
           <td></td>
           <td class="paramtype">int&#160;</td>
-          <td class="paramname"><em>pad</em>, </td>
+          <td class="paramname"><em>align</em>, </td>
         </tr>
         <tr>
           <td class="paramkey"></td>
@@ -1466,17 +1467,17 @@ If you choose option 1, <code>*jpegSize</code> should be set to the size of your
       </table>
 </div><div class="memdoc">
 
-<p>Decode a YUV planar image into an RGB or grayscale image. </p>
-<p>This function uses the accelerated color conversion routines in the underlying codec but does not execute any of the other steps in the JPEG decompression process.</p>
+<p>Decode a unified planar YUV image into a packed-pixel RGB or grayscale image. </p>
+<p>This function performs color conversion (which is accelerated in the libjpeg-turbo implementation) but does not execute any of the other steps in the JPEG decompression process.</p>
 <dl class="params"><dt>Parameters</dt><dd>
   <table class="params">
     <tr><td class="paramname">handle</td><td>a handle to a TurboJPEG decompressor or transformer instance</td></tr>
-    <tr><td class="paramname">srcBuf</td><td>pointer to an image buffer containing a YUV planar image to be decoded. The size of this buffer should match the value returned by <a class="el" href="group___turbo_j_p_e_g.html#ga2be2b9969d4df9ecce9b05deed273194" title="The size of the buffer (in bytes) required to hold a YUV planar image with the given parameters.">tjBufSizeYUV2()</a> for the given image width, height, padding, and level of chrominance subsampling. The Y, U (Cb), and V (Cr) image planes should be stored sequentially in the source buffer (refer to <a class="el" href="group___turbo_j_p_e_g.html#YUVnotes">YUV Image Format Notes</a>.)</td></tr>
-    <tr><td class="paramname">pad</td><td>Use this parameter to specify that the width of each line in each plane of the YUV source image is padded to the nearest multiple of this number of bytes (must be a power of 2.)</td></tr>
+    <tr><td class="paramname">srcBuf</td><td>pointer to a buffer containing a unified planar YUV source image to be decoded. The size of this buffer should match the value returned by <a class="el" href="group___turbo_j_p_e_g.html#ga5e5aac9e8bcf17049279301e2466474c" title="The size of the buffer (in bytes) required to hold a unified planar YUV image with the given paramete...">tjBufSizeYUV2()</a> for the given image width, height, row alignment, and level of chrominance subsampling. The Y, U (Cb), and V (Cr) image planes should be stored sequentially in the source buffer. (Refer to <a class="el" href="group___turbo_j_p_e_g.html#YUVnotes">YUV Image Format Notes</a>.)</td></tr>
+    <tr><td class="paramname">align</td><td>row alignment (in bytes) of the YUV source image (must be a power of 2.) Setting this parameter to n indicates that each row in each plane of the YUV source image is padded to the nearest multiple of n bytes (1 = unpadded.)</td></tr>
     <tr><td class="paramname">subsamp</td><td>the level of chrominance subsampling used in the YUV source image (see <a class="el" href="group___turbo_j_p_e_g.html#ga1d047060ea80bb9820d540bb928e9074">Chrominance subsampling options</a>.)</td></tr>
-    <tr><td class="paramname">dstBuf</td><td>pointer to an image buffer that will receive the decoded image. This buffer should normally be <code>pitch * height</code> bytes in size, but the <code>dstBuf</code> pointer can also be used to decode into a specific region of a larger buffer.</td></tr>
+    <tr><td class="paramname">dstBuf</td><td>pointer to a buffer that will receive the packed-pixel decoded image. This buffer should normally be <code>pitch * height</code> bytes in size, but the <code>dstBuf</code> pointer can also be used to decode into a specific region of a larger buffer.</td></tr>
     <tr><td class="paramname">width</td><td>width (in pixels) of the source and destination images</td></tr>
-    <tr><td class="paramname">pitch</td><td>bytes per line in the destination image. Normally, this should be <code>width * <a class="el" href="group___turbo_j_p_e_g.html#gad77cf8fe5b2bfd3cb3f53098146abb4c" title="Pixel size (in bytes) for a given pixel format.">tjPixelSize</a>[pixelFormat]</code> if the destination image is unpadded, or <code><a class="el" href="group___turbo_j_p_e_g.html#ga0aba955473315e405295d978f0c16511" title="Pad the given width to the nearest 32-bit boundary.">TJPAD</a>(width * <a class="el" href="group___turbo_j_p_e_g.html#gad77cf8fe5b2bfd3cb3f53098146abb4c" title="Pixel size (in bytes) for a given pixel format.">tjPixelSize</a>[pixelFormat])</code> if each line of the destination image should be padded to the nearest 32-bit boundary, as is the case for Windows bitmaps. You can also be clever and use the pitch parameter to skip lines, etc. Setting this parameter to 0 is the equivalent of setting it to <code>width * <a class="el" href="group___turbo_j_p_e_g.html#gad77cf8fe5b2bfd3cb3f53098146abb4c" title="Pixel size (in bytes) for a given pixel format.">tjPixelSize</a>[pixelFormat]</code>.</td></tr>
+    <tr><td class="paramname">pitch</td><td>bytes per row in the destination image. Normally this should be set to <code>width * <a class="el" href="group___turbo_j_p_e_g.html#gad77cf8fe5b2bfd3cb3f53098146abb4c" title="Pixel size (in bytes) for a given pixel format.">tjPixelSize</a>[pixelFormat]</code>, if the destination image should be unpadded, or <code><a class="el" href="group___turbo_j_p_e_g.html#ga0aba955473315e405295d978f0c16511" title="Pad the given width to the nearest multiple of 4.">TJPAD</a>(width * <a class="el" href="group___turbo_j_p_e_g.html#gad77cf8fe5b2bfd3cb3f53098146abb4c" title="Pixel size (in bytes) for a given pixel format.">tjPixelSize</a>[pixelFormat])</code> if each row of the destination image should be padded to the nearest multiple of 4 bytes, as is the case for Windows bitmaps. You can also be clever and use the pitch parameter to skip rows, etc. Setting this parameter to 0 is the equivalent of setting it to <code>width * <a class="el" href="group___turbo_j_p_e_g.html#gad77cf8fe5b2bfd3cb3f53098146abb4c" title="Pixel size (in bytes) for a given pixel format.">tjPixelSize</a>[pixelFormat]</code>.</td></tr>
     <tr><td class="paramname">height</td><td>height (in pixels) of the source and destination images</td></tr>
     <tr><td class="paramname">pixelFormat</td><td>pixel format of the destination image (see <a class="el" href="group___turbo_j_p_e_g.html#gac916144e26c3817ac514e64ae5d12e2a">Pixel formats</a>.)</td></tr>
     <tr><td class="paramname">flags</td><td>the bitwise OR of one or more of the <a class="el" href="group___turbo_j_p_e_g.html#gacb233cfd722d66d1ccbf48a7de81f0e0">flags</a></td></tr>
@@ -1561,17 +1562,17 @@ If you choose option 1, <code>*jpegSize</code> should be set to the size of your
       </table>
 </div><div class="memdoc">
 
-<p>Decode a set of Y, U (Cb), and V (Cr) image planes into an RGB or grayscale image. </p>
-<p>This function uses the accelerated color conversion routines in the underlying codec but does not execute any of the other steps in the JPEG decompression process.</p>
+<p>Decode a set of Y, U (Cb), and V (Cr) image planes into a packed-pixel RGB or grayscale image. </p>
+<p>This function performs color conversion (which is accelerated in the libjpeg-turbo implementation) but does not execute any of the other steps in the JPEG decompression process.</p>
 <dl class="params"><dt>Parameters</dt><dd>
   <table class="params">
     <tr><td class="paramname">handle</td><td>a handle to a TurboJPEG decompressor or transformer instance</td></tr>
     <tr><td class="paramname">srcPlanes</td><td>an array of pointers to Y, U (Cb), and V (Cr) image planes (or just a Y plane, if decoding a grayscale image) that contain a YUV image to be decoded. These planes can be contiguous or non-contiguous in memory. The size of each plane should match the value returned by <a class="el" href="group___turbo_j_p_e_g.html#gab4ab7b24f6e797d79abaaa670373961d" title="The size of the buffer (in bytes) required to hold a YUV image plane with the given parameters.">tjPlaneSizeYUV()</a> for the given image width, height, strides, and level of chrominance subsampling. Refer to <a class="el" href="group___turbo_j_p_e_g.html#YUVnotes">YUV Image Format Notes</a> for more details.</td></tr>
-    <tr><td class="paramname">strides</td><td>an array of integers, each specifying the number of bytes per line in the corresponding plane of the YUV source image. Setting the stride for any plane to 0 is the same as setting it to the plane width (see <a class="el" href="group___turbo_j_p_e_g.html#YUVnotes">YUV Image Format Notes</a>.) If <code>strides</code> is NULL, then the strides for all planes will be set to their respective plane widths. You can adjust the strides in order to specify an arbitrary amount of line padding in each plane or to decode a subregion of a larger YUV planar image.</td></tr>
+    <tr><td class="paramname">strides</td><td>an array of integers, each specifying the number of bytes per row in the corresponding plane of the YUV source image. Setting the stride for any plane to 0 is the same as setting it to the plane width (see <a class="el" href="group___turbo_j_p_e_g.html#YUVnotes">YUV Image Format Notes</a>.) If <code>strides</code> is NULL, then the strides for all planes will be set to their respective plane widths. You can adjust the strides in order to specify an arbitrary amount of row padding in each plane or to decode a subregion of a larger planar YUV image.</td></tr>
     <tr><td class="paramname">subsamp</td><td>the level of chrominance subsampling used in the YUV source image (see <a class="el" href="group___turbo_j_p_e_g.html#ga1d047060ea80bb9820d540bb928e9074">Chrominance subsampling options</a>.)</td></tr>
-    <tr><td class="paramname">dstBuf</td><td>pointer to an image buffer that will receive the decoded image. This buffer should normally be <code>pitch * height</code> bytes in size, but the <code>dstBuf</code> pointer can also be used to decode into a specific region of a larger buffer.</td></tr>
+    <tr><td class="paramname">dstBuf</td><td>pointer to a buffer that will receive the packed-pixel decoded image. This buffer should normally be <code>pitch * height</code> bytes in size, but the <code>dstBuf</code> pointer can also be used to decode into a specific region of a larger buffer.</td></tr>
     <tr><td class="paramname">width</td><td>width (in pixels) of the source and destination images</td></tr>
-    <tr><td class="paramname">pitch</td><td>bytes per line in the destination image. Normally, this should be <code>width * <a class="el" href="group___turbo_j_p_e_g.html#gad77cf8fe5b2bfd3cb3f53098146abb4c" title="Pixel size (in bytes) for a given pixel format.">tjPixelSize</a>[pixelFormat]</code> if the destination image is unpadded, or <code><a class="el" href="group___turbo_j_p_e_g.html#ga0aba955473315e405295d978f0c16511" title="Pad the given width to the nearest 32-bit boundary.">TJPAD</a>(width * <a class="el" href="group___turbo_j_p_e_g.html#gad77cf8fe5b2bfd3cb3f53098146abb4c" title="Pixel size (in bytes) for a given pixel format.">tjPixelSize</a>[pixelFormat])</code> if each line of the destination image should be padded to the nearest 32-bit boundary, as is the case for Windows bitmaps. You can also be clever and use the pitch parameter to skip lines, etc. Setting this parameter to 0 is the equivalent of setting it to <code>width * <a class="el" href="group___turbo_j_p_e_g.html#gad77cf8fe5b2bfd3cb3f53098146abb4c" title="Pixel size (in bytes) for a given pixel format.">tjPixelSize</a>[pixelFormat]</code>.</td></tr>
+    <tr><td class="paramname">pitch</td><td>bytes per row in the destination image. Normally this should be set to <code>width * <a class="el" href="group___turbo_j_p_e_g.html#gad77cf8fe5b2bfd3cb3f53098146abb4c" title="Pixel size (in bytes) for a given pixel format.">tjPixelSize</a>[pixelFormat]</code>, if the destination image should be unpadded, or <code><a class="el" href="group___turbo_j_p_e_g.html#ga0aba955473315e405295d978f0c16511" title="Pad the given width to the nearest multiple of 4.">TJPAD</a>(width * <a class="el" href="group___turbo_j_p_e_g.html#gad77cf8fe5b2bfd3cb3f53098146abb4c" title="Pixel size (in bytes) for a given pixel format.">tjPixelSize</a>[pixelFormat])</code> if each row of the destination image should be padded to the nearest multiple of 4 bytes, as is the case for Windows bitmaps. You can also be clever and use the pitch parameter to skip rows, etc. Setting this parameter to 0 is the equivalent of setting it to <code>width * <a class="el" href="group___turbo_j_p_e_g.html#gad77cf8fe5b2bfd3cb3f53098146abb4c" title="Pixel size (in bytes) for a given pixel format.">tjPixelSize</a>[pixelFormat]</code>.</td></tr>
     <tr><td class="paramname">height</td><td>height (in pixels) of the source and destination images</td></tr>
     <tr><td class="paramname">pixelFormat</td><td>pixel format of the destination image (see <a class="el" href="group___turbo_j_p_e_g.html#gac916144e26c3817ac514e64ae5d12e2a">Pixel formats</a>.)</td></tr>
     <tr><td class="paramname">flags</td><td>the bitwise OR of one or more of the <a class="el" href="group___turbo_j_p_e_g.html#gacb233cfd722d66d1ccbf48a7de81f0e0">flags</a></td></tr>
@@ -1650,15 +1651,15 @@ If you choose option 1, <code>*jpegSize</code> should be set to the size of your
       </table>
 </div><div class="memdoc">
 
-<p>Decompress a JPEG image to an RGB, grayscale, or CMYK image. </p>
+<p>Decompress a JPEG image into a packed-pixel RGB, grayscale, or CMYK image. </p>
 <dl class="params"><dt>Parameters</dt><dd>
   <table class="params">
     <tr><td class="paramname">handle</td><td>a handle to a TurboJPEG decompressor or transformer instance</td></tr>
-    <tr><td class="paramname">jpegBuf</td><td>pointer to a buffer containing the JPEG image to decompress</td></tr>
+    <tr><td class="paramname">jpegBuf</td><td>pointer to a byte buffer containing the JPEG image to decompress</td></tr>
     <tr><td class="paramname">jpegSize</td><td>size of the JPEG image (in bytes)</td></tr>
-    <tr><td class="paramname">dstBuf</td><td>pointer to an image buffer that will receive the decompressed image. This buffer should normally be <code>pitch * scaledHeight</code> bytes in size, where <code>scaledHeight</code> can be determined by calling <a class="el" href="group___turbo_j_p_e_g.html#ga84878bb65404204743aa18cac02781df" title="Compute the scaled value of dimension using the given scaling factor.">TJSCALED()</a> with the JPEG image height and one of the scaling factors returned by <a class="el" href="group___turbo_j_p_e_g.html#gac3854476006b10787bd128f7ede48057" title="Returns a list of fractional scaling factors that the JPEG decompressor in this implementation of Tur...">tjGetScalingFactors()</a>. The <code>dstBuf</code> pointer may also be used to decompress into a specific region of a larger buffer.</td></tr>
+    <tr><td class="paramname">dstBuf</td><td>pointer to a buffer that will receive the packed-pixel decompressed image. This buffer should normally be <code>pitch * scaledHeight</code> bytes in size, where <code>scaledHeight</code> can be determined by calling <a class="el" href="group___turbo_j_p_e_g.html#ga84878bb65404204743aa18cac02781df" title="Compute the scaled value of dimension using the given scaling factor.">TJSCALED()</a> with the JPEG image height and one of the scaling factors returned by <a class="el" href="group___turbo_j_p_e_g.html#ga193d0977b3b9966d53a6c402e90899b1" title="Returns a list of fractional scaling factors that the JPEG decompressor supports.">tjGetScalingFactors()</a>. The <code>dstBuf</code> pointer may also be used to decompress into a specific region of a larger buffer.</td></tr>
     <tr><td class="paramname">width</td><td>desired width (in pixels) of the destination image. If this is different than the width of the JPEG image being decompressed, then TurboJPEG will use scaling in the JPEG decompressor to generate the largest possible image that will fit within the desired width. If <code>width</code> is set to 0, then only the height will be considered when determining the scaled image size.</td></tr>
-    <tr><td class="paramname">pitch</td><td>bytes per line in the destination image. Normally, this is <code>scaledWidth * <a class="el" href="group___turbo_j_p_e_g.html#gad77cf8fe5b2bfd3cb3f53098146abb4c" title="Pixel size (in bytes) for a given pixel format.">tjPixelSize</a>[pixelFormat]</code> if the decompressed image is unpadded, else <code><a class="el" href="group___turbo_j_p_e_g.html#ga0aba955473315e405295d978f0c16511" title="Pad the given width to the nearest 32-bit boundary.">TJPAD</a>(scaledWidth * <a class="el" href="group___turbo_j_p_e_g.html#gad77cf8fe5b2bfd3cb3f53098146abb4c" title="Pixel size (in bytes) for a given pixel format.">tjPixelSize</a>[pixelFormat])</code> if each line of the decompressed image is padded to the nearest 32-bit boundary, as is the case for Windows bitmaps. (NOTE: <code>scaledWidth</code> can be determined by calling <a class="el" href="group___turbo_j_p_e_g.html#ga84878bb65404204743aa18cac02781df" title="Compute the scaled value of dimension using the given scaling factor.">TJSCALED()</a> with the JPEG image width and one of the scaling factors returned by <a class="el" href="group___turbo_j_p_e_g.html#gac3854476006b10787bd128f7ede48057" title="Returns a list of fractional scaling factors that the JPEG decompressor in this implementation of Tur...">tjGetScalingFactors()</a>.) You can also be clever and use the pitch parameter to skip lines, etc. Setting this parameter to 0 is the equivalent of setting it to <code>scaledWidth * <a class="el" href="group___turbo_j_p_e_g.html#gad77cf8fe5b2bfd3cb3f53098146abb4c" title="Pixel size (in bytes) for a given pixel format.">tjPixelSize</a>[pixelFormat]</code>.</td></tr>
+    <tr><td class="paramname">pitch</td><td>bytes per row in the destination image. Normally this should be set to <code>scaledWidth * <a class="el" href="group___turbo_j_p_e_g.html#gad77cf8fe5b2bfd3cb3f53098146abb4c" title="Pixel size (in bytes) for a given pixel format.">tjPixelSize</a>[pixelFormat]</code>, if the destination image should be unpadded, or <code><a class="el" href="group___turbo_j_p_e_g.html#ga0aba955473315e405295d978f0c16511" title="Pad the given width to the nearest multiple of 4.">TJPAD</a>(scaledWidth * <a class="el" href="group___turbo_j_p_e_g.html#gad77cf8fe5b2bfd3cb3f53098146abb4c" title="Pixel size (in bytes) for a given pixel format.">tjPixelSize</a>[pixelFormat])</code> if each row of the destination image should be padded to the nearest multiple of 4 bytes, as is the case for Windows bitmaps. (NOTE: <code>scaledWidth</code> can be determined by calling <a class="el" href="group___turbo_j_p_e_g.html#ga84878bb65404204743aa18cac02781df" title="Compute the scaled value of dimension using the given scaling factor.">TJSCALED()</a> with the JPEG image width and one of the scaling factors returned by <a class="el" href="group___turbo_j_p_e_g.html#ga193d0977b3b9966d53a6c402e90899b1" title="Returns a list of fractional scaling factors that the JPEG decompressor supports.">tjGetScalingFactors()</a>.) You can also be clever and use the pitch parameter to skip rows, etc. Setting this parameter to 0 is the equivalent of setting it to <code>scaledWidth * <a class="el" href="group___turbo_j_p_e_g.html#gad77cf8fe5b2bfd3cb3f53098146abb4c" title="Pixel size (in bytes) for a given pixel format.">tjPixelSize</a>[pixelFormat]</code>.</td></tr>
     <tr><td class="paramname">height</td><td>desired height (in pixels) of the destination image. If this is different than the height of the JPEG image being decompressed, then TurboJPEG will use scaling in the JPEG decompressor to generate the largest possible image that will fit within the desired height. If <code>height</code> is set to 0, then only the width will be considered when determining the scaled image size.</td></tr>
     <tr><td class="paramname">pixelFormat</td><td>pixel format of the destination image (see <a class="el" href="group___turbo_j_p_e_g.html#gac916144e26c3817ac514e64ae5d12e2a">Pixel formats</a>.)</td></tr>
     <tr><td class="paramname">flags</td><td>the bitwise OR of one or more of the <a class="el" href="group___turbo_j_p_e_g.html#gacb233cfd722d66d1ccbf48a7de81f0e0">flags</a></td></tr>
@@ -1729,7 +1730,7 @@ If you choose option 1, <code>*jpegSize</code> should be set to the size of your
 <dl class="params"><dt>Parameters</dt><dd>
   <table class="params">
     <tr><td class="paramname">handle</td><td>a handle to a TurboJPEG decompressor or transformer instance</td></tr>
-    <tr><td class="paramname">jpegBuf</td><td>pointer to a buffer containing a JPEG image or an "abbreviated table specification" (AKA "tables-only") datastream. Passing a tables-only datastream to this function primes the decompressor with quantization and Huffman tables that can be used when decompressing subsequent "abbreviated image" datastreams. This is useful, for instance, when decompressing video streams in which all frames share the same quantization and Huffman tables.</td></tr>
+    <tr><td class="paramname">jpegBuf</td><td>pointer to a byte buffer containing a JPEG image or an "abbreviated table specification" (AKA "tables-only") datastream. Passing a tables-only datastream to this function primes the decompressor with quantization and Huffman tables that can be used when decompressing subsequent "abbreviated image" datastreams. This is useful, for instance, when decompressing video streams in which all frames share the same quantization and Huffman tables.</td></tr>
     <tr><td class="paramname">jpegSize</td><td>size of the JPEG image or tables-only datastream (in bytes)</td></tr>
     <tr><td class="paramname">width</td><td>pointer to an integer variable that will receive the width (in pixels) of the JPEG image. If <code>jpegBuf</code> points to a tables-only datastream, then <code>width</code> is ignored.</td></tr>
     <tr><td class="paramname">height</td><td>pointer to an integer variable that will receive the height (in pixels) of the JPEG image. If <code>jpegBuf</code> points to a tables-only datastream, then <code>height</code> is ignored.</td></tr>
@@ -1742,8 +1743,8 @@ If you choose option 1, <code>*jpegSize</code> should be set to the size of your
 
 </div>
 </div>
-<a id="ga04d1e839ff9a0860dd1475cff78d3364"></a>
-<h2 class="memtitle"><span class="permalink"><a href="#ga04d1e839ff9a0860dd1475cff78d3364">&#9670;&nbsp;</a></span>tjDecompressToYUV2()</h2>
+<a id="ga5a3093e325598c17a9f004323af6fafa"></a>
+<h2 class="memtitle"><span class="permalink"><a href="#ga5a3093e325598c17a9f004323af6fafa">&#9670;&nbsp;</a></span>tjDecompressToYUV2()</h2>
 
 <div class="memitem">
 <div class="memproto">
@@ -1782,7 +1783,7 @@ If you choose option 1, <code>*jpegSize</code> should be set to the size of your
           <td class="paramkey"></td>
           <td></td>
           <td class="paramtype">int&#160;</td>
-          <td class="paramname"><em>pad</em>, </td>
+          <td class="paramname"><em>align</em>, </td>
         </tr>
         <tr>
           <td class="paramkey"></td>
@@ -1804,17 +1805,17 @@ If you choose option 1, <code>*jpegSize</code> should be set to the size of your
       </table>
 </div><div class="memdoc">
 
-<p>Decompress a JPEG image to a YUV planar image. </p>
-<p>This function performs JPEG decompression but leaves out the color conversion step, so a planar YUV image is generated instead of an RGB image.</p>
+<p>Decompress a JPEG image into a unified planar YUV image. </p>
+<p>This function performs JPEG decompression but leaves out the color conversion step, so a planar YUV image is generated instead of a packed-pixel image.</p>
 <dl class="params"><dt>Parameters</dt><dd>
   <table class="params">
     <tr><td class="paramname">handle</td><td>a handle to a TurboJPEG decompressor or transformer instance</td></tr>
-    <tr><td class="paramname">jpegBuf</td><td>pointer to a buffer containing the JPEG image to decompress</td></tr>
+    <tr><td class="paramname">jpegBuf</td><td>pointer to a byte buffer containing the JPEG image to decompress</td></tr>
     <tr><td class="paramname">jpegSize</td><td>size of the JPEG image (in bytes)</td></tr>
-    <tr><td class="paramname">dstBuf</td><td>pointer to an image buffer that will receive the YUV image. Use <a class="el" href="group___turbo_j_p_e_g.html#ga2be2b9969d4df9ecce9b05deed273194" title="The size of the buffer (in bytes) required to hold a YUV planar image with the given parameters.">tjBufSizeYUV2()</a> to determine the appropriate size for this buffer based on the image width, height, padding, and level of subsampling. The Y, U (Cb), and V (Cr) image planes will be stored sequentially in the buffer (refer to <a class="el" href="group___turbo_j_p_e_g.html#YUVnotes">YUV Image Format Notes</a>.)</td></tr>
-    <tr><td class="paramname">width</td><td>desired width (in pixels) of the YUV image. If this is different than the width of the JPEG image being decompressed, then TurboJPEG will use scaling in the JPEG decompressor to generate the largest possible image that will fit within the desired width. If <code>width</code> is set to 0, then only the height will be considered when determining the scaled image size. If the scaled width is not an even multiple of the MCU block width (see <a class="el" href="group___turbo_j_p_e_g.html#ga9e61e7cd47a15a173283ba94e781308c" title="MCU block width (in pixels) for a given level of chrominance subsampling.">tjMCUWidth</a>), then an intermediate buffer copy will be performed within TurboJPEG.</td></tr>
-    <tr><td class="paramname">pad</td><td>the width of each line in each plane of the YUV image will be padded to the nearest multiple of this number of bytes (must be a power of 2.) To generate images suitable for X Video, <code>pad</code> should be set to 4.</td></tr>
-    <tr><td class="paramname">height</td><td>desired height (in pixels) of the YUV image. If this is different than the height of the JPEG image being decompressed, then TurboJPEG will use scaling in the JPEG decompressor to generate the largest possible image that will fit within the desired height. If <code>height</code> is set to 0, then only the width will be considered when determining the scaled image size. If the scaled height is not an even multiple of the MCU block height (see <a class="el" href="group___turbo_j_p_e_g.html#gabd247bb9fecb393eca57366feb8327bf" title="MCU block height (in pixels) for a given level of chrominance subsampling.">tjMCUHeight</a>), then an intermediate buffer copy will be performed within TurboJPEG.</td></tr>
+    <tr><td class="paramname">dstBuf</td><td>pointer to a buffer that will receive the unified planar YUV decompressed image. Use <a class="el" href="group___turbo_j_p_e_g.html#ga5e5aac9e8bcf17049279301e2466474c" title="The size of the buffer (in bytes) required to hold a unified planar YUV image with the given paramete...">tjBufSizeYUV2()</a> to determine the appropriate size for this buffer based on the scaled image width, scaled image height, row alignment, and level of chrominance subsampling. The Y, U (Cb), and V (Cr) image planes will be stored sequentially in the buffer. (Refer to <a class="el" href="group___turbo_j_p_e_g.html#YUVnotes">YUV Image Format Notes</a>.)</td></tr>
+    <tr><td class="paramname">width</td><td>desired width (in pixels) of the YUV image. If this is different than the width of the JPEG image being decompressed, then TurboJPEG will use scaling in the JPEG decompressor to generate the largest possible image that will fit within the desired width. If <code>width</code> is set to 0, then only the height will be considered when determining the scaled image size. If the scaled width is not an even multiple of the MCU block width (see <a class="el" href="group___turbo_j_p_e_g.html#ga9e61e7cd47a15a173283ba94e781308c" title="MCU block width (in pixels) for a given level of chrominance subsampling.">tjMCUWidth</a>), then an intermediate buffer copy will be performed.</td></tr>
+    <tr><td class="paramname">align</td><td>row alignment (in bytes) of the YUV image (must be a power of 2.) Setting this parameter to n will cause each row in each plane of the YUV image to be padded to the nearest multiple of n bytes (1 = unpadded.) To generate images suitable for X Video, <code>align</code> should be set to 4.</td></tr>
+    <tr><td class="paramname">height</td><td>desired height (in pixels) of the YUV image. If this is different than the height of the JPEG image being decompressed, then TurboJPEG will use scaling in the JPEG decompressor to generate the largest possible image that will fit within the desired height. If <code>height</code> is set to 0, then only the width will be considered when determining the scaled image size. If the scaled height is not an even multiple of the MCU block height (see <a class="el" href="group___turbo_j_p_e_g.html#gabd247bb9fecb393eca57366feb8327bf" title="MCU block height (in pixels) for a given level of chrominance subsampling.">tjMCUHeight</a>), then an intermediate buffer copy will be performed.</td></tr>
     <tr><td class="paramname">flags</td><td>the bitwise OR of one or more of the <a class="el" href="group___turbo_j_p_e_g.html#gacb233cfd722d66d1ccbf48a7de81f0e0">flags</a></td></tr>
   </table>
   </dd>
@@ -1886,16 +1887,16 @@ If you choose option 1, <code>*jpegSize</code> should be set to the size of your
 </div><div class="memdoc">
 
 <p>Decompress a JPEG image into separate Y, U (Cb), and V (Cr) image planes. </p>
-<p>This function performs JPEG decompression but leaves out the color conversion step, so a planar YUV image is generated instead of an RGB image.</p>
+<p>This function performs JPEG decompression but leaves out the color conversion step, so a planar YUV image is generated instead of a packed-pixel image.</p>
 <dl class="params"><dt>Parameters</dt><dd>
   <table class="params">
     <tr><td class="paramname">handle</td><td>a handle to a TurboJPEG decompressor or transformer instance</td></tr>
-    <tr><td class="paramname">jpegBuf</td><td>pointer to a buffer containing the JPEG image to decompress</td></tr>
+    <tr><td class="paramname">jpegBuf</td><td>pointer to a byte buffer containing the JPEG image to decompress</td></tr>
     <tr><td class="paramname">jpegSize</td><td>size of the JPEG image (in bytes)</td></tr>
-    <tr><td class="paramname">dstPlanes</td><td>an array of pointers to Y, U (Cb), and V (Cr) image planes (or just a Y plane, if decompressing a grayscale image) that will receive the YUV image. These planes can be contiguous or non-contiguous in memory. Use <a class="el" href="group___turbo_j_p_e_g.html#gab4ab7b24f6e797d79abaaa670373961d" title="The size of the buffer (in bytes) required to hold a YUV image plane with the given parameters.">tjPlaneSizeYUV()</a> to determine the appropriate size for each plane based on the scaled image width, scaled image height, strides, and level of chrominance subsampling. Refer to <a class="el" href="group___turbo_j_p_e_g.html#YUVnotes">YUV Image Format Notes</a> for more details.</td></tr>
-    <tr><td class="paramname">width</td><td>desired width (in pixels) of the YUV image. If this is different than the width of the JPEG image being decompressed, then TurboJPEG will use scaling in the JPEG decompressor to generate the largest possible image that will fit within the desired width. If <code>width</code> is set to 0, then only the height will be considered when determining the scaled image size. If the scaled width is not an even multiple of the MCU block width (see <a class="el" href="group___turbo_j_p_e_g.html#ga9e61e7cd47a15a173283ba94e781308c" title="MCU block width (in pixels) for a given level of chrominance subsampling.">tjMCUWidth</a>), then an intermediate buffer copy will be performed within TurboJPEG.</td></tr>
-    <tr><td class="paramname">strides</td><td>an array of integers, each specifying the number of bytes per line in the corresponding plane of the output image. Setting the stride for any plane to 0 is the same as setting it to the scaled plane width (see <a class="el" href="group___turbo_j_p_e_g.html#YUVnotes">YUV Image Format Notes</a>.) If <code>strides</code> is NULL, then the strides for all planes will be set to their respective scaled plane widths. You can adjust the strides in order to add an arbitrary amount of line padding to each plane or to decompress the JPEG image into a subregion of a larger YUV planar image.</td></tr>
-    <tr><td class="paramname">height</td><td>desired height (in pixels) of the YUV image. If this is different than the height of the JPEG image being decompressed, then TurboJPEG will use scaling in the JPEG decompressor to generate the largest possible image that will fit within the desired height. If <code>height</code> is set to 0, then only the width will be considered when determining the scaled image size. If the scaled height is not an even multiple of the MCU block height (see <a class="el" href="group___turbo_j_p_e_g.html#gabd247bb9fecb393eca57366feb8327bf" title="MCU block height (in pixels) for a given level of chrominance subsampling.">tjMCUHeight</a>), then an intermediate buffer copy will be performed within TurboJPEG.</td></tr>
+    <tr><td class="paramname">dstPlanes</td><td>an array of pointers to Y, U (Cb), and V (Cr) image planes (or just a Y plane, if decompressing a grayscale image) that will receive the decompressed image. These planes can be contiguous or non-contiguous in memory. Use <a class="el" href="group___turbo_j_p_e_g.html#gab4ab7b24f6e797d79abaaa670373961d" title="The size of the buffer (in bytes) required to hold a YUV image plane with the given parameters.">tjPlaneSizeYUV()</a> to determine the appropriate size for each plane based on the scaled image width, scaled image height, strides, and level of chrominance subsampling. Refer to <a class="el" href="group___turbo_j_p_e_g.html#YUVnotes">YUV Image Format Notes</a> for more details.</td></tr>
+    <tr><td class="paramname">width</td><td>desired width (in pixels) of the YUV image. If this is different than the width of the JPEG image being decompressed, then TurboJPEG will use scaling in the JPEG decompressor to generate the largest possible image that will fit within the desired width. If <code>width</code> is set to 0, then only the height will be considered when determining the scaled image size. If the scaled width is not an even multiple of the MCU block width (see <a class="el" href="group___turbo_j_p_e_g.html#ga9e61e7cd47a15a173283ba94e781308c" title="MCU block width (in pixels) for a given level of chrominance subsampling.">tjMCUWidth</a>), then an intermediate buffer copy will be performed.</td></tr>
+    <tr><td class="paramname">strides</td><td>an array of integers, each specifying the number of bytes per row in the corresponding plane of the YUV image. Setting the stride for any plane to 0 is the same as setting it to the scaled plane width (see <a class="el" href="group___turbo_j_p_e_g.html#YUVnotes">YUV Image Format Notes</a>.) If <code>strides</code> is NULL, then the strides for all planes will be set to their respective scaled plane widths. You can adjust the strides in order to add an arbitrary amount of row padding to each plane or to decompress the JPEG image into a subregion of a larger planar YUV image.</td></tr>
+    <tr><td class="paramname">height</td><td>desired height (in pixels) of the YUV image. If this is different than the height of the JPEG image being decompressed, then TurboJPEG will use scaling in the JPEG decompressor to generate the largest possible image that will fit within the desired height. If <code>height</code> is set to 0, then only the width will be considered when determining the scaled image size. If the scaled height is not an even multiple of the MCU block height (see <a class="el" href="group___turbo_j_p_e_g.html#gabd247bb9fecb393eca57366feb8327bf" title="MCU block height (in pixels) for a given level of chrominance subsampling.">tjMCUHeight</a>), then an intermediate buffer copy will be performed.</td></tr>
     <tr><td class="paramname">flags</td><td>the bitwise OR of one or more of the <a class="el" href="group___turbo_j_p_e_g.html#gacb233cfd722d66d1ccbf48a7de81f0e0">flags</a></td></tr>
   </table>
   </dd>
@@ -1931,8 +1932,8 @@ If you choose option 1, <code>*jpegSize</code> should be set to the size of your
 
 </div>
 </div>
-<a id="gac519b922cdf446e97d0cdcba513636bf"></a>
-<h2 class="memtitle"><span class="permalink"><a href="#gac519b922cdf446e97d0cdcba513636bf">&#9670;&nbsp;</a></span>tjEncodeYUV3()</h2>
+<a id="ga5d619e0a02b71e05a8dffb764f6d7a64"></a>
+<h2 class="memtitle"><span class="permalink"><a href="#ga5d619e0a02b71e05a8dffb764f6d7a64">&#9670;&nbsp;</a></span>tjEncodeYUV3()</h2>
 
 <div class="memitem">
 <div class="memproto">
@@ -1983,7 +1984,7 @@ If you choose option 1, <code>*jpegSize</code> should be set to the size of your
           <td class="paramkey"></td>
           <td></td>
           <td class="paramtype">int&#160;</td>
-          <td class="paramname"><em>pad</em>, </td>
+          <td class="paramname"><em>align</em>, </td>
         </tr>
         <tr>
           <td class="paramkey"></td>
@@ -2005,18 +2006,18 @@ If you choose option 1, <code>*jpegSize</code> should be set to the size of your
       </table>
 </div><div class="memdoc">
 
-<p>Encode an RGB or grayscale image into a YUV planar image. </p>
-<p>This function uses the accelerated color conversion routines in the underlying codec but does not execute any of the other steps in the JPEG compression process.</p>
+<p>Encode a packed-pixel RGB or grayscale image into a unified planar YUV image. </p>
+<p>This function performs color conversion (which is accelerated in the libjpeg-turbo implementation) but does not execute any of the other steps in the JPEG compression process.</p>
 <dl class="params"><dt>Parameters</dt><dd>
   <table class="params">
     <tr><td class="paramname">handle</td><td>a handle to a TurboJPEG compressor or transformer instance</td></tr>
-    <tr><td class="paramname">srcBuf</td><td>pointer to an image buffer containing RGB or grayscale pixels to be encoded</td></tr>
+    <tr><td class="paramname">srcBuf</td><td>pointer to a buffer containing a packed-pixel RGB or grayscale source image to be encoded</td></tr>
     <tr><td class="paramname">width</td><td>width (in pixels) of the source image</td></tr>
-    <tr><td class="paramname">pitch</td><td>bytes per line in the source image. Normally, this should be <code>width * <a class="el" href="group___turbo_j_p_e_g.html#gad77cf8fe5b2bfd3cb3f53098146abb4c" title="Pixel size (in bytes) for a given pixel format.">tjPixelSize</a>[pixelFormat]</code> if the image is unpadded, or <code><a class="el" href="group___turbo_j_p_e_g.html#ga0aba955473315e405295d978f0c16511" title="Pad the given width to the nearest 32-bit boundary.">TJPAD</a>(width * <a class="el" href="group___turbo_j_p_e_g.html#gad77cf8fe5b2bfd3cb3f53098146abb4c" title="Pixel size (in bytes) for a given pixel format.">tjPixelSize</a>[pixelFormat])</code> if each line of the image is padded to the nearest 32-bit boundary, as is the case for Windows bitmaps. You can also be clever and use this parameter to skip lines, etc. Setting this parameter to 0 is the equivalent of setting it to <code>width * <a class="el" href="group___turbo_j_p_e_g.html#gad77cf8fe5b2bfd3cb3f53098146abb4c" title="Pixel size (in bytes) for a given pixel format.">tjPixelSize</a>[pixelFormat]</code>.</td></tr>
+    <tr><td class="paramname">pitch</td><td>bytes per row in the source image. Normally this should be <code>width * <a class="el" href="group___turbo_j_p_e_g.html#gad77cf8fe5b2bfd3cb3f53098146abb4c" title="Pixel size (in bytes) for a given pixel format.">tjPixelSize</a>[pixelFormat]</code>, if the image is unpadded, or <code><a class="el" href="group___turbo_j_p_e_g.html#ga0aba955473315e405295d978f0c16511" title="Pad the given width to the nearest multiple of 4.">TJPAD</a>(width * <a class="el" href="group___turbo_j_p_e_g.html#gad77cf8fe5b2bfd3cb3f53098146abb4c" title="Pixel size (in bytes) for a given pixel format.">tjPixelSize</a>[pixelFormat])</code> if each row of the image is padded to the nearest multiple of 4 bytes, as is the case for Windows bitmaps. You can also be clever and use this parameter to skip rows, etc. Setting this parameter to 0 is the equivalent of setting it to <code>width * <a class="el" href="group___turbo_j_p_e_g.html#gad77cf8fe5b2bfd3cb3f53098146abb4c" title="Pixel size (in bytes) for a given pixel format.">tjPixelSize</a>[pixelFormat]</code>.</td></tr>
     <tr><td class="paramname">height</td><td>height (in pixels) of the source image</td></tr>
     <tr><td class="paramname">pixelFormat</td><td>pixel format of the source image (see <a class="el" href="group___turbo_j_p_e_g.html#gac916144e26c3817ac514e64ae5d12e2a">Pixel formats</a>.)</td></tr>
-    <tr><td class="paramname">dstBuf</td><td>pointer to an image buffer that will receive the YUV image. Use <a class="el" href="group___turbo_j_p_e_g.html#ga2be2b9969d4df9ecce9b05deed273194" title="The size of the buffer (in bytes) required to hold a YUV planar image with the given parameters.">tjBufSizeYUV2()</a> to determine the appropriate size for this buffer based on the image width, height, padding, and level of chrominance subsampling. The Y, U (Cb), and V (Cr) image planes will be stored sequentially in the buffer (refer to <a class="el" href="group___turbo_j_p_e_g.html#YUVnotes">YUV Image Format Notes</a>.)</td></tr>
-    <tr><td class="paramname">pad</td><td>the width of each line in each plane of the YUV image will be padded to the nearest multiple of this number of bytes (must be a power of 2.) To generate images suitable for X Video, <code>pad</code> should be set to 4.</td></tr>
+    <tr><td class="paramname">dstBuf</td><td>pointer to a buffer that will receive the unified planar YUV image. Use <a class="el" href="group___turbo_j_p_e_g.html#ga5e5aac9e8bcf17049279301e2466474c" title="The size of the buffer (in bytes) required to hold a unified planar YUV image with the given paramete...">tjBufSizeYUV2()</a> to determine the appropriate size for this buffer based on the image width, height, row alignment, and level of chrominance subsampling. The Y, U (Cb), and V (Cr) image planes will be stored sequentially in the buffer. (Refer to <a class="el" href="group___turbo_j_p_e_g.html#YUVnotes">YUV Image Format Notes</a>.)</td></tr>
+    <tr><td class="paramname">align</td><td>row alignment (in bytes) of the YUV image (must be a power of 2.) Setting this parameter to n will cause each row in each plane of the YUV image to be padded to the nearest multiple of n bytes (1 = unpadded.) To generate images suitable for X Video, <code>align</code> should be set to 4.</td></tr>
     <tr><td class="paramname">subsamp</td><td>the level of chrominance subsampling to be used when generating the YUV image (see <a class="el" href="group___turbo_j_p_e_g.html#ga1d047060ea80bb9820d540bb928e9074">Chrominance subsampling options</a>.) To generate images suitable for X Video, <code>subsamp</code> should be set to <a class="el" href="group___turbo_j_p_e_g.html#gga1d047060ea80bb9820d540bb928e9074a63085dbf683cfe39e513cdb6343e3737">TJSAMP_420</a>. This produces an image compatible with the I420 (AKA "YUV420P") format.</td></tr>
     <tr><td class="paramname">flags</td><td>the bitwise OR of one or more of the <a class="el" href="group___turbo_j_p_e_g.html#gacb233cfd722d66d1ccbf48a7de81f0e0">flags</a></td></tr>
   </table>
@@ -2100,18 +2101,18 @@ If you choose option 1, <code>*jpegSize</code> should be set to the size of your
       </table>
 </div><div class="memdoc">
 
-<p>Encode an RGB or grayscale image into separate Y, U (Cb), and V (Cr) image planes. </p>
-<p>This function uses the accelerated color conversion routines in the underlying codec but does not execute any of the other steps in the JPEG compression process.</p>
+<p>Encode a packed-pixel RGB or grayscale image into separate Y, U (Cb), and V (Cr) image planes. </p>
+<p>This function performs color conversion (which is accelerated in the libjpeg-turbo implementation) but does not execute any of the other steps in the JPEG compression process.</p>
 <dl class="params"><dt>Parameters</dt><dd>
   <table class="params">
     <tr><td class="paramname">handle</td><td>a handle to a TurboJPEG compressor or transformer instance</td></tr>
-    <tr><td class="paramname">srcBuf</td><td>pointer to an image buffer containing RGB or grayscale pixels to be encoded</td></tr>
+    <tr><td class="paramname">srcBuf</td><td>pointer to a buffer containing a packed-pixel RGB or grayscale source image to be encoded</td></tr>
     <tr><td class="paramname">width</td><td>width (in pixels) of the source image</td></tr>
-    <tr><td class="paramname">pitch</td><td>bytes per line in the source image. Normally, this should be <code>width * <a class="el" href="group___turbo_j_p_e_g.html#gad77cf8fe5b2bfd3cb3f53098146abb4c" title="Pixel size (in bytes) for a given pixel format.">tjPixelSize</a>[pixelFormat]</code> if the image is unpadded, or <code><a class="el" href="group___turbo_j_p_e_g.html#ga0aba955473315e405295d978f0c16511" title="Pad the given width to the nearest 32-bit boundary.">TJPAD</a>(width * <a class="el" href="group___turbo_j_p_e_g.html#gad77cf8fe5b2bfd3cb3f53098146abb4c" title="Pixel size (in bytes) for a given pixel format.">tjPixelSize</a>[pixelFormat])</code> if each line of the image is padded to the nearest 32-bit boundary, as is the case for Windows bitmaps. You can also be clever and use this parameter to skip lines, etc. Setting this parameter to 0 is the equivalent of setting it to <code>width * <a class="el" href="group___turbo_j_p_e_g.html#gad77cf8fe5b2bfd3cb3f53098146abb4c" title="Pixel size (in bytes) for a given pixel format.">tjPixelSize</a>[pixelFormat]</code>.</td></tr>
+    <tr><td class="paramname">pitch</td><td>bytes per row in the source image. Normally this should be <code>width * <a class="el" href="group___turbo_j_p_e_g.html#gad77cf8fe5b2bfd3cb3f53098146abb4c" title="Pixel size (in bytes) for a given pixel format.">tjPixelSize</a>[pixelFormat]</code>, if the image is unpadded, or <code><a class="el" href="group___turbo_j_p_e_g.html#ga0aba955473315e405295d978f0c16511" title="Pad the given width to the nearest multiple of 4.">TJPAD</a>(width * <a class="el" href="group___turbo_j_p_e_g.html#gad77cf8fe5b2bfd3cb3f53098146abb4c" title="Pixel size (in bytes) for a given pixel format.">tjPixelSize</a>[pixelFormat])</code> if each row of the image is padded to the nearest multiple of 4 bytes, as is the case for Windows bitmaps. You can also be clever and use this parameter to skip rows, etc. Setting this parameter to 0 is the equivalent of setting it to <code>width * <a class="el" href="group___turbo_j_p_e_g.html#gad77cf8fe5b2bfd3cb3f53098146abb4c" title="Pixel size (in bytes) for a given pixel format.">tjPixelSize</a>[pixelFormat]</code>.</td></tr>
     <tr><td class="paramname">height</td><td>height (in pixels) of the source image</td></tr>
     <tr><td class="paramname">pixelFormat</td><td>pixel format of the source image (see <a class="el" href="group___turbo_j_p_e_g.html#gac916144e26c3817ac514e64ae5d12e2a">Pixel formats</a>.)</td></tr>
     <tr><td class="paramname">dstPlanes</td><td>an array of pointers to Y, U (Cb), and V (Cr) image planes (or just a Y plane, if generating a grayscale image) that will receive the encoded image. These planes can be contiguous or non-contiguous in memory. Use <a class="el" href="group___turbo_j_p_e_g.html#gab4ab7b24f6e797d79abaaa670373961d" title="The size of the buffer (in bytes) required to hold a YUV image plane with the given parameters.">tjPlaneSizeYUV()</a> to determine the appropriate size for each plane based on the image width, height, strides, and level of chrominance subsampling. Refer to <a class="el" href="group___turbo_j_p_e_g.html#YUVnotes">YUV Image Format Notes</a> for more details.</td></tr>
-    <tr><td class="paramname">strides</td><td>an array of integers, each specifying the number of bytes per line in the corresponding plane of the output image. Setting the stride for any plane to 0 is the same as setting it to the plane width (see <a class="el" href="group___turbo_j_p_e_g.html#YUVnotes">YUV Image Format Notes</a>.) If <code>strides</code> is NULL, then the strides for all planes will be set to their respective plane widths. You can adjust the strides in order to add an arbitrary amount of line padding to each plane or to encode an RGB or grayscale image into a subregion of a larger YUV planar image.</td></tr>
+    <tr><td class="paramname">strides</td><td>an array of integers, each specifying the number of bytes per row in the corresponding plane of the YUV image. Setting the stride for any plane to 0 is the same as setting it to the plane width (see <a class="el" href="group___turbo_j_p_e_g.html#YUVnotes">YUV Image Format Notes</a>.) If <code>strides</code> is NULL, then the strides for all planes will be set to their respective plane widths. You can adjust the strides in order to add an arbitrary amount of row padding to each plane or to encode an RGB or grayscale image into a subregion of a larger planar YUV image.</td></tr>
     <tr><td class="paramname">subsamp</td><td>the level of chrominance subsampling to be used when generating the YUV image (see <a class="el" href="group___turbo_j_p_e_g.html#ga1d047060ea80bb9820d540bb928e9074">Chrominance subsampling options</a>.) To generate images suitable for X Video, <code>subsamp</code> should be set to <a class="el" href="group___turbo_j_p_e_g.html#gga1d047060ea80bb9820d540bb928e9074a63085dbf683cfe39e513cdb6343e3737">TJSAMP_420</a>. This produces an image compatible with the I420 (AKA "YUV420P") format.</td></tr>
     <tr><td class="paramname">flags</td><td>the bitwise OR of one or more of the <a class="el" href="group___turbo_j_p_e_g.html#gacb233cfd722d66d1ccbf48a7de81f0e0">flags</a></td></tr>
   </table>
@@ -2137,15 +2138,15 @@ If you choose option 1, <code>*jpegSize</code> should be set to the size of your
       </table>
 </div><div class="memdoc">
 
-<p>Free an image buffer previously allocated by TurboJPEG. </p>
-<p>You should always use this function to free JPEG destination buffer(s) that were automatically (re)allocated by the compression and transform functions or that were manually allocated using <a class="el" href="group___turbo_j_p_e_g.html#gaec627dd4c5f30b7a775a7aea3bec5d83" title="Allocate an image buffer for use with TurboJPEG.">tjAlloc()</a>.</p>
+<p>Free a byte buffer previously allocated by TurboJPEG. </p>
+<p>You should always use this function to free JPEG destination buffer(s) that were automatically (re)allocated by the compression and transform functions or that were manually allocated using <a class="el" href="group___turbo_j_p_e_g.html#gaec627dd4c5f30b7a775a7aea3bec5d83" title="Allocate a byte buffer for use with TurboJPEG.">tjAlloc()</a>.</p>
 <dl class="params"><dt>Parameters</dt><dd>
   <table class="params">
     <tr><td class="paramname">buffer</td><td>address of the buffer to free. If the address is NULL, then this function has no effect.</td></tr>
   </table>
   </dd>
 </dl>
-<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___turbo_j_p_e_g.html#gaec627dd4c5f30b7a775a7aea3bec5d83" title="Allocate an image buffer for use with TurboJPEG.">tjAlloc()</a> </dd></dl>
+<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___turbo_j_p_e_g.html#gaec627dd4c5f30b7a775a7aea3bec5d83" title="Allocate a byte buffer for use with TurboJPEG.">tjAlloc()</a> </dd></dl>
 
 </div>
 </div>
@@ -2204,8 +2205,8 @@ If you choose option 1, <code>*jpegSize</code> should be set to the size of your
 
 </div>
 </div>
-<a id="gac3854476006b10787bd128f7ede48057"></a>
-<h2 class="memtitle"><span class="permalink"><a href="#gac3854476006b10787bd128f7ede48057">&#9670;&nbsp;</a></span>tjGetScalingFactors()</h2>
+<a id="ga193d0977b3b9966d53a6c402e90899b1"></a>
+<h2 class="memtitle"><span class="permalink"><a href="#ga193d0977b3b9966d53a6c402e90899b1">&#9670;&nbsp;</a></span>tjGetScalingFactors()</h2>
 
 <div class="memitem">
 <div class="memproto">
@@ -2214,16 +2215,16 @@ If you choose option 1, <code>*jpegSize</code> should be set to the size of your
           <td class="memname">DLLEXPORT <a class="el" href="structtjscalingfactor.html">tjscalingfactor</a>* tjGetScalingFactors </td>
           <td>(</td>
           <td class="paramtype">int *&#160;</td>
-          <td class="paramname"><em>numscalingfactors</em></td><td>)</td>
+          <td class="paramname"><em>numScalingFactors</em></td><td>)</td>
           <td></td>
         </tr>
       </table>
 </div><div class="memdoc">
 
-<p>Returns a list of fractional scaling factors that the JPEG decompressor in this implementation of TurboJPEG supports. </p>
+<p>Returns a list of fractional scaling factors that the JPEG decompressor supports. </p>
 <dl class="params"><dt>Parameters</dt><dd>
   <table class="params">
-    <tr><td class="paramname">numscalingfactors</td><td>pointer to an integer variable that will receive the number of elements in the list</td></tr>
+    <tr><td class="paramname">numScalingFactors</td><td>pointer to an integer variable that will receive the number of elements in the list</td></tr>
   </table>
   </dd>
 </dl>
@@ -2344,25 +2345,25 @@ If you choose option 1, <code>*jpegSize</code> should be set to the size of your
       </table>
 </div><div class="memdoc">
 
-<p>Load an uncompressed image from disk into memory. </p>
+<p>Load a packed-pixel image from disk into memory. </p>
 <dl class="params"><dt>Parameters</dt><dd>
   <table class="params">
-    <tr><td class="paramname">filename</td><td>name of a file containing an uncompressed image in Windows BMP or PBMPLUS (PPM/PGM) format</td></tr>
-    <tr><td class="paramname">width</td><td>pointer to an integer variable that will receive the width (in pixels) of the uncompressed image</td></tr>
-    <tr><td class="paramname">align</td><td>row alignment of the image buffer to be returned (must be a power of 2.) For instance, setting this parameter to 4 will cause all rows in the image buffer to be padded to the nearest 32-bit boundary, and setting this parameter to 1 will cause all rows in the image buffer to be unpadded.</td></tr>
-    <tr><td class="paramname">height</td><td>pointer to an integer variable that will receive the height (in pixels) of the uncompressed image</td></tr>
-    <tr><td class="paramname">pixelFormat</td><td>pointer to an integer variable that specifies or will receive the pixel format of the uncompressed image buffer. The behavior of <a class="el" href="group___turbo_j_p_e_g.html#gaffbd83c375e79f5db4b5c5d8ad4466e7" title="Load an uncompressed image from disk into memory.">tjLoadImage()</a> will vary depending on the value of <code>*pixelFormat</code> passed to the function:<ul>
-<li><a class="el" href="group___turbo_j_p_e_g.html#ggac916144e26c3817ac514e64ae5d12e2aa84c1a6cead7952998e2fb895844a21ed">TJPF_UNKNOWN</a> : The uncompressed image buffer returned by the function will use the most optimal pixel format for the file type, and <code>*pixelFormat</code> will contain the ID of this pixel format upon successful return from the function.</li>
-<li><a class="el" href="group___turbo_j_p_e_g.html#ggac916144e26c3817ac514e64ae5d12e2aa5431b54b015337705f13118073711a1a">TJPF_GRAY</a> : Only PGM files and 8-bit BMP files with a grayscale colormap can be loaded.</li>
-<li><a class="el" href="group___turbo_j_p_e_g.html#ggac916144e26c3817ac514e64ae5d12e2aa7f5100ec44c91994e243f1cf55553f8b">TJPF_CMYK</a> : The RGB or grayscale pixels stored in the file will be converted using a quick &amp; dirty algorithm that is suitable only for testing purposes (proper conversion between CMYK and other formats requires a color management system.)</li>
-<li>Other <a class="el" href="group___turbo_j_p_e_g.html#gac916144e26c3817ac514e64ae5d12e2a">pixel formats</a> : The uncompressed image buffer will use the specified pixel format, and pixel format conversion will be performed if necessary.</li>
+    <tr><td class="paramname">filename</td><td>name of a file containing a packed-pixel image in Windows BMP or PBMPLUS (PPM/PGM) format</td></tr>
+    <tr><td class="paramname">width</td><td>pointer to an integer variable that will receive the width (in pixels) of the packed-pixel image</td></tr>
+    <tr><td class="paramname">align</td><td>row alignment of the packed-pixel buffer to be returned (must be a power of 2.) Setting this parameter to n will cause all rows in the buffer to be padded to the nearest multiple of n bytes (1 = unpadded.)</td></tr>
+    <tr><td class="paramname">height</td><td>pointer to an integer variable that will receive the height (in pixels) of the packed-pixel image</td></tr>
+    <tr><td class="paramname">pixelFormat</td><td>pointer to an integer variable that specifies or will receive the pixel format of the packed-pixel buffer. The behavior of <a class="el" href="group___turbo_j_p_e_g.html#gaffbd83c375e79f5db4b5c5d8ad4466e7" title="Load a packed-pixel image from disk into memory.">tjLoadImage()</a> will vary depending on the value of <code>*pixelFormat</code> passed to the function:<ul>
+<li><a class="el" href="group___turbo_j_p_e_g.html#ggac916144e26c3817ac514e64ae5d12e2aa84c1a6cead7952998e2fb895844a21ed">TJPF_UNKNOWN</a> : The packed-pixel buffer returned by this function will use the most optimal pixel format for the file type, and <code>*pixelFormat</code> will contain the ID of that pixel format upon successful return from this function.</li>
+<li><a class="el" href="group___turbo_j_p_e_g.html#ggac916144e26c3817ac514e64ae5d12e2aa5431b54b015337705f13118073711a1a">TJPF_GRAY</a> : Only PGM files and 8-bit-per-pixel BMP files with a grayscale colormap can be loaded.</li>
+<li><a class="el" href="group___turbo_j_p_e_g.html#ggac916144e26c3817ac514e64ae5d12e2aa7f5100ec44c91994e243f1cf55553f8b">TJPF_CMYK</a> : The RGB or grayscale pixels stored in the file will be converted using a quick &amp; dirty algorithm that is suitable only for testing purposes. (Proper conversion between CMYK and other formats requires a color management system.)</li>
+<li>Other <a class="el" href="group___turbo_j_p_e_g.html#gac916144e26c3817ac514e64ae5d12e2a">pixel formats</a> : The packed-pixel buffer will use the specified pixel format, and pixel format conversion will be performed if necessary.</li>
 </ul>
 </td></tr>
     <tr><td class="paramname">flags</td><td>the bitwise OR of one or more of the <a class="el" href="group___turbo_j_p_e_g.html#ga72ecf4ebe6eb702d3c6f5ca27455e1ec">flags</a>.</td></tr>
   </table>
   </dd>
 </dl>
-<dl class="section return"><dt>Returns</dt><dd>a pointer to a newly-allocated buffer containing the uncompressed image, converted to the chosen pixel format and with the chosen row alignment, or NULL if an error occurred (see <a class="el" href="group___turbo_j_p_e_g.html#ga1ead8574f9f39fbafc6b497124e7aafa" title="Returns a descriptive error message explaining why the last command failed.">tjGetErrorStr2()</a>.) This buffer should be freed using <a class="el" href="group___turbo_j_p_e_g.html#gaea863d2da0cdb609563aabdf9196514b" title="Free an image buffer previously allocated by TurboJPEG.">tjFree()</a>. </dd></dl>
+<dl class="section return"><dt>Returns</dt><dd>a pointer to a newly-allocated buffer containing the packed-pixel image, converted to the chosen pixel format and with the chosen row alignment, or NULL if an error occurred (see <a class="el" href="group___turbo_j_p_e_g.html#ga1ead8574f9f39fbafc6b497124e7aafa" title="Returns a descriptive error message explaining why the last command failed.">tjGetErrorStr2()</a>.) This buffer should be freed using <a class="el" href="group___turbo_j_p_e_g.html#gaea863d2da0cdb609563aabdf9196514b" title="Free a byte buffer previously allocated by TurboJPEG.">tjFree()</a>. </dd></dl>
 
 </div>
 </div>
@@ -2461,7 +2462,7 @@ If you choose option 1, <code>*jpegSize</code> should be set to the size of your
   <table class="params">
     <tr><td class="paramname">componentID</td><td>ID number of the image plane (0 = Y, 1 = U/Cb, 2 = V/Cr)</td></tr>
     <tr><td class="paramname">width</td><td>width (in pixels) of the YUV image. NOTE: this is the width of the whole image, not the plane width.</td></tr>
-    <tr><td class="paramname">stride</td><td>bytes per line in the image plane. Setting this to 0 is the equivalent of setting it to the plane width.</td></tr>
+    <tr><td class="paramname">stride</td><td>bytes per row in the image plane. Setting this to 0 is the equivalent of setting it to the plane width.</td></tr>
     <tr><td class="paramname">height</td><td>height (in pixels) of the YUV image. NOTE: this is the height of the whole image, not the plane height.</td></tr>
     <tr><td class="paramname">subsamp</td><td>level of chrominance subsampling in the image (see <a class="el" href="group___turbo_j_p_e_g.html#ga1d047060ea80bb9820d540bb928e9074">Chrominance subsampling options</a>.)</td></tr>
   </table>
@@ -2573,15 +2574,15 @@ If you choose option 1, <code>*jpegSize</code> should be set to the size of your
       </table>
 </div><div class="memdoc">
 
-<p>Save an uncompressed image from memory to disk. </p>
+<p>Save a packed-pixel image from memory to disk. </p>
 <dl class="params"><dt>Parameters</dt><dd>
   <table class="params">
-    <tr><td class="paramname">filename</td><td>name of a file to which to save the uncompressed image. The image will be stored in Windows BMP or PBMPLUS (PPM/PGM) format, depending on the file extension.</td></tr>
-    <tr><td class="paramname">buffer</td><td>pointer to an image buffer containing RGB, grayscale, or CMYK pixels to be saved</td></tr>
-    <tr><td class="paramname">width</td><td>width (in pixels) of the uncompressed image</td></tr>
-    <tr><td class="paramname">pitch</td><td>bytes per line in the image buffer. Setting this parameter to 0 is the equivalent of setting it to <code>width * <a class="el" href="group___turbo_j_p_e_g.html#gad77cf8fe5b2bfd3cb3f53098146abb4c" title="Pixel size (in bytes) for a given pixel format.">tjPixelSize</a>[pixelFormat]</code>.</td></tr>
-    <tr><td class="paramname">height</td><td>height (in pixels) of the uncompressed image</td></tr>
-    <tr><td class="paramname">pixelFormat</td><td>pixel format of the image buffer (see <a class="el" href="group___turbo_j_p_e_g.html#gac916144e26c3817ac514e64ae5d12e2a">Pixel formats</a>.) If this parameter is set to <a class="el" href="group___turbo_j_p_e_g.html#ggac916144e26c3817ac514e64ae5d12e2aa5431b54b015337705f13118073711a1a">TJPF_GRAY</a>, then the image will be stored in PGM or 8-bit (indexed color) BMP format. Otherwise, the image will be stored in PPM or 24-bit BMP format. If this parameter is set to <a class="el" href="group___turbo_j_p_e_g.html#ggac916144e26c3817ac514e64ae5d12e2aa7f5100ec44c91994e243f1cf55553f8b">TJPF_CMYK</a>, then the CMYK pixels will be converted to RGB using a quick &amp; dirty algorithm that is suitable only for testing (proper conversion between CMYK and other formats requires a color management system.)</td></tr>
+    <tr><td class="paramname">filename</td><td>name of a file to which to save the packed-pixel image. The image will be stored in Windows BMP or PBMPLUS (PPM/PGM) format, depending on the file extension.</td></tr>
+    <tr><td class="paramname">buffer</td><td>pointer to a buffer containing a packed-pixel RGB, grayscale, or CMYK image to be saved</td></tr>
+    <tr><td class="paramname">width</td><td>width (in pixels) of the packed-pixel image</td></tr>
+    <tr><td class="paramname">pitch</td><td>bytes per row in the packed-pixel image. Setting this parameter to 0 is the equivalent of setting it to <code>width * <a class="el" href="group___turbo_j_p_e_g.html#gad77cf8fe5b2bfd3cb3f53098146abb4c" title="Pixel size (in bytes) for a given pixel format.">tjPixelSize</a>[pixelFormat]</code>.</td></tr>
+    <tr><td class="paramname">height</td><td>height (in pixels) of the packed-pixel image</td></tr>
+    <tr><td class="paramname">pixelFormat</td><td>pixel format of the packed-pixel image (see <a class="el" href="group___turbo_j_p_e_g.html#gac916144e26c3817ac514e64ae5d12e2a">Pixel formats</a>.) If this parameter is set to <a class="el" href="group___turbo_j_p_e_g.html#ggac916144e26c3817ac514e64ae5d12e2aa5431b54b015337705f13118073711a1a">TJPF_GRAY</a>, then the image will be stored in PGM or 8-bit-per-pixel (indexed color) BMP format. Otherwise, the image will be stored in PPM or 24-bit-per-pixel BMP format. If this parameter is set to <a class="el" href="group___turbo_j_p_e_g.html#ggac916144e26c3817ac514e64ae5d12e2aa7f5100ec44c91994e243f1cf55553f8b">TJPF_CMYK</a>, then the CMYK pixels will be converted to RGB using a quick &amp; dirty algorithm that is suitable only for testing purposes. (Proper conversion between CMYK and other formats requires a color management system.)</td></tr>
     <tr><td class="paramname">flags</td><td>the bitwise OR of one or more of the <a class="el" href="group___turbo_j_p_e_g.html#ga72ecf4ebe6eb702d3c6f5ca27455e1ec">flags</a>.</td></tr>
   </table>
   </dd>
@@ -2657,17 +2658,17 @@ If you choose option 1, <code>*jpegSize</code> should be set to the size of your
 <dl class="params"><dt>Parameters</dt><dd>
   <table class="params">
     <tr><td class="paramname">handle</td><td>a handle to a TurboJPEG transformer instance</td></tr>
-    <tr><td class="paramname">jpegBuf</td><td>pointer to a buffer containing the JPEG source image to transform</td></tr>
+    <tr><td class="paramname">jpegBuf</td><td>pointer to a byte buffer containing the JPEG source image to transform</td></tr>
     <tr><td class="paramname">jpegSize</td><td>size of the JPEG source image (in bytes)</td></tr>
     <tr><td class="paramname">n</td><td>the number of transformed JPEG images to generate</td></tr>
-    <tr><td class="paramname">dstBufs</td><td>pointer to an array of n image buffers. <code>dstBufs[i]</code> will receive a JPEG image that has been transformed using the parameters in <code>transforms[i]</code>. TurboJPEG has the ability to reallocate the JPEG buffer to accommodate the size of the JPEG image. Thus, you can choose to:<ol type="1">
-<li>pre-allocate the JPEG buffer with an arbitrary size using <a class="el" href="group___turbo_j_p_e_g.html#gaec627dd4c5f30b7a775a7aea3bec5d83" title="Allocate an image buffer for use with TurboJPEG.">tjAlloc()</a> and let TurboJPEG grow the buffer as needed,</li>
+    <tr><td class="paramname">dstBufs</td><td>pointer to an array of n byte buffers. <code>dstBufs[i]</code> will receive a JPEG image that has been transformed using the parameters in <code>transforms[i]</code>. TurboJPEG has the ability to reallocate the JPEG destination buffer to accommodate the size of the transformed JPEG image. Thus, you can choose to:<ol type="1">
+<li>pre-allocate the JPEG destination buffer with an arbitrary size using <a class="el" href="group___turbo_j_p_e_g.html#gaec627dd4c5f30b7a775a7aea3bec5d83" title="Allocate a byte buffer for use with TurboJPEG.">tjAlloc()</a> and let TurboJPEG grow the buffer as needed,</li>
 <li>set <code>dstBufs[i]</code> to NULL to tell TurboJPEG to allocate the buffer for you, or</li>
-<li>pre-allocate the buffer to a "worst case" size determined by calling <a class="el" href="group___turbo_j_p_e_g.html#ga67ac12fee79073242cb216e07c9f1f90" title="The maximum size of the buffer (in bytes) required to hold a JPEG image with the given parameters.">tjBufSize()</a> with the transformed or cropped width and height. Under normal circumstances, this should ensure that the buffer never has to be re-allocated (setting <a class="el" href="group___turbo_j_p_e_g.html#ga8808d403c68b62aaa58a4c1e58e98963" title="Disable buffer (re)allocation.">TJFLAG_NOREALLOC</a> guarantees that it won't be.) Note, however, that there are some rare cases (such as transforming images with a large amount of embedded EXIF or ICC profile data) in which the output image will be larger than the worst-case size, and <a class="el" href="group___turbo_j_p_e_g.html#ga8808d403c68b62aaa58a4c1e58e98963" title="Disable buffer (re)allocation.">TJFLAG_NOREALLOC</a> cannot be used in those cases.</li>
+<li>pre-allocate the buffer to a "worst case" size determined by calling <a class="el" href="group___turbo_j_p_e_g.html#ga67ac12fee79073242cb216e07c9f1f90" title="The maximum size of the buffer (in bytes) required to hold a JPEG image with the given parameters.">tjBufSize()</a> with the transformed or cropped width and height. Under normal circumstances, this should ensure that the buffer never has to be re-allocated. (Setting <a class="el" href="group___turbo_j_p_e_g.html#ga8808d403c68b62aaa58a4c1e58e98963" title="Disable JPEG buffer (re)allocation.">TJFLAG_NOREALLOC</a> guarantees that it won't be.) Note, however, that there are some rare cases (such as transforming images with a large amount of embedded EXIF or ICC profile data) in which the transformed JPEG image will be larger than the worst-case size, and <a class="el" href="group___turbo_j_p_e_g.html#ga8808d403c68b62aaa58a4c1e58e98963" title="Disable JPEG buffer (re)allocation.">TJFLAG_NOREALLOC</a> cannot be used in those cases.</li>
 </ol>
-If you choose option 1, <code>dstSizes[i]</code> should be set to the size of your pre-allocated buffer. In any case, unless you have set <a class="el" href="group___turbo_j_p_e_g.html#ga8808d403c68b62aaa58a4c1e58e98963" title="Disable buffer (re)allocation.">TJFLAG_NOREALLOC</a>, you should always check <code>dstBufs[i]</code> upon return from this function, as it may have changed.</td></tr>
-    <tr><td class="paramname">dstSizes</td><td>pointer to an array of n unsigned long variables that will receive the actual sizes (in bytes) of each transformed JPEG image. If <code>dstBufs[i]</code> points to a pre-allocated buffer, then <code>dstSizes[i]</code> should be set to the size of the buffer. Upon return, <code>dstSizes[i]</code> will contain the size of the JPEG image (in bytes.)</td></tr>
-    <tr><td class="paramname">transforms</td><td>pointer to an array of n <a class="el" href="structtjtransform.html" title="Lossless transform.">tjtransform</a> structures, each of which specifies the transform parameters and/or cropping region for the corresponding transformed output image.</td></tr>
+If you choose option 1, then <code>dstSizes[i]</code> should be set to the size of your pre-allocated buffer. In any case, unless you have set <a class="el" href="group___turbo_j_p_e_g.html#ga8808d403c68b62aaa58a4c1e58e98963" title="Disable JPEG buffer (re)allocation.">TJFLAG_NOREALLOC</a>, you should always check <code>dstBufs[i]</code> upon return from this function, as it may have changed.</td></tr>
+    <tr><td class="paramname">dstSizes</td><td>pointer to an array of n unsigned long variables that will receive the actual sizes (in bytes) of each transformed JPEG image. If <code>dstBufs[i]</code> points to a pre-allocated buffer, then <code>dstSizes[i]</code> should be set to the size of the buffer. Upon return, <code>dstSizes[i]</code> will contain the size of the transformed JPEG image (in bytes.)</td></tr>
+    <tr><td class="paramname">transforms</td><td>pointer to an array of n <a class="el" href="structtjtransform.html" title="Lossless transform.">tjtransform</a> structures, each of which specifies the transform parameters and/or cropping region for the corresponding transformed JPEG image.</td></tr>
     <tr><td class="paramname">flags</td><td>the bitwise OR of one or more of the <a class="el" href="group___turbo_j_p_e_g.html#gacb233cfd722d66d1ccbf48a7de81f0e0">flags</a></td></tr>
   </table>
   </dd>
@@ -2698,7 +2699,7 @@ If you choose option 1, <code>dstSizes[i]</code> should be set to the size of yo
 </div><div class="memdoc">
 
 <p>Alpha offset (in bytes) for a given pixel format. </p>
-<p>This specifies the number of bytes that the Alpha component is offset from the start of the pixel. For instance, if a pixel of format TJ_BGRA is stored in <code>char pixel[]</code>, then the alpha component will be <code>pixel[tjAlphaOffset[TJ_BGRA]]</code>. This will be -1 if the pixel format does not have an alpha component. </p>
+<p>This specifies the number of bytes that the alpha component is offset from the start of the pixel. For instance, if a pixel of format TJPF_BGRA is stored in <code>unsigned char pixel[]</code>, then the alpha component will be <code>pixel[tjAlphaOffset[TJPF_BGRA]]</code>. This will be -1 if the pixel format does not have an alpha component. </p>
 
 </div>
 </div>
@@ -2723,7 +2724,7 @@ If you choose option 1, <code>dstSizes[i]</code> should be set to the size of yo
 </div><div class="memdoc">
 
 <p>Blue offset (in bytes) for a given pixel format. </p>
-<p>This specifies the number of bytes that the Blue component is offset from the start of the pixel. For instance, if a pixel of format TJ_BGRX is stored in <code>char pixel[]</code>, then the blue component will be <code>pixel[tjBlueOffset[TJ_BGRX]]</code>. This will be -1 if the pixel format does not have a blue component. </p>
+<p>This specifies the number of bytes that the blue component is offset from the start of the pixel. For instance, if a pixel of format TJPF_BGRX is stored in <code>unsigned char pixel[]</code>, then the blue component will be <code>pixel[tjBlueOffset[TJPF_BGRX]]</code>. This will be -1 if the pixel format does not have a blue component. </p>
 
 </div>
 </div>
@@ -2748,7 +2749,7 @@ If you choose option 1, <code>dstSizes[i]</code> should be set to the size of yo
 </div><div class="memdoc">
 
 <p>Green offset (in bytes) for a given pixel format. </p>
-<p>This specifies the number of bytes that the green component is offset from the start of the pixel. For instance, if a pixel of format TJ_BGRX is stored in <code>char pixel[]</code>, then the green component will be <code>pixel[tjGreenOffset[TJ_BGRX]]</code>. This will be -1 if the pixel format does not have a green component. </p>
+<p>This specifies the number of bytes that the green component is offset from the start of the pixel. For instance, if a pixel of format TJPF_BGRX is stored in <code>unsigned char pixel[]</code>, then the green component will be <code>pixel[tjGreenOffset[TJPF_BGRX]]</code>. This will be -1 if the pixel format does not have a green component. </p>
 
 </div>
 </div>
@@ -2859,7 +2860,7 @@ If you choose option 1, <code>dstSizes[i]</code> should be set to the size of yo
 </div><div class="memdoc">
 
 <p>Red offset (in bytes) for a given pixel format. </p>
-<p>This specifies the number of bytes that the red component is offset from the start of the pixel. For instance, if a pixel of format TJ_BGRX is stored in <code>char pixel[]</code>, then the red component will be <code>pixel[tjRedOffset[TJ_BGRX]]</code>. This will be -1 if the pixel format does not have a red component. </p>
+<p>This specifies the number of bytes that the red component is offset from the start of the pixel. For instance, if a pixel of format TJPF_BGRX is stored in <code>unsigned char pixel[]</code>, then the red component will be <code>pixel[tjRedOffset[TJPF_BGRX]]</code>. This will be -1 if the pixel format does not have a red component. </p>
 
 </div>
 </div>
diff --git a/doc/html/search/all_6.js b/doc/html/search/all_6.js
index aa31107..6b43b30 100644
--- a/doc/html/search/all_6.js
+++ b/doc/html/search/all_6.js
@@ -9,9 +9,9 @@ var searchData=
   ['tjalphaoffset_14',['tjAlphaOffset',['../group___turbo_j_p_e_g.html#ga5af0ab065feefd526debf1e20c43e837',1,'turbojpeg.h']]],
   ['tjblueoffset_15',['tjBlueOffset',['../group___turbo_j_p_e_g.html#ga84e2e35d3f08025f976ec1ec53693dea',1,'turbojpeg.h']]],
   ['tjbufsize_16',['tjBufSize',['../group___turbo_j_p_e_g.html#ga67ac12fee79073242cb216e07c9f1f90',1,'turbojpeg.h']]],
-  ['tjbufsizeyuv2_17',['tjBufSizeYUV2',['../group___turbo_j_p_e_g.html#ga2be2b9969d4df9ecce9b05deed273194',1,'turbojpeg.h']]],
+  ['tjbufsizeyuv2_17',['tjBufSizeYUV2',['../group___turbo_j_p_e_g.html#ga5e5aac9e8bcf17049279301e2466474c',1,'turbojpeg.h']]],
   ['tjcompress2_18',['tjCompress2',['../group___turbo_j_p_e_g.html#gafbdce0112fd78fd38efae841443a9bcf',1,'turbojpeg.h']]],
-  ['tjcompressfromyuv_19',['tjCompressFromYUV',['../group___turbo_j_p_e_g.html#ga7622a459b79aa1007e005b58783f875b',1,'turbojpeg.h']]],
+  ['tjcompressfromyuv_19',['tjCompressFromYUV',['../group___turbo_j_p_e_g.html#gab40f5096a72fd7e5bda9d6b58fa37e2e',1,'turbojpeg.h']]],
   ['tjcompressfromyuvplanes_20',['tjCompressFromYUVPlanes',['../group___turbo_j_p_e_g.html#ga29ec5dfbd2d84b8724e951d6fa0d5d9e',1,'turbojpeg.h']]],
   ['tjcs_21',['TJCS',['../group___turbo_j_p_e_g.html#ga4f83ad3368e0e29d1957be0efa7c3720',1,'turbojpeg.h']]],
   ['tjcs_5fcmyk_22',['TJCS_CMYK',['../group___turbo_j_p_e_g.html#gga4f83ad3368e0e29d1957be0efa7c3720a6c8b636152ac8195b869587db315ee53',1,'turbojpeg.h']]],
@@ -19,14 +19,14 @@ var searchData=
   ['tjcs_5frgb_24',['TJCS_RGB',['../group___turbo_j_p_e_g.html#gga4f83ad3368e0e29d1957be0efa7c3720a677cb7ccb85c4038ac41964a2e09e555',1,'turbojpeg.h']]],
   ['tjcs_5fycbcr_25',['TJCS_YCbCr',['../group___turbo_j_p_e_g.html#gga4f83ad3368e0e29d1957be0efa7c3720a7389b8f65bb387ffedce3efd0d78ec75',1,'turbojpeg.h']]],
   ['tjcs_5fycck_26',['TJCS_YCCK',['../group___turbo_j_p_e_g.html#gga4f83ad3368e0e29d1957be0efa7c3720a53839e0fe867b76b58d16b0a1a7c598e',1,'turbojpeg.h']]],
-  ['tjdecodeyuv_27',['tjDecodeYUV',['../group___turbo_j_p_e_g.html#ga70abbf38f77a26fd6da8813bef96f695',1,'turbojpeg.h']]],
+  ['tjdecodeyuv_27',['tjDecodeYUV',['../group___turbo_j_p_e_g.html#ga97c2cedc1e2bade15a84164c94e503c1',1,'turbojpeg.h']]],
   ['tjdecodeyuvplanes_28',['tjDecodeYUVPlanes',['../group___turbo_j_p_e_g.html#ga10e837c07fa9d25770565b237d3898d9',1,'turbojpeg.h']]],
   ['tjdecompress2_29',['tjDecompress2',['../group___turbo_j_p_e_g.html#gae9eccef8b682a48f43a9117c231ed013',1,'turbojpeg.h']]],
   ['tjdecompressheader3_30',['tjDecompressHeader3',['../group___turbo_j_p_e_g.html#ga0595681096bba7199cc6f3533cb25f77',1,'turbojpeg.h']]],
-  ['tjdecompresstoyuv2_31',['tjDecompressToYUV2',['../group___turbo_j_p_e_g.html#ga04d1e839ff9a0860dd1475cff78d3364',1,'turbojpeg.h']]],
+  ['tjdecompresstoyuv2_31',['tjDecompressToYUV2',['../group___turbo_j_p_e_g.html#ga5a3093e325598c17a9f004323af6fafa',1,'turbojpeg.h']]],
   ['tjdecompresstoyuvplanes_32',['tjDecompressToYUVPlanes',['../group___turbo_j_p_e_g.html#gaa59f901a5258ada5bd0185ad59368540',1,'turbojpeg.h']]],
   ['tjdestroy_33',['tjDestroy',['../group___turbo_j_p_e_g.html#ga75f355fa27225ba1a4ee392c852394d2',1,'turbojpeg.h']]],
-  ['tjencodeyuv3_34',['tjEncodeYUV3',['../group___turbo_j_p_e_g.html#gac519b922cdf446e97d0cdcba513636bf',1,'turbojpeg.h']]],
+  ['tjencodeyuv3_34',['tjEncodeYUV3',['../group___turbo_j_p_e_g.html#ga5d619e0a02b71e05a8dffb764f6d7a64',1,'turbojpeg.h']]],
   ['tjencodeyuvplanes_35',['tjEncodeYUVPlanes',['../group___turbo_j_p_e_g.html#gae2d04c72457fe7f4d60cf78ab1b1feb1',1,'turbojpeg.h']]],
   ['tjerr_36',['TJERR',['../group___turbo_j_p_e_g.html#gafbc17cfa57d0d5d11fea35ac025950fe',1,'turbojpeg.h']]],
   ['tjerr_5ffatal_37',['TJERR_FATAL',['../group___turbo_j_p_e_g.html#ggafbc17cfa57d0d5d11fea35ac025950feafc9cceeada13122b09e4851e3788039a',1,'turbojpeg.h']]],
@@ -42,7 +42,7 @@ var searchData=
   ['tjfree_47',['tjFree',['../group___turbo_j_p_e_g.html#gaea863d2da0cdb609563aabdf9196514b',1,'turbojpeg.h']]],
   ['tjgeterrorcode_48',['tjGetErrorCode',['../group___turbo_j_p_e_g.html#ga414feeffbf860ebd31c745df203de410',1,'turbojpeg.h']]],
   ['tjgeterrorstr2_49',['tjGetErrorStr2',['../group___turbo_j_p_e_g.html#ga1ead8574f9f39fbafc6b497124e7aafa',1,'turbojpeg.h']]],
-  ['tjgetscalingfactors_50',['tjGetScalingFactors',['../group___turbo_j_p_e_g.html#gac3854476006b10787bd128f7ede48057',1,'turbojpeg.h']]],
+  ['tjgetscalingfactors_50',['tjGetScalingFactors',['../group___turbo_j_p_e_g.html#ga193d0977b3b9966d53a6c402e90899b1',1,'turbojpeg.h']]],
   ['tjgreenoffset_51',['tjGreenOffset',['../group___turbo_j_p_e_g.html#ga82d6e35da441112a411da41923c0ba2f',1,'turbojpeg.h']]],
   ['tjhandle_52',['tjhandle',['../group___turbo_j_p_e_g.html#ga758d2634ecb4949de7815cba621f5763',1,'turbojpeg.h']]],
   ['tjinitcompress_53',['tjInitCompress',['../group___turbo_j_p_e_g.html#ga9d63a05fc6d813f4aae06107041a37e8',1,'turbojpeg.h']]],
@@ -82,7 +82,7 @@ var searchData=
   ['tjsaveimage_87',['tjSaveImage',['../group___turbo_j_p_e_g.html#ga6f445b22d8933ae4815b3370a538d879',1,'turbojpeg.h']]],
   ['tjscaled_88',['TJSCALED',['../group___turbo_j_p_e_g.html#ga84878bb65404204743aa18cac02781df',1,'turbojpeg.h']]],
   ['tjscalingfactor_89',['tjscalingfactor',['../structtjscalingfactor.html',1,'']]],
-  ['tjtransform_90',['tjtransform',['../structtjtransform.html',1,'tjtransform'],['../group___turbo_j_p_e_g.html#ga504805ec0161f1b505397ca0118bf8fd',1,'tjtransform():&#160;turbojpeg.h'],['../group___turbo_j_p_e_g.html#ga9cb8abf4cc91881e04a0329b2270be25',1,'tjTransform(tjhandle handle, const unsigned char *jpegBuf, unsigned long jpegSize, int n, unsigned char **dstBufs, unsigned long *dstSizes, tjtransform *transforms, int flags):&#160;turbojpeg.h']]],
+  ['tjtransform_90',['tjtransform',['../structtjtransform.html',1,'tjtransform'],['../group___turbo_j_p_e_g.html#ga9cb8abf4cc91881e04a0329b2270be25',1,'tjTransform(tjhandle handle, const unsigned char *jpegBuf, unsigned long jpegSize, int n, unsigned char **dstBufs, unsigned long *dstSizes, tjtransform *transforms, int flags):&#160;turbojpeg.h'],['../group___turbo_j_p_e_g.html#ga504805ec0161f1b505397ca0118bf8fd',1,'tjtransform():&#160;turbojpeg.h']]],
   ['tjxop_91',['TJXOP',['../group___turbo_j_p_e_g.html#ga2de531af4e7e6c4f124908376b354866',1,'turbojpeg.h']]],
   ['tjxop_5fhflip_92',['TJXOP_HFLIP',['../group___turbo_j_p_e_g.html#gga2de531af4e7e6c4f124908376b354866aa0df69776caa30f0fa28e26332d311ce',1,'turbojpeg.h']]],
   ['tjxop_5fnone_93',['TJXOP_NONE',['../group___turbo_j_p_e_g.html#gga2de531af4e7e6c4f124908376b354866aad88c0366cd3f7d0eac9d7a3fa1c2c27',1,'turbojpeg.h']]],
diff --git a/doc/html/search/functions_0.js b/doc/html/search/functions_0.js
index 4a9ea5b..a608dab 100644
--- a/doc/html/search/functions_0.js
+++ b/doc/html/search/functions_0.js
@@ -2,23 +2,23 @@ var searchData=
 [
   ['tjalloc_114',['tjAlloc',['../group___turbo_j_p_e_g.html#gaec627dd4c5f30b7a775a7aea3bec5d83',1,'turbojpeg.h']]],
   ['tjbufsize_115',['tjBufSize',['../group___turbo_j_p_e_g.html#ga67ac12fee79073242cb216e07c9f1f90',1,'turbojpeg.h']]],
-  ['tjbufsizeyuv2_116',['tjBufSizeYUV2',['../group___turbo_j_p_e_g.html#ga2be2b9969d4df9ecce9b05deed273194',1,'turbojpeg.h']]],
+  ['tjbufsizeyuv2_116',['tjBufSizeYUV2',['../group___turbo_j_p_e_g.html#ga5e5aac9e8bcf17049279301e2466474c',1,'turbojpeg.h']]],
   ['tjcompress2_117',['tjCompress2',['../group___turbo_j_p_e_g.html#gafbdce0112fd78fd38efae841443a9bcf',1,'turbojpeg.h']]],
-  ['tjcompressfromyuv_118',['tjCompressFromYUV',['../group___turbo_j_p_e_g.html#ga7622a459b79aa1007e005b58783f875b',1,'turbojpeg.h']]],
+  ['tjcompressfromyuv_118',['tjCompressFromYUV',['../group___turbo_j_p_e_g.html#gab40f5096a72fd7e5bda9d6b58fa37e2e',1,'turbojpeg.h']]],
   ['tjcompressfromyuvplanes_119',['tjCompressFromYUVPlanes',['../group___turbo_j_p_e_g.html#ga29ec5dfbd2d84b8724e951d6fa0d5d9e',1,'turbojpeg.h']]],
-  ['tjdecodeyuv_120',['tjDecodeYUV',['../group___turbo_j_p_e_g.html#ga70abbf38f77a26fd6da8813bef96f695',1,'turbojpeg.h']]],
+  ['tjdecodeyuv_120',['tjDecodeYUV',['../group___turbo_j_p_e_g.html#ga97c2cedc1e2bade15a84164c94e503c1',1,'turbojpeg.h']]],
   ['tjdecodeyuvplanes_121',['tjDecodeYUVPlanes',['../group___turbo_j_p_e_g.html#ga10e837c07fa9d25770565b237d3898d9',1,'turbojpeg.h']]],
   ['tjdecompress2_122',['tjDecompress2',['../group___turbo_j_p_e_g.html#gae9eccef8b682a48f43a9117c231ed013',1,'turbojpeg.h']]],
   ['tjdecompressheader3_123',['tjDecompressHeader3',['../group___turbo_j_p_e_g.html#ga0595681096bba7199cc6f3533cb25f77',1,'turbojpeg.h']]],
-  ['tjdecompresstoyuv2_124',['tjDecompressToYUV2',['../group___turbo_j_p_e_g.html#ga04d1e839ff9a0860dd1475cff78d3364',1,'turbojpeg.h']]],
+  ['tjdecompresstoyuv2_124',['tjDecompressToYUV2',['../group___turbo_j_p_e_g.html#ga5a3093e325598c17a9f004323af6fafa',1,'turbojpeg.h']]],
   ['tjdecompresstoyuvplanes_125',['tjDecompressToYUVPlanes',['../group___turbo_j_p_e_g.html#gaa59f901a5258ada5bd0185ad59368540',1,'turbojpeg.h']]],
   ['tjdestroy_126',['tjDestroy',['../group___turbo_j_p_e_g.html#ga75f355fa27225ba1a4ee392c852394d2',1,'turbojpeg.h']]],
-  ['tjencodeyuv3_127',['tjEncodeYUV3',['../group___turbo_j_p_e_g.html#gac519b922cdf446e97d0cdcba513636bf',1,'turbojpeg.h']]],
+  ['tjencodeyuv3_127',['tjEncodeYUV3',['../group___turbo_j_p_e_g.html#ga5d619e0a02b71e05a8dffb764f6d7a64',1,'turbojpeg.h']]],
   ['tjencodeyuvplanes_128',['tjEncodeYUVPlanes',['../group___turbo_j_p_e_g.html#gae2d04c72457fe7f4d60cf78ab1b1feb1',1,'turbojpeg.h']]],
   ['tjfree_129',['tjFree',['../group___turbo_j_p_e_g.html#gaea863d2da0cdb609563aabdf9196514b',1,'turbojpeg.h']]],
   ['tjgeterrorcode_130',['tjGetErrorCode',['../group___turbo_j_p_e_g.html#ga414feeffbf860ebd31c745df203de410',1,'turbojpeg.h']]],
   ['tjgeterrorstr2_131',['tjGetErrorStr2',['../group___turbo_j_p_e_g.html#ga1ead8574f9f39fbafc6b497124e7aafa',1,'turbojpeg.h']]],
-  ['tjgetscalingfactors_132',['tjGetScalingFactors',['../group___turbo_j_p_e_g.html#gac3854476006b10787bd128f7ede48057',1,'turbojpeg.h']]],
+  ['tjgetscalingfactors_132',['tjGetScalingFactors',['../group___turbo_j_p_e_g.html#ga193d0977b3b9966d53a6c402e90899b1',1,'turbojpeg.h']]],
   ['tjinitcompress_133',['tjInitCompress',['../group___turbo_j_p_e_g.html#ga9d63a05fc6d813f4aae06107041a37e8',1,'turbojpeg.h']]],
   ['tjinitdecompress_134',['tjInitDecompress',['../group___turbo_j_p_e_g.html#ga52300eac3f3d9ef4bab303bc244f62d3',1,'turbojpeg.h']]],
   ['tjinittransform_135',['tjInitTransform',['../group___turbo_j_p_e_g.html#ga928beff6ac248ceadf01089fc6b41957',1,'turbojpeg.h']]],
diff --git a/doc/html/structtjtransform.html b/doc/html/structtjtransform.html
index ba78980..9ff248d 100644
--- a/doc/html/structtjtransform.html
+++ b/doc/html/structtjtransform.html
@@ -84,7 +84,7 @@ Data Fields</h2></td></tr>
 <tr class="memdesc:a2525aab4ba6978a1c273f74fef50e498"><td class="mdescLeft">&#160;</td><td class="mdescRight">One of the <a class="el" href="group___turbo_j_p_e_g.html#ga2de531af4e7e6c4f124908376b354866">transform operations</a>.  <a href="structtjtransform.html#a2525aab4ba6978a1c273f74fef50e498">More...</a><br /></td></tr>
 <tr class="separator:a2525aab4ba6978a1c273f74fef50e498"><td class="memSeparator" colspan="2">&#160;</td></tr>
 <tr class="memitem:ac0e74655baa4402209a21e1ae481c8f6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtjtransform.html#ac0e74655baa4402209a21e1ae481c8f6">options</a></td></tr>
-<tr class="memdesc:ac0e74655baa4402209a21e1ae481c8f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The bitwise OR of one of more of the <a class="el" href="group___turbo_j_p_e_g.html#ga9c771a757fc1294add611906b89ab2d2">transform options</a>.  <a href="structtjtransform.html#ac0e74655baa4402209a21e1ae481c8f6">More...</a><br /></td></tr>
+<tr class="memdesc:ac0e74655baa4402209a21e1ae481c8f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The bitwise OR of one of more of the <a class="el" href="group___turbo_j_p_e_g.html#ga153b468cfb905d0de61706c838986fe8">transform options</a>.  <a href="structtjtransform.html#ac0e74655baa4402209a21e1ae481c8f6">More...</a><br /></td></tr>
 <tr class="separator:ac0e74655baa4402209a21e1ae481c8f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
 <tr class="memitem:a688fe8f1a8ecc12a538d9e561cf338e3"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtjtransform.html#a688fe8f1a8ecc12a538d9e561cf338e3">data</a></td></tr>
 <tr class="memdesc:a688fe8f1a8ecc12a538d9e561cf338e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arbitrary data that can be accessed within the body of the callback function.  <a href="structtjtransform.html#a688fe8f1a8ecc12a538d9e561cf338e3">More...</a><br /></td></tr>
@@ -115,7 +115,7 @@ Data Fields</h2></td></tr>
     <tr><td class="paramname">coeffs</td><td>pointer to an array of transformed DCT coefficients. (NOTE: this pointer is not guaranteed to be valid once the callback returns, so applications wishing to hand off the DCT coefficients to another function or library should make a copy of them within the body of the callback.)</td></tr>
     <tr><td class="paramname">arrayRegion</td><td><a class="el" href="structtjregion.html" title="Cropping region.">tjregion</a> structure containing the width and height of the array pointed to by <code>coeffs</code> as well as its offset relative to the component plane. TurboJPEG implementations may choose to split each component plane into multiple DCT coefficient arrays and call the callback function once for each array.</td></tr>
     <tr><td class="paramname">planeRegion</td><td><a class="el" href="structtjregion.html" title="Cropping region.">tjregion</a> structure containing the width and height of the component plane to which <code>coeffs</code> belongs</td></tr>
-    <tr><td class="paramname">componentID</td><td>ID number of the component plane to which <code>coeffs</code> belongs (Y, Cb, and Cr have, respectively, ID's of 0, 1, and 2 in typical JPEG images.)</td></tr>
+    <tr><td class="paramname">componentID</td><td>ID number of the component plane to which <code>coeffs</code> belongs. (Y, Cb, and Cr have, respectively, ID's of 0, 1, and 2 in typical JPEG images.)</td></tr>
     <tr><td class="paramname">transformID</td><td>ID number of the transformed image to which <code>coeffs</code> belongs. This is the same as the index of the transform in the <code>transforms</code> array that was passed to <a class="el" href="group___turbo_j_p_e_g.html#ga9cb8abf4cc91881e04a0329b2270be25" title="Losslessly transform a JPEG image into another JPEG image.">tjTransform()</a>.</td></tr>
     <tr><td class="paramname">transform</td><td>a pointer to a <a class="el" href="structtjtransform.html" title="Lossless transform.">tjtransform</a> structure that specifies the parameters and/or cropping region for this transform</td></tr>
   </table>
@@ -169,7 +169,7 @@ Data Fields</h2></td></tr>
       </table>
 </div><div class="memdoc">
 
-<p>The bitwise OR of one of more of the <a class="el" href="group___turbo_j_p_e_g.html#ga9c771a757fc1294add611906b89ab2d2">transform options</a>. </p>
+<p>The bitwise OR of one of more of the <a class="el" href="group___turbo_j_p_e_g.html#ga153b468cfb905d0de61706c838986fe8">transform options</a>. </p>
 
 </div>
 </div>
diff --git a/java/TJBench.java b/java/TJBench.java
index 3a061d8..e95541d 100644
--- a/java/TJBench.java
+++ b/java/TJBench.java
@@ -1,6 +1,6 @@
 /*
- * Copyright (C)2009-2014, 2016-2019, 2021 D. R. Commander.
- *                                         All Rights Reserved.
+ * Copyright (C)2009-2014, 2016-2019, 2021, 2023 D. R. Commander.
+ *                                               All Rights Reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -37,7 +37,7 @@ final class TJBench {
 
   private TJBench() {}
 
-  private static int flags = 0, quiet = 0, pf = TJ.PF_BGR, yuvPad = 1;
+  private static int flags = 0, quiet = 0, pf = TJ.PF_BGR, yuvAlign = 1;
   private static boolean compOnly, decompOnly, doTile, doYUV, write = true;
 
   static final String[] PIXFORMATSTR = {
@@ -192,7 +192,7 @@ final class TJBench {
       int width = doTile ? tilew : scaledw;
       int height = doTile ? tileh : scaledh;
 
-      yuvImage = new YUVImage(width, yuvPad, height, subsamp);
+      yuvImage = new YUVImage(width, yuvAlign, height, subsamp);
       Arrays.fill(yuvImage.getBuf(), (byte)127);
     }
 
@@ -212,7 +212,8 @@ final class TJBench {
             tjd.setSourceImage(jpegBuf[tile], jpegSize[tile]);
           } catch (TJException e) { handleTJException(e); }
           if (doYUV) {
-            yuvImage.setBuf(yuvImage.getBuf(), width, yuvPad, height, subsamp);
+            yuvImage.setBuf(yuvImage.getBuf(), width, yuvAlign, height,
+                            subsamp);
             try {
               tjd.decompressToYUV(yuvImage, flags);
             } catch (TJException e) { handleTJException(e); }
@@ -372,7 +373,7 @@ final class TJBench {
       tjc.setSubsamp(subsamp);
 
       if (doYUV) {
-        yuvImage = new YUVImage(tilew, yuvPad, tileh, subsamp);
+        yuvImage = new YUVImage(tilew, yuvAlign, tileh, subsamp);
         Arrays.fill(yuvImage.getBuf(), (byte)127);
       }
 
@@ -393,7 +394,7 @@ final class TJBench {
             if (doYUV) {
               double startEncode = getTime();
 
-              yuvImage.setBuf(yuvImage.getBuf(), width, yuvPad, height,
+              yuvImage.setBuf(yuvImage.getBuf(), width, yuvAlign, height,
                               subsamp);
               tjc.encodeYUV(yuvImage, flags);
               if (iter >= 0)
@@ -524,7 +525,7 @@ final class TJBench {
 
     if (quiet == 1) {
       System.out.println("All performance values in Mpixels/sec\n");
-      System.out.format("Bitmap     JPEG   JPEG     %s  %s   Xform   Comp    Decomp  ",
+      System.out.format("Pixel      JPEG   JPEG     %s  %s   Xform   Comp    Decomp  ",
                         (doTile ? "Tile " : "Image"),
                         (doTile ? "Tile " : "Image"));
       if (doYUV)
@@ -695,34 +696,30 @@ final class TJBench {
     String className = new TJBench().getClass().getName();
 
     System.out.println("\nUSAGE: java " + className);
-    System.out.println("       <Inputfile (BMP)> <Quality> [options]\n");
+    System.out.println("       <Inputimage (BMP)> <Quality> [options]\n");
     System.out.println("       java " + className);
-    System.out.println("       <Inputfile (JPG)> [options]\n");
+    System.out.println("       <Inputimage (JPG)> [options]\n");
     System.out.println("Options:\n");
-    System.out.println("-alloc = Dynamically allocate JPEG image buffers");
-    System.out.println("-bottomup = Test bottom-up compression/decompression");
-    System.out.println("-tile = Test performance of the codec when the image is encoded as separate");
-    System.out.println("     tiles of varying sizes.");
+    System.out.println("-bottomup = Use bottom-up row order for packed-pixel source/destination buffers");
+    System.out.println("-tile = Compress/transform the input image into separate JPEG tiles of varying");
+    System.out.println("     sizes (useful for measuring JPEG overhead)");
     System.out.println("-rgb, -bgr, -rgbx, -bgrx, -xbgr, -xrgb =");
-    System.out.println("     Test the specified color conversion path in the codec (default = BGR)");
-    System.out.println("-fastupsample = Use the fastest chrominance upsampling algorithm available in");
-    System.out.println("     the underlying codec");
-    System.out.println("-fastdct = Use the fastest DCT/IDCT algorithms available in the underlying");
-    System.out.println("     codec");
-    System.out.println("-accuratedct = Use the most accurate DCT/IDCT algorithms available in the");
-    System.out.println("     underlying codec");
+    System.out.println("     Use the specified pixel format for packed-pixel source/destination buffers");
+    System.out.println("     [default = BGR]");
+    System.out.println("-fastupsample = Use the fastest chrominance upsampling algorithm available");
+    System.out.println("-fastdct = Use the fastest DCT/IDCT algorithm available");
+    System.out.println("-accuratedct = Use the most accurate DCT/IDCT algorithm available");
     System.out.println("-progressive = Use progressive entropy coding in JPEG images generated by");
-    System.out.println("     compression and transform operations.");
-    System.out.println("-subsamp <s> = When testing JPEG compression, this option specifies the level");
-    System.out.println("     of chrominance subsampling to use (<s> = 444, 422, 440, 420, 411, or");
-    System.out.println("     GRAY).  The default is to test Grayscale, 4:2:0, 4:2:2, and 4:4:4 in");
-    System.out.println("     sequence.");
+    System.out.println("     compression and transform operations");
+    System.out.println("-subsamp <s> = When compressing, use the specified level of chrominance");
+    System.out.println("     subsampling (<s> = 444, 422, 440, 420, 411, or GRAY) [default = test");
+    System.out.println("     Grayscale, 4:2:0, 4:2:2, and 4:4:4 in sequence]");
     System.out.println("-quiet = Output results in tabular rather than verbose format");
-    System.out.println("-yuv = Test YUV encoding/decoding functions");
-    System.out.println("-yuvpad <p> = If testing YUV encoding/decoding, this specifies the number of");
-    System.out.println("     bytes to which each row of each plane in the intermediate YUV image is");
-    System.out.println("     padded (default = 1)");
-    System.out.println("-scale M/N = Scale down the width/height of the decompressed JPEG image by a");
+    System.out.println("-yuv = Compress from/decompress to intermediate planar YUV images");
+    System.out.println("-yuvpad <p> = The number of bytes by which each row in each plane of an");
+    System.out.println("     intermediate YUV image is evenly divisible (must be a power of 2)");
+    System.out.println("     [default = 1]");
+    System.out.println("-scale M/N = When decompressing, scale the width/height of the JPEG image by a");
     System.out.print("     factor of M/N (M/N = ");
     for (i = 0; i < nsf; i++) {
       System.out.format("%d/%d", scalingFactors[i].getNum(),
@@ -740,24 +737,24 @@ final class TJBench {
     }
     System.out.println(")");
     System.out.println("-hflip, -vflip, -transpose, -transverse, -rot90, -rot180, -rot270 =");
-    System.out.println("     Perform the corresponding lossless transform prior to");
-    System.out.println("     decompression (these options are mutually exclusive)");
-    System.out.println("-grayscale = Perform lossless grayscale conversion prior to decompression");
-    System.out.println("     test (can be combined with the other transforms above)");
+    System.out.println("     Perform the specified lossless transform operation on the input image");
+    System.out.println("     prior to decompression (these operations are mutually exclusive)");
+    System.out.println("-grayscale = Transform the input image into a grayscale JPEG image prior to");
+    System.out.println("     decompression (can be combined with the other transform operations above)");
     System.out.println("-copynone = Do not copy any extra markers (including EXIF and ICC profile data)");
-    System.out.println("     when transforming the image.");
-    System.out.println("-benchtime <t> = Run each benchmark for at least <t> seconds (default = 5.0)");
-    System.out.println("-warmup <t> = Run each benchmark for <t> seconds (default = 1.0) prior to");
+    System.out.println("     when transforming the input image");
+    System.out.println("-benchtime <t> = Run each benchmark for at least <t> seconds [default = 5.0]");
+    System.out.println("-warmup <t> = Run each benchmark for <t> seconds [default = 1.0] prior to");
     System.out.println("     starting the timer, in order to prime the caches and thus improve the");
-    System.out.println("     consistency of the results.");
+    System.out.println("     consistency of the benchmark results");
     System.out.println("-componly = Stop after running compression tests.  Do not test decompression.");
-    System.out.println("-nowrite = Do not write reference or output images (improves consistency");
-    System.out.println("     of performance measurements.)");
+    System.out.println("-nowrite = Do not write reference or output images (improves consistency of");
+    System.out.println("     benchmark results)");
     System.out.println("-limitscans = Refuse to decompress or transform progressive JPEG images that");
     System.out.println("     have an unreasonably large number of scans");
     System.out.println("-stoponwarning = Immediately discontinue the current");
-    System.out.println("     compression/decompression/transform operation if the underlying codec");
-    System.out.println("     throws a warning (non-fatal error)\n");
+    System.out.println("     compression/decompression/transform operation if a warning (non-fatal");
+    System.out.println("     error) occurs\n");
     System.out.println("NOTE:  If the quality is specified as a range (e.g. 90-100), a separate");
     System.out.println("test will be performed for all quality values in the range.\n");
     System.exit(1);
@@ -785,18 +782,18 @@ final class TJBench {
         minArg = 2;
         if (argv.length < minArg)
           usage();
+        String[] quals = argv[1].split("-", 2);
         try {
-          minQual = Integer.parseInt(argv[1]);
+          minQual = Integer.parseInt(quals[0]);
         } catch (NumberFormatException e) {}
         if (minQual < 1 || minQual > 100)
           throw new Exception("Quality must be between 1 and 100.");
-        int dashIndex = argv[1].indexOf('-');
-        if (dashIndex > 0 && argv[1].length() > dashIndex + 1) {
+        if (quals.length > 1) {
           try {
-            maxQual = Integer.parseInt(argv[1].substring(dashIndex + 1));
+            maxQual = Integer.parseInt(quals[1]);
           } catch (NumberFormatException e) {}
         }
-        if (maxQual < 1 || maxQual > 100)
+        if (maxQual < 1 || maxQual > 100 || maxQual < minQual)
           maxQual = minQual;
       }
 
@@ -805,7 +802,7 @@ final class TJBench {
           if (argv[i].equalsIgnoreCase("-tile")) {
             doTile = true;  xformOpt |= TJTransform.OPT_CROP;
           } else if (argv[i].equalsIgnoreCase("-fastupsample")) {
-            System.out.println("Using fast upsampling code\n");
+            System.out.println("Using fastest upsampling algorithm\n");
             flags |= TJ.FLAG_FASTUPSAMPLE;
           } else if (argv[i].equalsIgnoreCase("-fastdct")) {
             System.out.println("Using fastest DCT/IDCT algorithm\n");
@@ -816,6 +813,7 @@ final class TJBench {
           } else if (argv[i].equalsIgnoreCase("-progressive")) {
             System.out.println("Using progressive entropy coding\n");
             flags |= TJ.FLAG_PROGRESSIVE;
+            xformOpt |= TJTransform.OPT_PROGRESSIVE;
           } else if (argv[i].equalsIgnoreCase("-rgb"))
             pf = TJ.PF_RGB;
           else if (argv[i].equalsIgnoreCase("-rgbx"))
@@ -902,7 +900,7 @@ final class TJBench {
             } else
               usage();
           } else if (argv[i].equalsIgnoreCase("-yuv")) {
-            System.out.println("Testing YUV planar encoding/decoding\n");
+            System.out.println("Testing planar YUV encoding/decoding\n");
             doYUV = true;
           } else if (argv[i].equalsIgnoreCase("-yuvpad") &&
                      i < argv.length - 1) {
@@ -911,8 +909,10 @@ final class TJBench {
             try {
               temp = Integer.parseInt(argv[++i]);
             } catch (NumberFormatException e) {}
-            if (temp >= 1)
-              yuvPad = temp;
+            if (temp >= 1 && (temp & (temp - 1)) == 0)
+              yuvAlign = temp;
+            else
+              usage();
           } else if (argv[i].equalsIgnoreCase("-subsamp") &&
                      i < argv.length - 1) {
             i++;
@@ -928,6 +928,8 @@ final class TJBench {
               subsamp = TJ.SAMP_420;
             else if (argv[i].equals("411"))
               subsamp = TJ.SAMP_411;
+            else
+              usage();
           } else if (argv[i].equalsIgnoreCase("-componly"))
             compOnly = true;
           else if (argv[i].equalsIgnoreCase("-nowrite"))
@@ -945,8 +947,9 @@ final class TJBench {
 
       if ((sf.getNum() != 1 || sf.getDenom() != 1) && doTile) {
         System.out.println("Disabling tiled compression/decompression tests, because those tests do not");
-        System.out.println("work when scaled decompression is enabled.");
+        System.out.println("work when scaled decompression is enabled.\n");
         doTile = false;
+        xformOpt &= (~TJTransform.OPT_CROP);
       }
 
       if (!decompOnly) {
@@ -961,7 +964,7 @@ final class TJBench {
 
       if (quiet == 1 && !decompOnly) {
         System.out.println("All performance values in Mpixels/sec\n");
-        System.out.format("Bitmap     JPEG     JPEG  %s  %s   ",
+        System.out.format("Pixel      JPEG     JPEG  %s  %s   ",
                           (doTile ? "Tile " : "Image"),
                           (doTile ? "Tile " : "Image"));
         if (doYUV)
diff --git a/java/TJExample.java b/java/TJExample.java
index 7859886..5ff1c52 100644
--- a/java/TJExample.java
+++ b/java/TJExample.java
@@ -1,6 +1,6 @@
 /*
- * Copyright (C)2011-2012, 2014-2015, 2017-2018 D. R. Commander.
- *                                              All Rights Reserved.
+ * Copyright (C)2011-2012, 2014-2015, 2017-2018, 2023 D. R. Commander.
+ *                                                    All Rights Reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -136,14 +136,11 @@ class TJExample implements TJCustomFilter {
     System.out.println("-display = Display output image (Output filename need not be specified in this");
     System.out.println("     case.)\n");
 
-    System.out.println("-fastupsample = Use the fastest chrominance upsampling algorithm available in");
-    System.out.println("     the underlying codec.\n");
+    System.out.println("-fastupsample = Use the fastest chrominance upsampling algorithm available\n");
 
-    System.out.println("-fastdct = Use the fastest DCT/IDCT algorithms available in the underlying");
-    System.out.println("     codec.\n");
+    System.out.println("-fastdct = Use the fastest DCT/IDCT algorithm available\n");
 
-    System.out.println("-accuratedct = Use the most accurate DCT/IDCT algorithms available in the");
-    System.out.println("     underlying codec.\n");
+    System.out.println("-accuratedct = Use the most accurate DCT/IDCT algorithm available\n");
 
     System.exit(1);
   }
diff --git a/java/TJUnitTest.java b/java/TJUnitTest.java
index 91ad5fd..20de6df 100644
--- a/java/TJUnitTest.java
+++ b/java/TJUnitTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C)2011-2018 D. R. Commander.  All Rights Reserved.
+ * Copyright (C)2011-2018, 2023 D. R. Commander.  All Rights Reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -48,10 +48,10 @@ final class TJUnitTest {
   static void usage() {
     System.out.println("\nUSAGE: java " + CLASS_NAME + " [options]\n");
     System.out.println("Options:");
-    System.out.println("-yuv = test YUV encoding/decoding support");
-    System.out.println("-noyuvpad = do not pad each line of each Y, U, and V plane to the nearest");
-    System.out.println("            4-byte boundary");
-    System.out.println("-bi = test BufferedImage support\n");
+    System.out.println("-yuv = test YUV encoding/compression/decompression/decoding");
+    System.out.println("-noyuvpad = do not pad each row in each Y, U, and V plane to the nearest");
+    System.out.println("            multiple of 4 bytes");
+    System.out.println("-bi = test BufferedImage I/O\n");
     System.exit(1);
   }
 
@@ -92,7 +92,7 @@ final class TJUnitTest {
   };
 
   private static boolean doYUV = false;
-  private static int pad = 4;
+  private static int yuvAlign = 4;
   private static boolean bi = false;
 
   private static int exitStatus = 0;
@@ -532,7 +532,7 @@ final class TJUnitTest {
     int hsf = TJ.getMCUWidth(subsamp) / 8, vsf = TJ.getMCUHeight(subsamp) / 8;
     int pw = pad(w, hsf), ph = pad(h, vsf);
     int cw = pw / hsf, ch = ph / vsf;
-    int ypitch = pad(pw, pad), uvpitch = pad(cw, pad);
+    int ypitch = pad(pw, yuvAlign), uvpitch = pad(cw, yuvAlign);
     int retval = 1;
     int correctsize = ypitch * ph +
                       (subsamp == TJ.SAMP_GRAY ? 0 : uvpitch * ch * 2);
@@ -668,7 +668,7 @@ final class TJUnitTest {
     if (doYUV) {
       System.out.format("%s %s -> YUV %s ... ", pfStrLong, buStrLong,
                         SUBNAME_LONG[subsamp]);
-      YUVImage yuvImage = tjc.encodeYUV(pad, flags);
+      YUVImage yuvImage = tjc.encodeYUV(yuvAlign, flags);
       if (checkBufYUV(yuvImage.getBuf(), yuvImage.getSize(), w, h, subsamp,
                       new TJScalingFactor(1, 1)) == 1)
         System.out.print("Passed.\n");
@@ -733,8 +733,8 @@ final class TJUnitTest {
       if (!sf.isOne())
         System.out.format("%d/%d ... ", sf.getNum(), sf.getDenom());
       else System.out.print("... ");
-      YUVImage yuvImage = tjd.decompressToYUV(scaledWidth, pad, scaledHeight,
-                                              flags);
+      YUVImage yuvImage = tjd.decompressToYUV(scaledWidth, yuvAlign,
+                                              scaledHeight, flags);
       if (checkBufYUV(yuvImage.getBuf(), yuvImage.getSize(), scaledWidth,
                       scaledHeight, subsamp, sf) == 1)
         System.out.print("Passed.\n");
@@ -837,6 +837,55 @@ final class TJUnitTest {
     if (tjd != null) tjd.close();
   }
 
+  static void overflowTest() throws Exception {
+    /* Ensure that the various buffer size methods don't overflow */
+    int size = 0;
+    boolean exception = false;
+
+    try {
+      exception = false;
+      size = TJ.bufSize(18919, 18919, TJ.SAMP_444);
+    } catch (Exception e) { exception = true; }
+    if (!exception || size != 0)
+      throw new Exception("TJ.bufSize() overflow");
+    try {
+      exception = false;
+      size = TJ.bufSizeYUV(26755, 1, 26755, TJ.SAMP_444);
+    } catch (Exception e) { exception = true; }
+    if (!exception || size != 0)
+      throw new Exception("TJ.bufSizeYUV() overflow");
+    try {
+      exception = false;
+      size = TJ.bufSizeYUV(26754, 3, 26754, TJ.SAMP_444);
+    } catch (Exception e) { exception = true; }
+    if (!exception || size != 0)
+      throw new Exception("TJ.bufSizeYUV() overflow");
+    try {
+      exception = false;
+      size = TJ.bufSizeYUV(26754, -1, 26754, TJ.SAMP_444);
+    } catch (Exception e) { exception = true; }
+    if (!exception || size != 0)
+      throw new Exception("TJ.bufSizeYUV() overflow");
+    try {
+      exception = false;
+      size = TJ.planeSizeYUV(0, 46341, 0, 46341, TJ.SAMP_444);
+    } catch (Exception e) { exception = true; }
+    if (!exception || size != 0)
+      throw new Exception("TJ.planeSizeYUV() overflow");
+    try {
+      exception = false;
+      size = TJ.planeWidth(0, Integer.MAX_VALUE, TJ.SAMP_420);
+    } catch (Exception e) { exception = true; }
+    if (!exception || size != 0)
+      throw new Exception("TJ.planeWidth() overflow");
+    try {
+      exception = false;
+      size = TJ.planeHeight(0, Integer.MAX_VALUE, TJ.SAMP_420);
+    } catch (Exception e) { exception = true; }
+    if (!exception || size != 0)
+      throw new Exception("TJ.planeHeight() overflow");
+  }
+
   static void bufSizeTest() throws Exception {
     int w, h, i, subsamp;
     byte[] srcBuf, dstBuf = null;
@@ -855,7 +904,7 @@ final class TJUnitTest {
               System.out.format("%04d x %04d\b\b\b\b\b\b\b\b\b\b\b", w, h);
             srcBuf = new byte[w * h * 4];
             if (doYUV)
-              dstImage = new YUVImage(w, pad, h, subsamp);
+              dstImage = new YUVImage(w, yuvAlign, h, subsamp);
             else
               dstBuf = new byte[TJ.bufSize(w, h, subsamp)];
             for (i = 0; i < w * h * 4; i++) {
@@ -871,7 +920,7 @@ final class TJUnitTest {
 
             srcBuf = new byte[h * w * 4];
             if (doYUV)
-              dstImage = new YUVImage(h, pad, w, subsamp);
+              dstImage = new YUVImage(h, yuvAlign, w, subsamp);
             else
               dstBuf = new byte[TJ.bufSize(h, w, subsamp)];
             for (i = 0; i < h * w * 4; i++) {
@@ -903,7 +952,7 @@ final class TJUnitTest {
         if (argv[i].equalsIgnoreCase("-yuv"))
           doYUV = true;
         else if (argv[i].equalsIgnoreCase("-noyuvpad"))
-          pad = 1;
+          yuvAlign = 1;
         else if (argv[i].equalsIgnoreCase("-bi")) {
           bi = true;
           testName = "javabitest";
@@ -912,6 +961,7 @@ final class TJUnitTest {
       }
       if (doYUV)
         FORMATS_4BYTE[4] = -1;
+      overflowTest();
       doTest(35, 39, bi ? FORMATS_3BYTEBI : FORMATS_3BYTE, TJ.SAMP_444,
              testName);
       doTest(39, 41, bi ? FORMATS_4BYTEBI : FORMATS_4BYTE, TJ.SAMP_444,
diff --git a/java/doc/index-all.html b/java/doc/index-all.html
index 5def53e..0224536 100644
--- a/java/doc/index-all.html
+++ b/java/doc/index-all.html
@@ -74,8 +74,9 @@
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJ.html#bufSizeYUV(int,%20int,%20int,%20int)">bufSizeYUV(int, int, int, int)</a></span> - Static method in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJ.html" title="class in org.libjpegturbo.turbojpeg">TJ</a></dt>
 <dd>
-<div class="block">Returns the size of the buffer (in bytes) required to hold a YUV planar
- image with the given width, height, and level of chrominance subsampling.</div>
+<div class="block">Returns the size of the buffer (in bytes) required to hold a unified
+ planar YUV image with the given width, height, and level of chrominance
+ subsampling.</div>
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJ.html#bufSizeYUV(int,%20int,%20int)">bufSizeYUV(int, int, int)</a></span> - Static method in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJ.html" title="class in org.libjpegturbo.turbojpeg">TJ</a></dt>
 <dd>
@@ -103,13 +104,14 @@
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJCompressor.html#compress(byte[],%20int)">compress(byte[], int)</a></span> - Method in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJCompressor.html" title="class in org.libjpegturbo.turbojpeg">TJCompressor</a></dt>
 <dd>
-<div class="block">Compress the uncompressed source image associated with this compressor
- instance and output a JPEG image to the given destination buffer.</div>
+<div class="block">Compress the packed-pixel or planar YUV source image associated with this
+ compressor instance and output a JPEG image to the given destination
+ buffer.</div>
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJCompressor.html#compress(int)">compress(int)</a></span> - Method in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJCompressor.html" title="class in org.libjpegturbo.turbojpeg">TJCompressor</a></dt>
 <dd>
-<div class="block">Compress the uncompressed source image associated with this compressor
- instance and return a buffer containing a JPEG image.</div>
+<div class="block">Compress the packed-pixel or planar YUV source image associated with this
+ compressor instance and return a buffer containing a JPEG image.</div>
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJCompressor.html#compress(java.awt.image.BufferedImage,%20byte[],%20int)">compress(BufferedImage, byte[], int)</a></span> - Method in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJCompressor.html" title="class in org.libjpegturbo.turbojpeg">TJCompressor</a></dt>
 <dd>
@@ -161,9 +163,9 @@
 <dl>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJDecompressor.html#decompress(byte[],%20int,%20int,%20int,%20int,%20int,%20int,%20int)">decompress(byte[], int, int, int, int, int, int, int)</a></span> - Method in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJDecompressor.html" title="class in org.libjpegturbo.turbojpeg">TJDecompressor</a></dt>
 <dd>
-<div class="block">Decompress the JPEG source image or decode the YUV source image associated
- with this decompressor instance and output a grayscale, RGB, or CMYK image
- to the given destination buffer.</div>
+<div class="block">Decompress the JPEG source image or decode the planar YUV source image
+ associated with this decompressor instance and output a packed-pixel
+ grayscale, RGB, or CMYK image to the given destination buffer.</div>
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJDecompressor.html#decompress(byte[],%20int,%20int,%20int,%20int,%20int)">decompress(byte[], int, int, int, int, int)</a></span> - Method in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJDecompressor.html" title="class in org.libjpegturbo.turbojpeg">TJDecompressor</a></dt>
 <dd>
@@ -174,32 +176,35 @@
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJDecompressor.html#decompress(int,%20int,%20int,%20int,%20int)">decompress(int, int, int, int, int)</a></span> - Method in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJDecompressor.html" title="class in org.libjpegturbo.turbojpeg">TJDecompressor</a></dt>
 <dd>
-<div class="block">Decompress the JPEG source image associated with this decompressor
- instance and return a buffer containing the decompressed image.</div>
+<div class="block">Decompress the JPEG source image or decode the planar YUV source image
+ associated with this decompressor instance and return a buffer containing
+ the packed-pixel decompressed image.</div>
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJDecompressor.html#decompress(int[],%20int,%20int,%20int,%20int,%20int,%20int,%20int)">decompress(int[], int, int, int, int, int, int, int)</a></span> - Method in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJDecompressor.html" title="class in org.libjpegturbo.turbojpeg">TJDecompressor</a></dt>
 <dd>
-<div class="block">Decompress the JPEG source image or decode the YUV source image associated
- with this decompressor instance and output a grayscale, RGB, or CMYK image
- to the given destination buffer.</div>
+<div class="block">Decompress the JPEG source image or decode the planar YUV source image
+ associated with this decompressor instance and output a packed-pixel
+ grayscale, RGB, or CMYK image to the given destination buffer.</div>
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJDecompressor.html#decompress(java.awt.image.BufferedImage,%20int)">decompress(BufferedImage, int)</a></span> - Method in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJDecompressor.html" title="class in org.libjpegturbo.turbojpeg">TJDecompressor</a></dt>
 <dd>
-<div class="block">Decompress the JPEG source image or decode the YUV source image associated
- with this decompressor instance and output a decompressed/decoded image to
- the given <code>BufferedImage</code> instance.</div>
+<div class="block">Decompress the JPEG source image or decode the planar YUV source image
+ associated with this decompressor instance and output a packed-pixel
+ decompressed/decoded image to the given <code>BufferedImage</code>
+ instance.</div>
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJDecompressor.html#decompress(int,%20int,%20int,%20int)">decompress(int, int, int, int)</a></span> - Method in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJDecompressor.html" title="class in org.libjpegturbo.turbojpeg">TJDecompressor</a></dt>
 <dd>
-<div class="block">Decompress the JPEG source image or decode the YUV source image associated
- with this decompressor instance and return a <code>BufferedImage</code>
- instance containing the decompressed/decoded image.</div>
+<div class="block">Decompress the JPEG source image or decode the planar YUV source image
+ associated with this decompressor instance and return a
+ <code>BufferedImage</code> instance containing the packed-pixel
+ decompressed/decoded image.</div>
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJDecompressor.html#decompressToYUV(org.libjpegturbo.turbojpeg.YUVImage,%20int)">decompressToYUV(YUVImage, int)</a></span> - Method in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJDecompressor.html" title="class in org.libjpegturbo.turbojpeg">TJDecompressor</a></dt>
 <dd>
 <div class="block">Decompress the JPEG source image associated with this decompressor
- instance into a YUV planar image and store it in the given
- <code>YUVImage</code> instance.</div>
+ instance into a planar YUV image and store it in the given
+ <a href="./org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg"><code>YUVImage</code></a> instance.</div>
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJDecompressor.html#decompressToYUV(byte[],%20int)">decompressToYUV(byte[], int)</a></span> - Method in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJDecompressor.html" title="class in org.libjpegturbo.turbojpeg">TJDecompressor</a></dt>
 <dd>
@@ -211,13 +216,13 @@
 <dd>
 <div class="block">Decompress the JPEG source image associated with this decompressor
  instance into a set of Y, U (Cb), and V (Cr) image planes and return a
- <code>YUVImage</code> instance containing the decompressed image planes.</div>
+ <a href="./org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg"><code>YUVImage</code></a> instance containing the decompressed image planes.</div>
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJDecompressor.html#decompressToYUV(int,%20int,%20int,%20int)">decompressToYUV(int, int, int, int)</a></span> - Method in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJDecompressor.html" title="class in org.libjpegturbo.turbojpeg">TJDecompressor</a></dt>
 <dd>
 <div class="block">Decompress the JPEG source image associated with this decompressor
- instance into a unified YUV planar image buffer and return a
- <code>YUVImage</code> instance containing the decompressed image.</div>
+ instance into a unified planar YUV image and return a <a href="./org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg"><code>YUVImage</code></a>
+ instance containing the decompressed image.</div>
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJDecompressor.html#decompressToYUV(int)">decompressToYUV(int)</a></span> - Method in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJDecompressor.html" title="class in org.libjpegturbo.turbojpeg">TJDecompressor</a></dt>
 <dd>
@@ -233,9 +238,9 @@
 <dl>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJCompressor.html#encodeYUV(org.libjpegturbo.turbojpeg.YUVImage,%20int)">encodeYUV(YUVImage, int)</a></span> - Method in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJCompressor.html" title="class in org.libjpegturbo.turbojpeg">TJCompressor</a></dt>
 <dd>
-<div class="block">Encode the uncompressed source image associated with this compressor
- instance into a YUV planar image and store it in the given
- <code>YUVImage</code> instance.</div>
+<div class="block">Encode the packed-pixel source image associated with this compressor
+ instance into a planar YUV image and store it in the given
+ <a href="./org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg"><code>YUVImage</code></a> instance.</div>
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJCompressor.html#encodeYUV(byte[],%20int)">encodeYUV(byte[], int)</a></span> - Method in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJCompressor.html" title="class in org.libjpegturbo.turbojpeg">TJCompressor</a></dt>
 <dd>
@@ -245,15 +250,15 @@
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJCompressor.html#encodeYUV(int,%20int)">encodeYUV(int, int)</a></span> - Method in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJCompressor.html" title="class in org.libjpegturbo.turbojpeg">TJCompressor</a></dt>
 <dd>
-<div class="block">Encode the uncompressed source image associated with this compressor
- instance into a unified YUV planar image buffer and return a
- <code>YUVImage</code> instance containing the encoded image.</div>
+<div class="block">Encode the packed-pixel source image associated with this compressor
+ instance into a unified planar YUV image and return a <a href="./org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg"><code>YUVImage</code></a>
+ instance containing the encoded image.</div>
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJCompressor.html#encodeYUV(int[],%20int)">encodeYUV(int[], int)</a></span> - Method in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJCompressor.html" title="class in org.libjpegturbo.turbojpeg">TJCompressor</a></dt>
 <dd>
-<div class="block">Encode the uncompressed source image associated with this compressor
+<div class="block">Encode the packed-pixel source image associated with this compressor
  instance into separate Y, U (Cb), and V (Cr) image planes and return a
- <code>YUVImage</code> instance containing the encoded image planes.</div>
+ <a href="./org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg"><code>YUVImage</code></a> instance containing the encoded image planes.</div>
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJCompressor.html#encodeYUV(int)">encodeYUV(int)</a></span> - Method in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJCompressor.html" title="class in org.libjpegturbo.turbojpeg">TJCompressor</a></dt>
 <dd>
@@ -288,8 +293,8 @@
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJ.html#ERR_WARNING">ERR_WARNING</a></span> - Static variable in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJ.html" title="class in org.libjpegturbo.turbojpeg">TJ</a></dt>
 <dd>
-<div class="block">The error was non-fatal and recoverable, but the image may still be
- corrupt.</div>
+<div class="block">The error was non-fatal and recoverable, but the destination image may
+ still be corrupt.</div>
 </dd>
 </dl>
 <a name="_F_">
@@ -303,23 +308,21 @@
 <dd>&nbsp;</dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJ.html#FLAG_ACCURATEDCT">FLAG_ACCURATEDCT</a></span> - Static variable in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJ.html" title="class in org.libjpegturbo.turbojpeg">TJ</a></dt>
 <dd>
-<div class="block">Use the most accurate DCT/IDCT algorithm available in the underlying
- codec.</div>
+<div class="block">Use the most accurate DCT/IDCT algorithm available.</div>
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJ.html#FLAG_BOTTOMUP">FLAG_BOTTOMUP</a></span> - Static variable in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJ.html" title="class in org.libjpegturbo.turbojpeg">TJ</a></dt>
 <dd>
-<div class="block">The uncompressed source/destination image is stored in bottom-up (Windows,
- OpenGL) order, not top-down (X11) order.</div>
+<div class="block">Rows in the packed-pixel source/destination image are stored in bottom-up
+ (Windows, OpenGL) order rather than in top-down (X11) order.</div>
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJ.html#FLAG_FASTDCT">FLAG_FASTDCT</a></span> - Static variable in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJ.html" title="class in org.libjpegturbo.turbojpeg">TJ</a></dt>
 <dd>
-<div class="block">Use the fastest DCT/IDCT algorithm available in the underlying codec.</div>
+<div class="block">Use the fastest DCT/IDCT algorithm available.</div>
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJ.html#FLAG_FASTUPSAMPLE">FLAG_FASTUPSAMPLE</a></span> - Static variable in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJ.html" title="class in org.libjpegturbo.turbojpeg">TJ</a></dt>
 <dd>
 <div class="block">When decompressing an image that was compressed using chrominance
- subsampling, use the fastest chrominance upsampling algorithm available in
- the underlying codec.</div>
+ subsampling, use the fastest chrominance upsampling algorithm available.</div>
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJ.html#FLAG_FORCEMMX">FLAG_FORCEMMX</a></span> - Static variable in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJ.html" title="class in org.libjpegturbo.turbojpeg">TJ</a></dt>
 <dd>
@@ -350,7 +353,7 @@
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJ.html#FLAG_STOPONWARNING">FLAG_STOPONWARNING</a></span> - Static variable in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJ.html" title="class in org.libjpegturbo.turbojpeg">TJ</a></dt>
 <dd>
 <div class="block">Immediately discontinue the current compression/decompression/transform
- operation if the underlying codec throws a warning (non-fatal error).</div>
+ operation if a warning (non-fatal error) occurs.</div>
 </dd>
 </dl>
 <a name="_G_">
@@ -370,8 +373,8 @@
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/YUVImage.html#getBuf()">getBuf()</a></span> - Method in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg">YUVImage</a></dt>
 <dd>
-<div class="block">Returns the YUV image buffer (if this image is stored in a unified
- buffer rather than separate image planes.)</div>
+<div class="block">Returns the YUV buffer (if this image is stored in a unified buffer rather
+ than separate image planes.)</div>
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJDecompressor.html#getColorspace()">getColorspace()</a></span> - Method in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJDecompressor.html" title="class in org.libjpegturbo.turbojpeg">TJDecompressor</a></dt>
 <dd>
@@ -408,7 +411,7 @@
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJDecompressor.html#getJPEGBuf()">getJPEGBuf()</a></span> - Method in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJDecompressor.html" title="class in org.libjpegturbo.turbojpeg">TJDecompressor</a></dt>
 <dd>
-<div class="block">Returns the JPEG image buffer associated with this decompressor instance.</div>
+<div class="block">Returns the JPEG buffer associated with this decompressor instance.</div>
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJDecompressor.html#getJPEGSize()">getJPEGSize()</a></span> - Method in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJDecompressor.html" title="class in org.libjpegturbo.turbojpeg">TJDecompressor</a></dt>
 <dd>
@@ -436,7 +439,7 @@
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/YUVImage.html#getPad()">getPad()</a></span> - Method in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg">YUVImage</a></dt>
 <dd>
-<div class="block">Returns the line padding used in the YUV image buffer (if this image is
+<div class="block">Returns the row alignment (in bytes) of the YUV buffer (if this image is
  stored in a unified buffer rather than separate image planes.)</div>
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJ.html#getPixelSize(int)">getPixelSize(int)</a></span> - Static method in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJ.html" title="class in org.libjpegturbo.turbojpeg">TJ</a></dt>
@@ -470,17 +473,17 @@
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJ.html#getScalingFactors()">getScalingFactors()</a></span> - Static method in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJ.html" title="class in org.libjpegturbo.turbojpeg">TJ</a></dt>
 <dd>
-<div class="block">Returns a list of fractional scaling factors that the JPEG decompressor in
- this implementation of TurboJPEG supports.</div>
+<div class="block">Returns a list of fractional scaling factors that the JPEG decompressor
+ supports.</div>
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/YUVImage.html#getSize()">getSize()</a></span> - Method in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg">YUVImage</a></dt>
 <dd>
-<div class="block">Returns the size (in bytes) of the YUV image buffer (if this image is
- stored in a unified buffer rather than separate image planes.)</div>
+<div class="block">Returns the size (in bytes) of the YUV buffer (if this image is stored in
+ a unified buffer rather than separate image planes.)</div>
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/YUVImage.html#getStrides()">getStrides()</a></span> - Method in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg">YUVImage</a></dt>
 <dd>
-<div class="block">Returns the number of bytes per line of each plane in the YUV image.</div>
+<div class="block">Returns the number of bytes per row of each plane in the YUV image.</div>
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJDecompressor.html#getSubsamp()">getSubsamp()</a></span> - Method in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJDecompressor.html" title="class in org.libjpegturbo.turbojpeg">TJDecompressor</a></dt>
 <dd>
@@ -494,7 +497,7 @@
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJTransformer.html#getTransformedSizes()">getTransformedSizes()</a></span> - Method in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJTransformer.html" title="class in org.libjpegturbo.turbojpeg">TJTransformer</a></dt>
 <dd>
 <div class="block">Returns an array containing the sizes of the transformed JPEG images
- generated by the most recent transform operation.</div>
+ (in bytes) generated by the most recent transform operation.</div>
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJDecompressor.html#getWidth()">getWidth()</a></span> - Method in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJDecompressor.html" title="class in org.libjpegturbo.turbojpeg">TJDecompressor</a></dt>
 <dd>
@@ -578,7 +581,7 @@
 <dl>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJTransform.html#op">op</a></span> - Variable in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJTransform.html" title="class in org.libjpegturbo.turbojpeg">TJTransform</a></dt>
 <dd>
-<div class="block">Transform operation (one of <code>OP_*</code>)</div>
+<div class="block">Transform operation (one of <a href="./org/libjpegturbo/turbojpeg/TJTransform.html#OP_NONE"><code>OP_*</code></a>)</div>
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJTransform.html#OP_HFLIP">OP_HFLIP</a></span> - Static variable in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJTransform.html" title="class in org.libjpegturbo.turbojpeg">TJTransform</a></dt>
 <dd>
@@ -616,7 +619,7 @@
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJTransform.html#OPT_COPYNONE">OPT_COPYNONE</a></span> - Static variable in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJTransform.html" title="class in org.libjpegturbo.turbojpeg">TJTransform</a></dt>
 <dd>
 <div class="block">This option will prevent <a href="./org/libjpegturbo/turbojpeg/TJTransformer.html#transform(byte[][],%20org.libjpegturbo.turbojpeg.TJTransform[],%20int)"><code>TJTransformer.transform()</code></a> from copying any extra markers (including EXIF
- and ICC profile data) from the source image to the output image.</div>
+ and ICC profile data) from the source image to the destination image.</div>
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJTransform.html#OPT_CROP">OPT_CROP</a></span> - Static variable in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJTransform.html" title="class in org.libjpegturbo.turbojpeg">TJTransform</a></dt>
 <dd>
@@ -624,8 +627,8 @@
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJTransform.html#OPT_GRAY">OPT_GRAY</a></span> - Static variable in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJTransform.html" title="class in org.libjpegturbo.turbojpeg">TJTransform</a></dt>
 <dd>
-<div class="block">This option will discard the color data in the input image and produce
- a grayscale output image.</div>
+<div class="block">This option will discard the color data in the source image and produce a
+ grayscale destination image.</div>
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJTransform.html#OPT_NOOUTPUT">OPT_NOOUTPUT</a></span> - Static variable in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJTransform.html" title="class in org.libjpegturbo.turbojpeg">TJTransform</a></dt>
 <dd>
@@ -639,7 +642,7 @@
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJTransform.html#OPT_PROGRESSIVE">OPT_PROGRESSIVE</a></span> - Static variable in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJTransform.html" title="class in org.libjpegturbo.turbojpeg">TJTransform</a></dt>
 <dd>
-<div class="block">This option will enable progressive entropy coding in the output image
+<div class="block">This option will enable progressive entropy coding in the JPEG image
  generated by this particular transform.</div>
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJTransform.html#OPT_TRIM">OPT_TRIM</a></span> - Static variable in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJTransform.html" title="class in org.libjpegturbo.turbojpeg">TJTransform</a></dt>
@@ -649,7 +652,8 @@
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJTransform.html#options">options</a></span> - Variable in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJTransform.html" title="class in org.libjpegturbo.turbojpeg">TJTransform</a></dt>
 <dd>
-<div class="block">Transform options (bitwise OR of one or more of <code>OPT_*</code>)</div>
+<div class="block">Transform options (bitwise OR of one or more of
+ <a href="./org/libjpegturbo/turbojpeg/TJTransform.html#OPT_PERFECT"><code>OPT_*</code></a>)</div>
 </dd>
 <dt><a href="./org/libjpegturbo/turbojpeg/package-summary.html">org.libjpegturbo.turbojpeg</a> - package org.libjpegturbo.turbojpeg</dt>
 <dd>&nbsp;</dd>
@@ -756,7 +760,7 @@
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/YUVImage.html#setBuf(byte[],%20int,%20int,%20int,%20int)">setBuf(byte[], int, int, int, int)</a></span> - Method in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg">YUVImage</a></dt>
 <dd>
-<div class="block">Assign a unified image buffer to this <code>YUVImage</code> instance.</div>
+<div class="block">Assign a unified buffer to this <code>YUVImage</code> instance.</div>
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJDecompressor.html#setJPEGImage(byte[],%20int)">setJPEGImage(byte[], int)</a></span> - Method in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJDecompressor.html" title="class in org.libjpegturbo.turbojpeg">TJDecompressor</a></dt>
 <dd>
@@ -770,7 +774,7 @@
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJCompressor.html#setSourceImage(byte[],%20int,%20int,%20int,%20int,%20int,%20int)">setSourceImage(byte[], int, int, int, int, int, int)</a></span> - Method in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJCompressor.html" title="class in org.libjpegturbo.turbojpeg">TJCompressor</a></dt>
 <dd>
-<div class="block">Associate an uncompressed RGB, grayscale, or CMYK source image with this
+<div class="block">Associate a packed-pixel RGB, grayscale, or CMYK source image with this
  compressor instance.</div>
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJCompressor.html#setSourceImage(byte[],%20int,%20int,%20int,%20int)">setSourceImage(byte[], int, int, int, int)</a></span> - Method in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJCompressor.html" title="class in org.libjpegturbo.turbojpeg">TJCompressor</a></dt>
@@ -782,13 +786,12 @@
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJCompressor.html#setSourceImage(java.awt.image.BufferedImage,%20int,%20int,%20int,%20int)">setSourceImage(BufferedImage, int, int, int, int)</a></span> - Method in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJCompressor.html" title="class in org.libjpegturbo.turbojpeg">TJCompressor</a></dt>
 <dd>
-<div class="block">Associate an uncompressed RGB or grayscale source image with this
+<div class="block">Associate a packed-pixel RGB or grayscale source image with this
  compressor instance.</div>
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJCompressor.html#setSourceImage(org.libjpegturbo.turbojpeg.YUVImage)">setSourceImage(YUVImage)</a></span> - Method in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJCompressor.html" title="class in org.libjpegturbo.turbojpeg">TJCompressor</a></dt>
 <dd>
-<div class="block">Associate an uncompressed YUV planar source image with this compressor
- instance.</div>
+<div class="block">Associate a planar YUV source image with this compressor instance.</div>
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJDecompressor.html#setSourceImage(byte[],%20int)">setSourceImage(byte[], int)</a></span> - Method in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJDecompressor.html" title="class in org.libjpegturbo.turbojpeg">TJDecompressor</a></dt>
 <dd>
@@ -798,7 +801,7 @@
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJDecompressor.html#setSourceImage(org.libjpegturbo.turbojpeg.YUVImage)">setSourceImage(YUVImage)</a></span> - Method in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJDecompressor.html" title="class in org.libjpegturbo.turbojpeg">TJDecompressor</a></dt>
 <dd>
-<div class="block">Associate the specified YUV planar source image with this decompressor
+<div class="block">Associate the specified planar YUV source image with this decompressor
  instance.</div>
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJCompressor.html#setSubsamp(int)">setSubsamp(int)</a></span> - Method in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJCompressor.html" title="class in org.libjpegturbo.turbojpeg">TJCompressor</a></dt>
@@ -826,7 +829,7 @@
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJCompressor.html#TJCompressor(byte[],%20int,%20int,%20int,%20int,%20int,%20int)">TJCompressor(byte[], int, int, int, int, int, int)</a></span> - Constructor for class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJCompressor.html" title="class in org.libjpegturbo.turbojpeg">TJCompressor</a></dt>
 <dd>
-<div class="block">Create a TurboJPEG compressor instance and associate the uncompressed
+<div class="block">Create a TurboJPEG compressor instance and associate the packed-pixel
  source image stored in <code>srcImage</code> with the newly created
  instance.</div>
 </dd>
@@ -839,7 +842,7 @@
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJCompressor.html#TJCompressor(java.awt.image.BufferedImage,%20int,%20int,%20int,%20int)">TJCompressor(BufferedImage, int, int, int, int)</a></span> - Constructor for class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJCompressor.html" title="class in org.libjpegturbo.turbojpeg">TJCompressor</a></dt>
 <dd>
-<div class="block">Create a TurboJPEG compressor instance and associate the uncompressed
+<div class="block">Create a TurboJPEG compressor instance and associate the packed-pixel
  source image stored in <code>srcImage</code> with the newly created
  instance.</div>
 </dd>
@@ -858,17 +861,19 @@
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJDecompressor.html#TJDecompressor(byte[])">TJDecompressor(byte[])</a></span> - Constructor for class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJDecompressor.html" title="class in org.libjpegturbo.turbojpeg">TJDecompressor</a></dt>
 <dd>
 <div class="block">Create a TurboJPEG decompressor instance and associate the JPEG source
- image stored in <code>jpegImage</code> with the newly created instance.</div>
+ image or "abbreviated table specification" (AKA "tables-only") datastream
+ stored in <code>jpegImage</code> with the newly created instance.</div>
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJDecompressor.html#TJDecompressor(byte[],%20int)">TJDecompressor(byte[], int)</a></span> - Constructor for class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJDecompressor.html" title="class in org.libjpegturbo.turbojpeg">TJDecompressor</a></dt>
 <dd>
 <div class="block">Create a TurboJPEG decompressor instance and associate the JPEG source
- image of length <code>imageSize</code> bytes stored in
- <code>jpegImage</code> with the newly created instance.</div>
+ image or "abbreviated table specification" (AKA "tables-only") datastream
+ of length <code>imageSize</code> bytes stored in <code>jpegImage</code>
+ with the newly created instance.</div>
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJDecompressor.html#TJDecompressor(org.libjpegturbo.turbojpeg.YUVImage)">TJDecompressor(YUVImage)</a></span> - Constructor for class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJDecompressor.html" title="class in org.libjpegturbo.turbojpeg">TJDecompressor</a></dt>
 <dd>
-<div class="block">Create a TurboJPEG decompressor instance and associate the YUV planar
+<div class="block">Create a TurboJPEG decompressor instance and associate the planar YUV
  source image stored in <code>yuvImage</code> with the newly created
  instance.</div>
 </dd>
@@ -919,25 +924,26 @@
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJTransformer.html#TJTransformer(byte[])">TJTransformer(byte[])</a></span> - Constructor for class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJTransformer.html" title="class in org.libjpegturbo.turbojpeg">TJTransformer</a></dt>
 <dd>
 <div class="block">Create a TurboJPEG lossless transformer instance and associate the JPEG
- image stored in <code>jpegImage</code> with the newly created instance.</div>
+ source image stored in <code>jpegImage</code> with the newly created
+ instance.</div>
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJTransformer.html#TJTransformer(byte[],%20int)">TJTransformer(byte[], int)</a></span> - Constructor for class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJTransformer.html" title="class in org.libjpegturbo.turbojpeg">TJTransformer</a></dt>
 <dd>
 <div class="block">Create a TurboJPEG lossless transformer instance and associate the JPEG
- image of length <code>imageSize</code> bytes stored in
+ source image of length <code>imageSize</code> bytes stored in
  <code>jpegImage</code> with the newly created instance.</div>
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJTransformer.html#transform(byte[][],%20org.libjpegturbo.turbojpeg.TJTransform[],%20int)">transform(byte[][], TJTransform[], int)</a></span> - Method in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJTransformer.html" title="class in org.libjpegturbo.turbojpeg">TJTransformer</a></dt>
 <dd>
-<div class="block">Losslessly transform the JPEG image associated with this transformer
- instance into one or more JPEG images stored in the given destination
- buffers.</div>
+<div class="block">Losslessly transform the JPEG source image associated with this
+ transformer instance into one or more JPEG images stored in the given
+ destination buffers.</div>
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJTransformer.html#transform(org.libjpegturbo.turbojpeg.TJTransform[],%20int)">transform(TJTransform[], int)</a></span> - Method in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJTransformer.html" title="class in org.libjpegturbo.turbojpeg">TJTransformer</a></dt>
 <dd>
-<div class="block">Losslessly transform the JPEG image associated with this transformer
- instance and return an array of <a href="./org/libjpegturbo/turbojpeg/TJDecompressor.html" title="class in org.libjpegturbo.turbojpeg"><code>TJDecompressor</code></a> instances, each of
- which has a transformed JPEG image associated with it.</div>
+<div class="block">Losslessly transform the JPEG source image associated with this
+ transformer instance and return an array of <a href="./org/libjpegturbo/turbojpeg/TJDecompressor.html" title="class in org.libjpegturbo.turbojpeg"><code>TJDecompressor</code></a>
+ instances, each of which has a transformed JPEG image associated with it.</div>
 </dd>
 </dl>
 <a name="_Y_">
@@ -945,13 +951,15 @@
 </a>
 <h2 class="title">Y</h2>
 <dl>
+<dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/YUVImage.html#yuvAlign">yuvAlign</a></span> - Variable in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg">YUVImage</a></dt>
+<dd>&nbsp;</dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/YUVImage.html#yuvHeight">yuvHeight</a></span> - Variable in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg">YUVImage</a></dt>
 <dd>&nbsp;</dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJDecompressor.html#yuvImage">yuvImage</a></span> - Variable in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJDecompressor.html" title="class in org.libjpegturbo.turbojpeg">TJDecompressor</a></dt>
 <dd>&nbsp;</dd>
 <dt><a href="./org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg"><span class="strong">YUVImage</span></a> - Class in <a href="./org/libjpegturbo/turbojpeg/package-summary.html">org.libjpegturbo.turbojpeg</a></dt>
 <dd>
-<div class="block">This class encapsulates a YUV planar image and the metadata
+<div class="block">This class encapsulates a planar YUV image and the metadata
  associated with it.</div>
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/YUVImage.html#YUVImage(int,%20int[],%20int,%20int)">YUVImage(int, int[], int, int)</a></span> - Constructor for class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg">YUVImage</a></dt>
@@ -961,8 +969,8 @@
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/YUVImage.html#YUVImage(int,%20int,%20int,%20int)">YUVImage(int, int, int, int)</a></span> - Constructor for class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg">YUVImage</a></dt>
 <dd>
-<div class="block">Create a new <code>YUVImage</code> instance backed by a unified image
- buffer, and allocate memory for the image buffer.</div>
+<div class="block">Create a new <code>YUVImage</code> instance backed by a unified buffer,
+ and allocate memory for the buffer.</div>
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/YUVImage.html#YUVImage(byte[][],%20int[],%20int,%20int[],%20int,%20int)">YUVImage(byte[][], int[], int, int[], int, int)</a></span> - Constructor for class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg">YUVImage</a></dt>
 <dd>
@@ -971,13 +979,11 @@
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/YUVImage.html#YUVImage(byte[],%20int,%20int,%20int,%20int)">YUVImage(byte[], int, int, int, int)</a></span> - Constructor for class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg">YUVImage</a></dt>
 <dd>
-<div class="block">Create a new <code>YUVImage</code> instance from an existing unified image
+<div class="block">Create a new <code>YUVImage</code> instance from an existing unified
  buffer.</div>
 </dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/YUVImage.html#yuvOffsets">yuvOffsets</a></span> - Variable in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg">YUVImage</a></dt>
 <dd>&nbsp;</dd>
-<dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/YUVImage.html#yuvPad">yuvPad</a></span> - Variable in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg">YUVImage</a></dt>
-<dd>&nbsp;</dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/YUVImage.html#yuvPlanes">yuvPlanes</a></span> - Variable in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg">YUVImage</a></dt>
 <dd>&nbsp;</dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/YUVImage.html#yuvStrides">yuvStrides</a></span> - Variable in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg">YUVImage</a></dt>
diff --git a/java/doc/org/libjpegturbo/turbojpeg/TJ.html b/java/doc/org/libjpegturbo/turbojpeg/TJ.html
index 2a3de37..f57baa7 100644
--- a/java/doc/org/libjpegturbo/turbojpeg/TJ.html
+++ b/java/doc/org/libjpegturbo/turbojpeg/TJ.html
@@ -156,36 +156,34 @@ extends java.lang.Object</pre>
 <tr class="altColor">
 <td class="colFirst"><code>static int</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJ.html#ERR_WARNING">ERR_WARNING</a></strong></code>
-<div class="block">The error was non-fatal and recoverable, but the image may still be
- corrupt.</div>
+<div class="block">The error was non-fatal and recoverable, but the destination image may
+ still be corrupt.</div>
 </td>
 </tr>
 <tr class="rowColor">
 <td class="colFirst"><code>static int</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJ.html#FLAG_ACCURATEDCT">FLAG_ACCURATEDCT</a></strong></code>
-<div class="block">Use the most accurate DCT/IDCT algorithm available in the underlying
- codec.</div>
+<div class="block">Use the most accurate DCT/IDCT algorithm available.</div>
 </td>
 </tr>
 <tr class="altColor">
 <td class="colFirst"><code>static int</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJ.html#FLAG_BOTTOMUP">FLAG_BOTTOMUP</a></strong></code>
-<div class="block">The uncompressed source/destination image is stored in bottom-up (Windows,
- OpenGL) order, not top-down (X11) order.</div>
+<div class="block">Rows in the packed-pixel source/destination image are stored in bottom-up
+ (Windows, OpenGL) order rather than in top-down (X11) order.</div>
 </td>
 </tr>
 <tr class="rowColor">
 <td class="colFirst"><code>static int</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJ.html#FLAG_FASTDCT">FLAG_FASTDCT</a></strong></code>
-<div class="block">Use the fastest DCT/IDCT algorithm available in the underlying codec.</div>
+<div class="block">Use the fastest DCT/IDCT algorithm available.</div>
 </td>
 </tr>
 <tr class="altColor">
 <td class="colFirst"><code>static int</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJ.html#FLAG_FASTUPSAMPLE">FLAG_FASTUPSAMPLE</a></strong></code>
 <div class="block">When decompressing an image that was compressed using chrominance
- subsampling, use the fastest chrominance upsampling algorithm available in
- the underlying codec.</div>
+ subsampling, use the fastest chrominance upsampling algorithm available.</div>
 </td>
 </tr>
 <tr class="rowColor">
@@ -230,7 +228,7 @@ extends java.lang.Object</pre>
 <td class="colFirst"><code>static int</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJ.html#FLAG_STOPONWARNING">FLAG_STOPONWARNING</a></strong></code>
 <div class="block">Immediately discontinue the current compression/decompression/transform
- operation if the underlying codec throws a warning (non-fatal error).</div>
+ operation if a warning (non-fatal error) occurs.</div>
 </td>
 </tr>
 <tr class="altColor">
@@ -402,11 +400,12 @@ extends java.lang.Object</pre>
 <tr class="altColor">
 <td class="colFirst"><code>static int</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJ.html#bufSizeYUV(int,%20int,%20int,%20int)">bufSizeYUV</a></strong>(int&nbsp;width,
-          int&nbsp;pad,
+          int&nbsp;align,
           int&nbsp;height,
           int&nbsp;subsamp)</code>
-<div class="block">Returns the size of the buffer (in bytes) required to hold a YUV planar
- image with the given width, height, and level of chrominance subsampling.</div>
+<div class="block">Returns the size of the buffer (in bytes) required to hold a unified
+ planar YUV image with the given width, height, and level of chrominance
+ subsampling.</div>
 </td>
 </tr>
 <tr class="rowColor">
@@ -460,8 +459,8 @@ extends java.lang.Object</pre>
 <tr class="altColor">
 <td class="colFirst"><code>static <a href="../../../org/libjpegturbo/turbojpeg/TJScalingFactor.html" title="class in org.libjpegturbo.turbojpeg">TJScalingFactor</a>[]</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJ.html#getScalingFactors()">getScalingFactors</a></strong>()</code>
-<div class="block">Returns a list of fractional scaling factors that the JPEG decompressor in
- this implementation of TurboJPEG supports.</div>
+<div class="block">Returns a list of fractional scaling factors that the JPEG decompressor
+ supports.</div>
 </td>
 </tr>
 <tr class="rowColor">
@@ -778,8 +777,8 @@ extends java.lang.Object</pre>
  vice versa, but the mapping is typically not 1:1 or reversible, nor can it
  be defined with a simple formula.  Thus, such a conversion is out of scope
  for a codec library.  However, the TurboJPEG API allows for compressing
- CMYK pixels into a YCCK JPEG image (see <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#CS_YCCK"><code>CS_YCCK</code></a>) and
- decompressing YCCK JPEG images into CMYK pixels.</div>
+ packed-pixel CMYK images into YCCK JPEG images (see <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#CS_YCCK"><code>CS_YCCK</code></a>) and
+ decompressing YCCK JPEG images into packed-pixel CMYK images.</div>
 <dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#org.libjpegturbo.turbojpeg.TJ.PF_CMYK">Constant Field Values</a></dd></dl>
 </li>
 </ul>
@@ -804,8 +803,9 @@ extends java.lang.Object</pre>
 <div class="block">RGB colorspace.  When compressing the JPEG image, the R, G, and B
  components in the source image are reordered into image planes, but no
  colorspace conversion or subsampling is performed.  RGB JPEG images can be
- decompressed to any of the extended RGB pixel formats or grayscale, but
- they cannot be decompressed to YUV images.</div>
+ decompressed to packed-pixel images with any of the extended RGB or
+ grayscale pixel formats, but they cannot be decompressed to planar YUV
+ images.</div>
 <dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#org.libjpegturbo.turbojpeg.TJ.CS_RGB">Constant Field Values</a></dd></dl>
 </li>
 </ul>
@@ -826,10 +826,11 @@ extends java.lang.Object</pre>
  transformation allowed the same signal to drive both black &amp; white and
  color televisions, but JPEG images use YCbCr primarily because it allows
  the color data to be optionally subsampled for the purposes of reducing
- bandwidth or disk space.  YCbCr is the most common JPEG colorspace, and
- YCbCr JPEG images can be compressed from and decompressed to any of the
- extended RGB pixel formats or grayscale, or they can be decompressed to
- YUV planar images.</div>
+ network or disk usage.  YCbCr is the most common JPEG colorspace, and
+ YCbCr JPEG images can be compressed from and decompressed to packed-pixel
+ images with any of the extended RGB or grayscale pixel formats.  YCbCr
+ JPEG images can also be compressed from and decompressed to planar YUV
+ images.</div>
 <dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#org.libjpegturbo.turbojpeg.TJ.CS_YCbCr">Constant Field Values</a></dd></dl>
 </li>
 </ul>
@@ -842,9 +843,10 @@ extends java.lang.Object</pre>
 <pre>public static final&nbsp;int CS_GRAY</pre>
 <div class="block">Grayscale colorspace.  The JPEG image retains only the luminance data (Y
  component), and any color data from the source image is discarded.
- Grayscale JPEG images can be compressed from and decompressed to any of
- the extended RGB pixel formats or grayscale, or they can be decompressed
- to YUV planar images.</div>
+ Grayscale JPEG images can be compressed from and decompressed to
+ packed-pixel images with any of the extended RGB or grayscale pixel
+ formats, or they can be compressed from and decompressed to planar YUV
+ images.</div>
 <dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#org.libjpegturbo.turbojpeg.TJ.CS_GRAY">Constant Field Values</a></dd></dl>
 </li>
 </ul>
@@ -858,7 +860,7 @@ extends java.lang.Object</pre>
 <div class="block">CMYK colorspace.  When compressing the JPEG image, the C, M, Y, and K
  components in the source image are reordered into image planes, but no
  colorspace conversion or subsampling is performed.  CMYK JPEG images can
- only be decompressed to CMYK pixels.</div>
+ only be decompressed to packed-pixel images with the CMYK pixel format.</div>
 <dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#org.libjpegturbo.turbojpeg.TJ.CS_CMYK">Constant Field Values</a></dd></dl>
 </li>
 </ul>
@@ -875,7 +877,7 @@ extends java.lang.Object</pre>
  reversibly transformed into YCCK, and as with YCbCr, the chrominance
  components in the YCCK pixels can be subsampled without incurring major
  perceptual loss.  YCCK JPEG images can only be compressed from and
- decompressed to CMYK pixels.</div>
+ decompressed to packed-pixel images with the CMYK pixel format.</div>
 <dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#org.libjpegturbo.turbojpeg.TJ.CS_YCCK">Constant Field Values</a></dd></dl>
 </li>
 </ul>
@@ -886,8 +888,8 @@ extends java.lang.Object</pre>
 <li class="blockList">
 <h4>FLAG_BOTTOMUP</h4>
 <pre>public static final&nbsp;int FLAG_BOTTOMUP</pre>
-<div class="block">The uncompressed source/destination image is stored in bottom-up (Windows,
- OpenGL) order, not top-down (X11) order.</div>
+<div class="block">Rows in the packed-pixel source/destination image are stored in bottom-up
+ (Windows, OpenGL) order rather than in top-down (X11) order.</div>
 <dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#org.libjpegturbo.turbojpeg.TJ.FLAG_BOTTOMUP">Constant Field Values</a></dd></dl>
 </li>
 </ul>
@@ -947,10 +949,10 @@ public static final&nbsp;int FLAG_FORCESSE3</pre>
 <h4>FLAG_FASTUPSAMPLE</h4>
 <pre>public static final&nbsp;int FLAG_FASTUPSAMPLE</pre>
 <div class="block">When decompressing an image that was compressed using chrominance
- subsampling, use the fastest chrominance upsampling algorithm available in
- the underlying codec.  The default is to use smooth upsampling, which
- creates a smooth transition between neighboring chrominance components in
- order to reduce upsampling artifacts in the decompressed image.</div>
+ subsampling, use the fastest chrominance upsampling algorithm available.
+ The default is to use smooth upsampling, which creates a smooth transition
+ between neighboring chrominance components in order to reduce upsampling
+ artifacts in the decompressed image.</div>
 <dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#org.libjpegturbo.turbojpeg.TJ.FLAG_FASTUPSAMPLE">Constant Field Values</a></dd></dl>
 </li>
 </ul>
@@ -961,12 +963,12 @@ public static final&nbsp;int FLAG_FORCESSE3</pre>
 <li class="blockList">
 <h4>FLAG_FASTDCT</h4>
 <pre>public static final&nbsp;int FLAG_FASTDCT</pre>
-<div class="block">Use the fastest DCT/IDCT algorithm available in the underlying codec.  The
- default if this flag is not specified is implementation-specific.  For
- example, the implementation of TurboJPEG for libjpeg[-turbo] uses the fast
- algorithm by default when compressing, because this has been shown to have
- only a very slight effect on accuracy, but it uses the accurate algorithm
- when decompressing, because this has been shown to have a larger effect.</div>
+<div class="block">Use the fastest DCT/IDCT algorithm available.  The default if this flag is
+ not specified is implementation-specific.  For example, the implementation
+ of the TurboJPEG API in libjpeg-turbo uses the fast algorithm by default
+ when compressing, because this has been shown to have only a very slight
+ effect on accuracy, but it uses the accurate algorithm when decompressing,
+ because this has been shown to have a larger effect.</div>
 <dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#org.libjpegturbo.turbojpeg.TJ.FLAG_FASTDCT">Constant Field Values</a></dd></dl>
 </li>
 </ul>
@@ -977,13 +979,12 @@ public static final&nbsp;int FLAG_FORCESSE3</pre>
 <li class="blockList">
 <h4>FLAG_ACCURATEDCT</h4>
 <pre>public static final&nbsp;int FLAG_ACCURATEDCT</pre>
-<div class="block">Use the most accurate DCT/IDCT algorithm available in the underlying
- codec.  The default if this flag is not specified is
- implementation-specific.  For example, the implementation of TurboJPEG for
- libjpeg[-turbo] uses the fast algorithm by default when compressing,
- because this has been shown to have only a very slight effect on accuracy,
- but it uses the accurate algorithm when decompressing, because this has
- been shown to have a larger effect.</div>
+<div class="block">Use the most accurate DCT/IDCT algorithm available.  The default if this
+ flag is not specified is implementation-specific.  For example, the
+ implementation of the TurboJPEG API in libjpeg-turbo uses the fast
+ algorithm by default when compressing, because this has been shown to have
+ only a very slight effect on accuracy, but it uses the accurate algorithm
+ when decompressing, because this has been shown to have a larger effect.</div>
 <dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#org.libjpegturbo.turbojpeg.TJ.FLAG_ACCURATEDCT">Constant Field Values</a></dd></dl>
 </li>
 </ul>
@@ -995,14 +996,13 @@ public static final&nbsp;int FLAG_FORCESSE3</pre>
 <h4>FLAG_STOPONWARNING</h4>
 <pre>public static final&nbsp;int FLAG_STOPONWARNING</pre>
 <div class="block">Immediately discontinue the current compression/decompression/transform
- operation if the underlying codec throws a warning (non-fatal error).  The
- default behavior is to allow the operation to complete unless a fatal
- error is encountered.
+ operation if a warning (non-fatal error) occurs.  The default behavior is
+ to allow the operation to complete unless a fatal error is encountered.
  <p>
  NOTE: due to the design of the TurboJPEG Java API, only certain methods
  (specifically, <a href="../../../org/libjpegturbo/turbojpeg/TJDecompressor.html" title="class in org.libjpegturbo.turbojpeg"><code>TJDecompressor.decompress*()</code></a> methods
- with a void return type) will complete and leave the output image in a
- fully recoverable state after a non-fatal error occurs.</div>
+ with a void return type) will complete and leave the destination image in
+ a fully recoverable state after a non-fatal error occurs.</div>
 <dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#org.libjpegturbo.turbojpeg.TJ.FLAG_STOPONWARNING">Constant Field Values</a></dd></dl>
 </li>
 </ul>
@@ -1055,13 +1055,13 @@ public static final&nbsp;int FLAG_FORCESSE3</pre>
 <li class="blockList">
 <h4>ERR_WARNING</h4>
 <pre>public static final&nbsp;int ERR_WARNING</pre>
-<div class="block">The error was non-fatal and recoverable, but the image may still be
- corrupt.
+<div class="block">The error was non-fatal and recoverable, but the destination image may
+ still be corrupt.
  <p>
  NOTE: due to the design of the TurboJPEG Java API, only certain methods
  (specifically, <a href="../../../org/libjpegturbo/turbojpeg/TJDecompressor.html" title="class in org.libjpegturbo.turbojpeg"><code>TJDecompressor.decompress*()</code></a> methods
- with a void return type) will complete and leave the output image in a
- fully recoverable state after a non-fatal error occurs.</div>
+ with a void return type) will complete and leave the destination image in
+ a fully recoverable state after a non-fatal error occurs.</div>
 <dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#org.libjpegturbo.turbojpeg.TJ.ERR_WARNING">Constant Field Values</a></dd></dl>
 </li>
 </ul>
@@ -1094,7 +1094,7 @@ public static final&nbsp;int FLAG_FORCESSE3</pre>
 <div class="block">Returns the MCU block width for the given level of chrominance
  subsampling.</div>
 <dl><dt><span class="strong">Parameters:</span></dt><dd><code>subsamp</code> - the level of chrominance subsampling (one of
- <code>SAMP_*</code>)</dd>
+ <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#SAMP_444"><code>SAMP_*</code></a>)</dd>
 <dt><span class="strong">Returns:</span></dt><dd>the MCU block width for the given level of chrominance
  subsampling.</dd></dl>
 </li>
@@ -1109,7 +1109,7 @@ public static final&nbsp;int FLAG_FORCESSE3</pre>
 <div class="block">Returns the MCU block height for the given level of chrominance
  subsampling.</div>
 <dl><dt><span class="strong">Parameters:</span></dt><dd><code>subsamp</code> - the level of chrominance subsampling (one of
- <code>SAMP_*</code>)</dd>
+ <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#SAMP_444"><code>SAMP_*</code></a>)</dd>
 <dt><span class="strong">Returns:</span></dt><dd>the MCU block height for the given level of chrominance
  subsampling.</dd></dl>
 </li>
@@ -1122,7 +1122,7 @@ public static final&nbsp;int FLAG_FORCESSE3</pre>
 <h4>getPixelSize</h4>
 <pre>public static&nbsp;int&nbsp;getPixelSize(int&nbsp;pixelFormat)</pre>
 <div class="block">Returns the pixel size (in bytes) for the given pixel format.</div>
-<dl><dt><span class="strong">Parameters:</span></dt><dd><code>pixelFormat</code> - the pixel format (one of <code>PF_*</code>)</dd>
+<dl><dt><span class="strong">Parameters:</span></dt><dd><code>pixelFormat</code> - the pixel format (one of <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#PF_RGB"><code>PF_*</code></a>)</dd>
 <dt><span class="strong">Returns:</span></dt><dd>the pixel size (in bytes) for the given pixel format.</dd></dl>
 </li>
 </ul>
@@ -1138,7 +1138,7 @@ public static final&nbsp;int FLAG_FORCESSE3</pre>
  of format <code>TJ.PF_BGRX</code> is stored in <code>char pixel[]</code>,
  then the red component will be
  <code>pixel[TJ.getRedOffset(TJ.PF_BGRX)]</code>.</div>
-<dl><dt><span class="strong">Parameters:</span></dt><dd><code>pixelFormat</code> - the pixel format (one of <code>PF_*</code>)</dd>
+<dl><dt><span class="strong">Parameters:</span></dt><dd><code>pixelFormat</code> - the pixel format (one of <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#PF_RGB"><code>PF_*</code></a>)</dd>
 <dt><span class="strong">Returns:</span></dt><dd>the red offset for the given pixel format, or -1 if the pixel
  format does not have a red component.</dd></dl>
 </li>
@@ -1155,7 +1155,7 @@ public static final&nbsp;int FLAG_FORCESSE3</pre>
  of format <code>TJ.PF_BGRX</code> is stored in <code>char pixel[]</code>,
  then the green component will be
  <code>pixel[TJ.getGreenOffset(TJ.PF_BGRX)]</code>.</div>
-<dl><dt><span class="strong">Parameters:</span></dt><dd><code>pixelFormat</code> - the pixel format (one of <code>PF_*</code>)</dd>
+<dl><dt><span class="strong">Parameters:</span></dt><dd><code>pixelFormat</code> - the pixel format (one of <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#PF_RGB"><code>PF_*</code></a>)</dd>
 <dt><span class="strong">Returns:</span></dt><dd>the green offset for the given pixel format, or -1 if the pixel
  format does not have a green component.</dd></dl>
 </li>
@@ -1172,7 +1172,7 @@ public static final&nbsp;int FLAG_FORCESSE3</pre>
  of format <code>TJ.PF_BGRX</code> is stored in <code>char pixel[]</code>,
  then the blue component will be
  <code>pixel[TJ.getBlueOffset(TJ.PF_BGRX)]</code>.</div>
-<dl><dt><span class="strong">Parameters:</span></dt><dd><code>pixelFormat</code> - the pixel format (one of <code>PF_*</code>)</dd>
+<dl><dt><span class="strong">Parameters:</span></dt><dd><code>pixelFormat</code> - the pixel format (one of <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#PF_RGB"><code>PF_*</code></a>)</dd>
 <dt><span class="strong">Returns:</span></dt><dd>the blue offset for the given pixel format, or -1 if the pixel
  format does not have a blue component.</dd></dl>
 </li>
@@ -1189,7 +1189,7 @@ public static final&nbsp;int FLAG_FORCESSE3</pre>
  of format <code>TJ.PF_BGRA</code> is stored in <code>char pixel[]</code>,
  then the alpha component will be
  <code>pixel[TJ.getAlphaOffset(TJ.PF_BGRA)]</code>.</div>
-<dl><dt><span class="strong">Parameters:</span></dt><dd><code>pixelFormat</code> - the pixel format (one of <code>PF_*</code>)</dd>
+<dl><dt><span class="strong">Parameters:</span></dt><dd><code>pixelFormat</code> - the pixel format (one of <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#PF_RGB"><code>PF_*</code></a>)</dd>
 <dt><span class="strong">Returns:</span></dt><dd>the alpha offset for the given pixel format, or -1 if the pixel
  format does not have a alpha component.</dd></dl>
 </li>
@@ -1206,7 +1206,7 @@ public static final&nbsp;int FLAG_FORCESSE3</pre>
 <div class="block">Returns the maximum size of the buffer (in bytes) required to hold a JPEG
  image with the given width, height, and level of chrominance subsampling.</div>
 <dl><dt><span class="strong">Parameters:</span></dt><dd><code>width</code> - the width (in pixels) of the JPEG image</dd><dd><code>height</code> - the height (in pixels) of the JPEG image</dd><dd><code>jpegSubsamp</code> - the level of chrominance subsampling to be used when
- generating the JPEG image (one of <a href="../../../org/libjpegturbo/turbojpeg/TJ.html" title="class in org.libjpegturbo.turbojpeg"><code>TJ.SAMP_*</code></a>)</dd>
+ generating the JPEG image (one of <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#SAMP_444"><code>TJ.SAMP_*</code></a>)</dd>
 <dt><span class="strong">Returns:</span></dt><dd>the maximum size of the buffer (in bytes) required to hold a JPEG
  image with the given width, height, and level of chrominance subsampling.</dd></dl>
 </li>
@@ -1218,16 +1218,20 @@ public static final&nbsp;int FLAG_FORCESSE3</pre>
 <li class="blockList">
 <h4>bufSizeYUV</h4>
 <pre>public static&nbsp;int&nbsp;bufSizeYUV(int&nbsp;width,
-             int&nbsp;pad,
+             int&nbsp;align,
              int&nbsp;height,
              int&nbsp;subsamp)</pre>
-<div class="block">Returns the size of the buffer (in bytes) required to hold a YUV planar
- image with the given width, height, and level of chrominance subsampling.</div>
-<dl><dt><span class="strong">Parameters:</span></dt><dd><code>width</code> - the width (in pixels) of the YUV image</dd><dd><code>pad</code> - the width of each line in each plane of the image is padded to
- the nearest multiple of this number of bytes (must be a power of 2.)</dd><dd><code>height</code> - the height (in pixels) of the YUV image</dd><dd><code>subsamp</code> - the level of chrominance subsampling used in the YUV
- image (one of <a href="../../../org/libjpegturbo/turbojpeg/TJ.html" title="class in org.libjpegturbo.turbojpeg"><code>TJ.SAMP_*</code></a>)</dd>
-<dt><span class="strong">Returns:</span></dt><dd>the size of the buffer (in bytes) required to hold a YUV planar
- image with the given width, height, and level of chrominance subsampling.</dd></dl>
+<div class="block">Returns the size of the buffer (in bytes) required to hold a unified
+ planar YUV image with the given width, height, and level of chrominance
+ subsampling.</div>
+<dl><dt><span class="strong">Parameters:</span></dt><dd><code>width</code> - the width (in pixels) of the YUV image</dd><dd><code>align</code> - row alignment (in bytes) of the YUV image (must be a power of
+ 2.)  Setting this parameter to n specifies that each row in each plane of
+ the YUV image will be padded to the nearest multiple of n bytes
+ (1 = unpadded.)</dd><dd><code>height</code> - the height (in pixels) of the YUV image</dd><dd><code>subsamp</code> - the level of chrominance subsampling used in the YUV
+ image (one of <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#SAMP_444"><code>TJ.SAMP_*</code></a>)</dd>
+<dt><span class="strong">Returns:</span></dt><dd>the size of the buffer (in bytes) required to hold a unified
+ planar YUV image with the given width, height, and level of chrominance
+ subsampling.</dd></dl>
 </li>
 </ul>
 <a name="bufSizeYUV(int, int, int)">
@@ -1258,11 +1262,11 @@ public static&nbsp;int&nbsp;bufSizeYUV(int&nbsp;width,
  plane with the given parameters.</div>
 <dl><dt><span class="strong">Parameters:</span></dt><dd><code>componentID</code> - ID number of the image plane (0 = Y, 1 = U/Cb,
  2 = V/Cr)</dd><dd><code>width</code> - width (in pixels) of the YUV image.  NOTE: this is the width
- of the whole image, not the plane width.</dd><dd><code>stride</code> - bytes per line in the image plane.</dd><dd><code>height</code> - height (in pixels) of the YUV image.  NOTE: this is the
+ of the whole image, not the plane width.</dd><dd><code>stride</code> - bytes per row in the image plane.</dd><dd><code>height</code> - height (in pixels) of the YUV image.  NOTE: this is the
  height of the whole image, not the plane height.</dd><dd><code>subsamp</code> - the level of chrominance subsampling used in the YUV
- image (one of <a href="../../../org/libjpegturbo/turbojpeg/TJ.html" title="class in org.libjpegturbo.turbojpeg"><code>TJ.SAMP_*</code></a>)</dd>
-<dt><span class="strong">Returns:</span></dt><dd>the size of the buffer (in bytes) required to hold a YUV planar
- image with the given parameters.</dd></dl>
+ image (one of <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#SAMP_444"><code>TJ.SAMP_*</code></a>)</dd>
+<dt><span class="strong">Returns:</span></dt><dd>the size of the buffer (in bytes) required to hold a YUV image
+ plane with the given parameters.</dd></dl>
 </li>
 </ul>
 <a name="planeWidth(int, int, int)">
@@ -1278,7 +1282,7 @@ public static&nbsp;int&nbsp;bufSizeYUV(int&nbsp;width,
  Refer to <a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg"><code>YUVImage</code></a> for a description of plane width.</div>
 <dl><dt><span class="strong">Parameters:</span></dt><dd><code>componentID</code> - ID number of the image plane (0 = Y, 1 = U/Cb,
  2 = V/Cr)</dd><dd><code>width</code> - width (in pixels) of the YUV image</dd><dd><code>subsamp</code> - the level of chrominance subsampling used in the YUV image
- (one of <a href="../../../org/libjpegturbo/turbojpeg/TJ.html" title="class in org.libjpegturbo.turbojpeg"><code>TJ.SAMP_*</code></a>)</dd>
+ (one of <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#SAMP_444"><code>TJ.SAMP_*</code></a>)</dd>
 <dt><span class="strong">Returns:</span></dt><dd>the plane width of a YUV image plane with the given parameters.</dd></dl>
 </li>
 </ul>
@@ -1295,7 +1299,7 @@ public static&nbsp;int&nbsp;bufSizeYUV(int&nbsp;width,
  Refer to <a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg"><code>YUVImage</code></a> for a description of plane height.</div>
 <dl><dt><span class="strong">Parameters:</span></dt><dd><code>componentID</code> - ID number of the image plane (0 = Y, 1 = U/Cb,
  2 = V/Cr)</dd><dd><code>height</code> - height (in pixels) of the YUV image</dd><dd><code>subsamp</code> - the level of chrominance subsampling used in the YUV image
- (one of <a href="../../../org/libjpegturbo/turbojpeg/TJ.html" title="class in org.libjpegturbo.turbojpeg"><code>TJ.SAMP_*</code></a>)</dd>
+ (one of <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#SAMP_444"><code>TJ.SAMP_*</code></a>)</dd>
 <dt><span class="strong">Returns:</span></dt><dd>the plane height of a YUV image plane with the given parameters.</dd></dl>
 </li>
 </ul>
@@ -1306,10 +1310,10 @@ public static&nbsp;int&nbsp;bufSizeYUV(int&nbsp;width,
 <li class="blockList">
 <h4>getScalingFactors</h4>
 <pre>public static&nbsp;<a href="../../../org/libjpegturbo/turbojpeg/TJScalingFactor.html" title="class in org.libjpegturbo.turbojpeg">TJScalingFactor</a>[]&nbsp;getScalingFactors()</pre>
-<div class="block">Returns a list of fractional scaling factors that the JPEG decompressor in
- this implementation of TurboJPEG supports.</div>
-<dl><dt><span class="strong">Returns:</span></dt><dd>a list of fractional scaling factors that the JPEG decompressor in
- this implementation of TurboJPEG supports.</dd></dl>
+<div class="block">Returns a list of fractional scaling factors that the JPEG decompressor
+ supports.</div>
+<dl><dt><span class="strong">Returns:</span></dt><dd>a list of fractional scaling factors that the JPEG decompressor
+ supports.</dd></dl>
 </li>
 </ul>
 </li>
diff --git a/java/doc/org/libjpegturbo/turbojpeg/TJCompressor.html b/java/doc/org/libjpegturbo/turbojpeg/TJCompressor.html
index a53f879..440247b 100644
--- a/java/doc/org/libjpegturbo/turbojpeg/TJCompressor.html
+++ b/java/doc/org/libjpegturbo/turbojpeg/TJCompressor.html
@@ -132,7 +132,7 @@ implements java.io.Closeable</pre>
             int&nbsp;y,
             int&nbsp;width,
             int&nbsp;height)</code>
-<div class="block">Create a TurboJPEG compressor instance and associate the uncompressed
+<div class="block">Create a TurboJPEG compressor instance and associate the packed-pixel
  source image stored in <code>srcImage</code> with the newly created
  instance.</div>
 </td>
@@ -157,7 +157,7 @@ implements java.io.Closeable</pre>
             int&nbsp;pitch,
             int&nbsp;height,
             int&nbsp;pixelFormat)</code>
-<div class="block">Create a TurboJPEG compressor instance and associate the uncompressed
+<div class="block">Create a TurboJPEG compressor instance and associate the packed-pixel
  source image stored in <code>srcImage</code> with the newly created
  instance.</div>
 </td>
@@ -210,15 +210,16 @@ implements java.io.Closeable</pre>
 <td class="colFirst"><code>void</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJCompressor.html#compress(byte[],%20int)">compress</a></strong>(byte[]&nbsp;dstBuf,
         int&nbsp;flags)</code>
-<div class="block">Compress the uncompressed source image associated with this compressor
- instance and output a JPEG image to the given destination buffer.</div>
+<div class="block">Compress the packed-pixel or planar YUV source image associated with this
+ compressor instance and output a JPEG image to the given destination
+ buffer.</div>
 </td>
 </tr>
 <tr class="altColor">
 <td class="colFirst"><code>byte[]</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJCompressor.html#compress(int)">compress</a></strong>(int&nbsp;flags)</code>
-<div class="block">Compress the uncompressed source image associated with this compressor
- instance and return a buffer containing a JPEG image.</div>
+<div class="block">Compress the packed-pixel or planar YUV source image associated with this
+ compressor instance and return a buffer containing a JPEG image.</div>
 </td>
 </tr>
 <tr class="rowColor">
@@ -265,27 +266,27 @@ implements java.io.Closeable</pre>
 <td class="colFirst"><code><a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg">YUVImage</a></code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJCompressor.html#encodeYUV(int[],%20int)">encodeYUV</a></strong>(int[]&nbsp;strides,
          int&nbsp;flags)</code>
-<div class="block">Encode the uncompressed source image associated with this compressor
+<div class="block">Encode the packed-pixel source image associated with this compressor
  instance into separate Y, U (Cb), and V (Cr) image planes and return a
- <code>YUVImage</code> instance containing the encoded image planes.</div>
+ <a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg"><code>YUVImage</code></a> instance containing the encoded image planes.</div>
 </td>
 </tr>
 <tr class="altColor">
 <td class="colFirst"><code><a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg">YUVImage</a></code></td>
-<td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJCompressor.html#encodeYUV(int,%20int)">encodeYUV</a></strong>(int&nbsp;pad,
+<td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJCompressor.html#encodeYUV(int,%20int)">encodeYUV</a></strong>(int&nbsp;align,
          int&nbsp;flags)</code>
-<div class="block">Encode the uncompressed source image associated with this compressor
- instance into a unified YUV planar image buffer and return a
- <code>YUVImage</code> instance containing the encoded image.</div>
+<div class="block">Encode the packed-pixel source image associated with this compressor
+ instance into a unified planar YUV image and return a <a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg"><code>YUVImage</code></a>
+ instance containing the encoded image.</div>
 </td>
 </tr>
 <tr class="rowColor">
 <td class="colFirst"><code>void</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJCompressor.html#encodeYUV(org.libjpegturbo.turbojpeg.YUVImage,%20int)">encodeYUV</a></strong>(<a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg">YUVImage</a>&nbsp;dstImage,
          int&nbsp;flags)</code>
-<div class="block">Encode the uncompressed source image associated with this compressor
- instance into a YUV planar image and store it in the given
- <code>YUVImage</code> instance.</div>
+<div class="block">Encode the packed-pixel source image associated with this compressor
+ instance into a planar YUV image and store it in the given
+ <a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg"><code>YUVImage</code></a> instance.</div>
 </td>
 </tr>
 <tr class="altColor">
@@ -312,7 +313,7 @@ implements java.io.Closeable</pre>
               int&nbsp;y,
               int&nbsp;width,
               int&nbsp;height)</code>
-<div class="block">Associate an uncompressed RGB or grayscale source image with this
+<div class="block">Associate a packed-pixel RGB or grayscale source image with this
  compressor instance.</div>
 </td>
 </tr>
@@ -338,15 +339,14 @@ implements java.io.Closeable</pre>
               int&nbsp;pitch,
               int&nbsp;height,
               int&nbsp;pixelFormat)</code>
-<div class="block">Associate an uncompressed RGB, grayscale, or CMYK source image with this
+<div class="block">Associate a packed-pixel RGB, grayscale, or CMYK source image with this
  compressor instance.</div>
 </td>
 </tr>
 <tr class="altColor">
 <td class="colFirst"><code>void</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJCompressor.html#setSourceImage(org.libjpegturbo.turbojpeg.YUVImage)">setSourceImage</a></strong>(<a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg">YUVImage</a>&nbsp;srcImage)</code>
-<div class="block">Associate an uncompressed YUV planar source image with this compressor
- instance.</div>
+<div class="block">Associate a planar YUV source image with this compressor instance.</div>
 </td>
 </tr>
 <tr class="rowColor">
@@ -405,7 +405,7 @@ implements java.io.Closeable</pre>
             int&nbsp;height,
             int&nbsp;pixelFormat)
              throws <a href="../../../org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg">TJException</a></pre>
-<div class="block">Create a TurboJPEG compressor instance and associate the uncompressed
+<div class="block">Create a TurboJPEG compressor instance and associate the packed-pixel
  source image stored in <code>srcImage</code> with the newly created
  instance.</div>
 <dl><dt><span class="strong">Parameters:</span></dt><dd><code>srcImage</code> - see <a href="../../../org/libjpegturbo/turbojpeg/TJCompressor.html#setSourceImage(byte[],%20int,%20int,%20int,%20int,%20int,%20int)"><code>setSourceImage(byte[], int, int, int, int, int, int)</code></a> for description</dd><dd><code>x</code> - see <a href="../../../org/libjpegturbo/turbojpeg/TJCompressor.html#setSourceImage(byte[],%20int,%20int,%20int,%20int,%20int,%20int)"><code>setSourceImage(byte[], int, int, int, int, int, int)</code></a> for description</dd><dd><code>y</code> - see <a href="../../../org/libjpegturbo/turbojpeg/TJCompressor.html#setSourceImage(byte[],%20int,%20int,%20int,%20int,%20int,%20int)"><code>setSourceImage(byte[], int, int, int, int, int, int)</code></a> for description</dd><dd><code>width</code> - see <a href="../../../org/libjpegturbo/turbojpeg/TJCompressor.html#setSourceImage(byte[],%20int,%20int,%20int,%20int,%20int,%20int)"><code>setSourceImage(byte[], int, int, int, int, int, int)</code></a> for description</dd><dd><code>pitch</code> - see <a href="../../../org/libjpegturbo/turbojpeg/TJCompressor.html#setSourceImage(byte[],%20int,%20int,%20int,%20int,%20int,%20int)"><code>setSourceImage(byte[], int, int, int, int, int, int)</code></a> for description</dd><dd><code>height</code> - see <a href="../../../org/libjpegturbo/turbojpeg/TJCompressor.html#setSourceImage(byte[],%20int,%20int,%20int,%20int,%20int,%20int)"><code>setSourceImage(byte[], int, int, int, int, int, int)</code></a> for description</dd><dd><code>pixelFormat</code> - pixel format of the source image (one of
@@ -445,7 +445,7 @@ public&nbsp;TJCompressor(byte[]&nbsp;srcImage,
             int&nbsp;width,
             int&nbsp;height)
              throws <a href="../../../org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg">TJException</a></pre>
-<div class="block">Create a TurboJPEG compressor instance and associate the uncompressed
+<div class="block">Create a TurboJPEG compressor instance and associate the packed-pixel
  source image stored in <code>srcImage</code> with the newly created
  instance.</div>
 <dl><dt><span class="strong">Parameters:</span></dt><dd><code>srcImage</code> - see
@@ -480,20 +480,22 @@ public&nbsp;TJCompressor(byte[]&nbsp;srcImage,
                   int&nbsp;height,
                   int&nbsp;pixelFormat)
                     throws <a href="../../../org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg">TJException</a></pre>
-<div class="block">Associate an uncompressed RGB, grayscale, or CMYK source image with this
+<div class="block">Associate a packed-pixel RGB, grayscale, or CMYK source image with this
  compressor instance.</div>
-<dl><dt><span class="strong">Parameters:</span></dt><dd><code>srcImage</code> - image buffer containing RGB, grayscale, or CMYK pixels to
- be compressed or encoded.  This buffer is not modified.</dd><dd><code>x</code> - x offset (in pixels) of the region in the source image from which
+<dl><dt><span class="strong">Parameters:</span></dt><dd><code>srcImage</code> - buffer containing a packed-pixel RGB, grayscale, or CMYK
+ source image to be compressed or encoded.  This buffer is not modified.</dd><dd><code>x</code> - x offset (in pixels) of the region in the source image from which
  the JPEG or YUV image should be compressed/encoded</dd><dd><code>y</code> - y offset (in pixels) of the region in the source image from which
  the JPEG or YUV image should be compressed/encoded</dd><dd><code>width</code> - width (in pixels) of the region in the source image from
- which the JPEG or YUV image should be compressed/encoded</dd><dd><code>pitch</code> - bytes per line of the source image.  Normally, this should be
- <code>width * TJ.pixelSize(pixelFormat)</code> if the source image is
- unpadded, but you can use this parameter to, for instance, specify that
- the scanlines in the source image are padded to a 4-byte boundary or to
- compress/encode a JPEG or YUV image from a region of a larger source
- image.  You can also be clever and use this parameter to skip lines, etc.
- Setting this parameter to 0 is the equivalent of setting it to
- <code>width * TJ.pixelSize(pixelFormat)</code>.</dd><dd><code>height</code> - height (in pixels) of the region in the source image from
+ which the JPEG or YUV image should be compressed/encoded</dd><dd><code>pitch</code> - bytes per row in the source image.  Normally this should be
+ <code>width *
+ </code><a href="../../../org/libjpegturbo/turbojpeg/TJ.html#getPixelSize(int)"><code>TJ.getPixelSize</code></a><code>(pixelFormat)</code>,
+ if the source image is unpadded.  However, you can use this parameter to,
+ for instance, specify that the rows in the source image are padded to the
+ nearest multiple of 4 bytes or to compress/encode a JPEG or YUV image from
+ a region of a larger source image.  You can also be clever and use this
+ parameter to skip rows, etc.  Setting this parameter to 0 is the
+ equivalent of setting it to <code>width *
+ </code><a href="../../../org/libjpegturbo/turbojpeg/TJ.html#getPixelSize(int)"><code>TJ.getPixelSize</code></a><code>(pixelFormat)</code>.</dd><dd><code>height</code> - height (in pixels) of the region in the source image from
  which the JPEG or YUV image should be compressed/encoded</dd><dd><code>pixelFormat</code> - pixel format of the source image (one of
  <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#PF_RGB"><code>TJ.PF_*</code></a>)</dd>
 <dt><span class="strong">Throws:</span></dt>
@@ -531,10 +533,11 @@ public&nbsp;void&nbsp;setSourceImage(byte[]&nbsp;srcImage,
                   int&nbsp;width,
                   int&nbsp;height)
                     throws <a href="../../../org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg">TJException</a></pre>
-<div class="block">Associate an uncompressed RGB or grayscale source image with this
+<div class="block">Associate a packed-pixel RGB or grayscale source image with this
  compressor instance.</div>
-<dl><dt><span class="strong">Parameters:</span></dt><dd><code>srcImage</code> - a <code>BufferedImage</code> instance containing RGB or
- grayscale pixels to be compressed or encoded.  This image is not modified.</dd><dd><code>x</code> - x offset (in pixels) of the region in the source image from which
+<dl><dt><span class="strong">Parameters:</span></dt><dd><code>srcImage</code> - a <code>BufferedImage</code> instance containing a
+ packed-pixel RGB or grayscale source image to be compressed or encoded.
+ This image is not modified.</dd><dd><code>x</code> - x offset (in pixels) of the region in the source image from which
  the JPEG or YUV image should be compressed/encoded</dd><dd><code>y</code> - y offset (in pixels) of the region in the source image from which
  the JPEG or YUV image should be compressed/encoded</dd><dd><code>width</code> - width (in pixels) of the region in the source image from
  which the JPEG or YUV image should be compressed/encoded (0 = use the
@@ -553,10 +556,9 @@ public&nbsp;void&nbsp;setSourceImage(byte[]&nbsp;srcImage,
 <h4>setSourceImage</h4>
 <pre>public&nbsp;void&nbsp;setSourceImage(<a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg">YUVImage</a>&nbsp;srcImage)
                     throws <a href="../../../org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg">TJException</a></pre>
-<div class="block">Associate an uncompressed YUV planar source image with this compressor
- instance.</div>
-<dl><dt><span class="strong">Parameters:</span></dt><dd><code>srcImage</code> - YUV planar image to be compressed.  This image is not
- modified.</dd>
+<div class="block">Associate a planar YUV source image with this compressor instance.</div>
+<dl><dt><span class="strong">Parameters:</span></dt><dd><code>srcImage</code> - planar YUV source image to be compressed.  This image is
+ not modified.</dd>
 <dt><span class="strong">Throws:</span></dt>
 <dd><code><a href="../../../org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg">TJException</a></code></dd></dl>
 </li>
@@ -573,16 +575,16 @@ public&nbsp;void&nbsp;setSourceImage(byte[]&nbsp;srcImage,
  <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#CS_YCbCr"><code>TJ.CS_YCbCr</code></a>) or from CMYK to YCCK (see <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#CS_YCCK"><code>TJ.CS_YCCK</code></a>) as part
  of the JPEG compression process, some of the Cb and Cr (chrominance)
  components can be discarded or averaged together to produce a smaller
- image with little perceptible loss of image clarity (the human eye is more
- sensitive to small changes in brightness than to small changes in color.)
- This is called "chrominance subsampling".
+ image with little perceptible loss of image clarity.  (The human eye is
+ more sensitive to small changes in brightness than to small changes in
+ color.)  This is called "chrominance subsampling".
  <p>
- NOTE: This method has no effect when compressing a JPEG image from a YUV
- planar source.  In that case, the level of chrominance subsampling in
- the JPEG image is determined by the source.  Furthermore, this method has
- no effect when encoding to a pre-allocated <a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg"><code>YUVImage</code></a> instance.  In
- that case, the level of chrominance subsampling is determined by the
- destination.</div>
+ NOTE: This method has no effect when compressing a JPEG image from a
+ planar YUV source image.  In that case, the level of chrominance
+ subsampling in the JPEG image is determined by the source image.
+ Furthermore, this method has no effect when encoding to a pre-allocated
+ <a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg"><code>YUVImage</code></a> instance.  In that case, the level of chrominance
+ subsampling is determined by the destination image.</div>
 <dl><dt><span class="strong">Parameters:</span></dt><dd><code>newSubsamp</code> - the level of chrominance subsampling to use in
  subsequent compress/encode oeprations (one of
  <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#SAMP_444"><code>TJ.SAMP_*</code></a>)</dd></dl>
@@ -609,8 +611,9 @@ public&nbsp;void&nbsp;setSourceImage(byte[]&nbsp;srcImage,
 <pre>public&nbsp;void&nbsp;compress(byte[]&nbsp;dstBuf,
             int&nbsp;flags)
               throws <a href="../../../org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg">TJException</a></pre>
-<div class="block">Compress the uncompressed source image associated with this compressor
- instance and output a JPEG image to the given destination buffer.</div>
+<div class="block">Compress the packed-pixel or planar YUV source image associated with this
+ compressor instance and output a JPEG image to the given destination
+ buffer.</div>
 <dl><dt><span class="strong">Parameters:</span></dt><dd><code>dstBuf</code> - buffer that will receive the JPEG image.  Use
  <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#bufSize(int,%20int,%20int)"><code>TJ.bufSize(int, int, int)</code></a> to determine the maximum size for this buffer based on
  the source image's width and height and the desired level of chrominance
@@ -628,8 +631,8 @@ public&nbsp;void&nbsp;setSourceImage(byte[]&nbsp;srcImage,
 <h4>compress</h4>
 <pre>public&nbsp;byte[]&nbsp;compress(int&nbsp;flags)
                 throws <a href="../../../org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg">TJException</a></pre>
-<div class="block">Compress the uncompressed source image associated with this compressor
- instance and return a buffer containing a JPEG image.</div>
+<div class="block">Compress the packed-pixel or planar YUV source image associated with this
+ compressor instance and return a buffer containing a JPEG image.</div>
 <dl><dt><span class="strong">Parameters:</span></dt><dd><code>flags</code> - the bitwise OR of one or more of
  <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#FLAG_BOTTOMUP"><code>TJ.FLAG_*</code></a></dd>
 <dt><span class="strong">Returns:</span></dt><dd>a buffer containing a JPEG image.  The length of this buffer will
@@ -682,13 +685,13 @@ public&nbsp;byte[]&nbsp;compress(java.awt.image.BufferedImage&nbsp;srcImage,
 <pre>public&nbsp;void&nbsp;encodeYUV(<a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg">YUVImage</a>&nbsp;dstImage,
              int&nbsp;flags)
                throws <a href="../../../org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg">TJException</a></pre>
-<div class="block">Encode the uncompressed source image associated with this compressor
- instance into a YUV planar image and store it in the given
- <code>YUVImage</code> instance.   This method uses the accelerated color
- conversion routines in TurboJPEG's underlying codec but does not execute
- any of the other steps in the JPEG compression process.  Encoding
- CMYK source images to YUV is not supported.</div>
-<dl><dt><span class="strong">Parameters:</span></dt><dd><code>dstImage</code> - <a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg"><code>YUVImage</code></a> instance that will receive the YUV planar
+<div class="block">Encode the packed-pixel source image associated with this compressor
+ instance into a planar YUV image and store it in the given
+ <a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg"><code>YUVImage</code></a> instance.  This method performs color conversion (which
+ is accelerated in the libjpeg-turbo implementation) but does not execute
+ any of the other steps in the JPEG compression process.  Encoding CMYK
+ source images into YUV images is not supported.</div>
+<dl><dt><span class="strong">Parameters:</span></dt><dd><code>dstImage</code> - <a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg"><code>YUVImage</code></a> instance that will receive the planar YUV
  image</dd><dd><code>flags</code> - the bitwise OR of one or more of
  <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#FLAG_BOTTOMUP"><code>TJ.FLAG_*</code></a></dd>
 <dt><span class="strong">Throws:</span></dt>
@@ -716,20 +719,21 @@ public&nbsp;void&nbsp;encodeYUV(byte[]&nbsp;dstBuf,
 <ul class="blockList">
 <li class="blockList">
 <h4>encodeYUV</h4>
-<pre>public&nbsp;<a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg">YUVImage</a>&nbsp;encodeYUV(int&nbsp;pad,
+<pre>public&nbsp;<a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg">YUVImage</a>&nbsp;encodeYUV(int&nbsp;align,
                  int&nbsp;flags)
                    throws <a href="../../../org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg">TJException</a></pre>
-<div class="block">Encode the uncompressed source image associated with this compressor
- instance into a unified YUV planar image buffer and return a
- <code>YUVImage</code> instance containing the encoded image.  This method
- uses the accelerated color conversion routines in TurboJPEG's underlying
- codec but does not execute any of the other steps in the JPEG compression
- process.  Encoding CMYK source images to YUV is not supported.</div>
-<dl><dt><span class="strong">Parameters:</span></dt><dd><code>pad</code> - the width of each line in each plane of the YUV image will be
- padded to the nearest multiple of this number of bytes (must be a power of
- 2.)</dd><dd><code>flags</code> - the bitwise OR of one or more of
+<div class="block">Encode the packed-pixel source image associated with this compressor
+ instance into a unified planar YUV image and return a <a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg"><code>YUVImage</code></a>
+ instance containing the encoded image.  This method performs color
+ conversion (which is accelerated in the libjpeg-turbo implementation) but
+ does not execute any of the other steps in the JPEG compression process.
+ Encoding CMYK source images into YUV images is not supported.</div>
+<dl><dt><span class="strong">Parameters:</span></dt><dd><code>align</code> - row alignment (in bytes) of the YUV image (must be a power of
+ 2.)  Setting this parameter to n will cause each row in each plane of the
+ YUV image to be padded to the nearest multiple of n bytes (1 = unpadded.)</dd><dd><code>flags</code> - the bitwise OR of one or more of
  <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#FLAG_BOTTOMUP"><code>TJ.FLAG_*</code></a></dd>
-<dt><span class="strong">Returns:</span></dt><dd>a YUV planar image.</dd>
+<dt><span class="strong">Returns:</span></dt><dd>a <a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg"><code>YUVImage</code></a> instance containing the unified planar YUV
+ encoded image</dd>
 <dt><span class="strong">Throws:</span></dt>
 <dd><code><a href="../../../org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg">TJException</a></code></dd></dl>
 </li>
@@ -743,21 +747,22 @@ public&nbsp;void&nbsp;encodeYUV(byte[]&nbsp;dstBuf,
 <pre>public&nbsp;<a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg">YUVImage</a>&nbsp;encodeYUV(int[]&nbsp;strides,
                  int&nbsp;flags)
                    throws <a href="../../../org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg">TJException</a></pre>
-<div class="block">Encode the uncompressed source image associated with this compressor
+<div class="block">Encode the packed-pixel source image associated with this compressor
  instance into separate Y, U (Cb), and V (Cr) image planes and return a
- <code>YUVImage</code> instance containing the encoded image planes.  This
- method uses the accelerated color conversion routines in TurboJPEG's
- underlying codec but does not execute any of the other steps in the JPEG
- compression process.  Encoding CMYK source images to YUV is not supported.</div>
+ <a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg"><code>YUVImage</code></a> instance containing the encoded image planes.  This
+ method performs color conversion (which is accelerated in the
+ libjpeg-turbo implementation) but does not execute any of the other steps
+ in the JPEG compression process.  Encoding CMYK source images into YUV
+ images is not supported.</div>
 <dl><dt><span class="strong">Parameters:</span></dt><dd><code>strides</code> - an array of integers, each specifying the number of bytes
- per line in the corresponding plane of the output image.  Setting the
- stride for any plane to 0 is the same as setting it to the component width
- of the plane.  If <code>strides</code> is null, then the strides for all
- planes will be set to their respective component widths.  You can adjust
- the strides in order to add an arbitrary amount of line padding to each
- plane.</dd><dd><code>flags</code> - the bitwise OR of one or more of
+ per row in the corresponding plane of the YUV source image.  Setting the
+ stride for any plane to 0 is the same as setting it to the plane width
+ (see <a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg"><code>YUVImage</code></a>.)  If <code>strides</code> is null, then the strides
+ for all planes will be set to their respective plane widths.  You can
+ adjust the strides in order to add an arbitrary amount of row padding to
+ each plane.</dd><dd><code>flags</code> - the bitwise OR of one or more of
  <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#FLAG_BOTTOMUP"><code>TJ.FLAG_*</code></a></dd>
-<dt><span class="strong">Returns:</span></dt><dd>a YUV planar image.</dd>
+<dt><span class="strong">Returns:</span></dt><dd>a <a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg"><code>YUVImage</code></a> instance containing the encoded image planes</dd>
 <dt><span class="strong">Throws:</span></dt>
 <dd><code><a href="../../../org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg">TJException</a></code></dd></dl>
 </li>
diff --git a/java/doc/org/libjpegturbo/turbojpeg/TJCustomFilter.html b/java/doc/org/libjpegturbo/turbojpeg/TJCustomFilter.html
index 412dcd4..982079c 100644
--- a/java/doc/org/libjpegturbo/turbojpeg/TJCustomFilter.html
+++ b/java/doc/org/libjpegturbo/turbojpeg/TJCustomFilter.html
@@ -163,7 +163,7 @@
  into multiple DCT coefficient buffers and call the callback function once
  for each buffer.</dd><dd><code>planeRegion</code> - rectangle containing the width and height of the
  component plane to which <code>coeffBuffer</code> belongs</dd><dd><code>componentID</code> - ID number of the component plane to which
- <code>coeffBuffer</code> belongs (Y, Cb, and Cr have, respectively, ID's
+ <code>coeffBuffer</code> belongs.  (Y, Cb, and Cr have, respectively, ID's
  of 0, 1, and 2 in typical JPEG images.)</dd><dd><code>transformID</code> - ID number of the transformed image to which
  <code>coeffBuffer</code> belongs.  This is the same as the index of the
  transform in the <code>transforms</code> array that was passed to <a href="../../../org/libjpegturbo/turbojpeg/TJTransformer.html#transform(byte[][],%20org.libjpegturbo.turbojpeg.TJTransform[],%20int)"><code>TJTransformer.transform()</code></a>.</dd><dd><code>transform</code> - a <a href="../../../org/libjpegturbo/turbojpeg/TJTransform.html" title="class in org.libjpegturbo.turbojpeg"><code>TJTransform</code></a> instance that specifies the
diff --git a/java/doc/org/libjpegturbo/turbojpeg/TJDecompressor.html b/java/doc/org/libjpegturbo/turbojpeg/TJDecompressor.html
index 6666e4e..77a7ab6 100644
--- a/java/doc/org/libjpegturbo/turbojpeg/TJDecompressor.html
+++ b/java/doc/org/libjpegturbo/turbojpeg/TJDecompressor.html
@@ -180,20 +180,22 @@ implements java.io.Closeable</pre>
 <tr class="rowColor">
 <td class="colOne"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJDecompressor.html#TJDecompressor(byte[])">TJDecompressor</a></strong>(byte[]&nbsp;jpegImage)</code>
 <div class="block">Create a TurboJPEG decompressor instance and associate the JPEG source
- image stored in <code>jpegImage</code> with the newly created instance.</div>
+ image or "abbreviated table specification" (AKA "tables-only") datastream
+ stored in <code>jpegImage</code> with the newly created instance.</div>
 </td>
 </tr>
 <tr class="altColor">
 <td class="colOne"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJDecompressor.html#TJDecompressor(byte[],%20int)">TJDecompressor</a></strong>(byte[]&nbsp;jpegImage,
               int&nbsp;imageSize)</code>
 <div class="block">Create a TurboJPEG decompressor instance and associate the JPEG source
- image of length <code>imageSize</code> bytes stored in
- <code>jpegImage</code> with the newly created instance.</div>
+ image or "abbreviated table specification" (AKA "tables-only") datastream
+ of length <code>imageSize</code> bytes stored in <code>jpegImage</code>
+ with the newly created instance.</div>
 </td>
 </tr>
 <tr class="rowColor">
 <td class="colOne"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJDecompressor.html#TJDecompressor(org.libjpegturbo.turbojpeg.YUVImage)">TJDecompressor</a></strong>(<a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg">YUVImage</a>&nbsp;yuvImage)</code>
-<div class="block">Create a TurboJPEG decompressor instance and associate the YUV planar
+<div class="block">Create a TurboJPEG decompressor instance and associate the planar YUV
  source image stored in <code>yuvImage</code> with the newly created
  instance.</div>
 </td>
@@ -223,9 +225,10 @@ implements java.io.Closeable</pre>
 <td class="colFirst"><code>void</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJDecompressor.html#decompress(java.awt.image.BufferedImage,%20int)">decompress</a></strong>(java.awt.image.BufferedImage&nbsp;dstImage,
           int&nbsp;flags)</code>
-<div class="block">Decompress the JPEG source image or decode the YUV source image associated
- with this decompressor instance and output a decompressed/decoded image to
- the given <code>BufferedImage</code> instance.</div>
+<div class="block">Decompress the JPEG source image or decode the planar YUV source image
+ associated with this decompressor instance and output a packed-pixel
+ decompressed/decoded image to the given <code>BufferedImage</code>
+ instance.</div>
 </td>
 </tr>
 <tr class="altColor">
@@ -252,9 +255,9 @@ implements java.io.Closeable</pre>
           int&nbsp;desiredHeight,
           int&nbsp;pixelFormat,
           int&nbsp;flags)</code>
-<div class="block">Decompress the JPEG source image or decode the YUV source image associated
- with this decompressor instance and output a grayscale, RGB, or CMYK image
- to the given destination buffer.</div>
+<div class="block">Decompress the JPEG source image or decode the planar YUV source image
+ associated with this decompressor instance and output a packed-pixel
+ grayscale, RGB, or CMYK image to the given destination buffer.</div>
 </td>
 </tr>
 <tr class="altColor">
@@ -267,9 +270,9 @@ implements java.io.Closeable</pre>
           int&nbsp;desiredHeight,
           int&nbsp;pixelFormat,
           int&nbsp;flags)</code>
-<div class="block">Decompress the JPEG source image or decode the YUV source image associated
- with this decompressor instance and output a grayscale, RGB, or CMYK image
- to the given destination buffer.</div>
+<div class="block">Decompress the JPEG source image or decode the planar YUV source image
+ associated with this decompressor instance and output a packed-pixel
+ grayscale, RGB, or CMYK image to the given destination buffer.</div>
 </td>
 </tr>
 <tr class="rowColor">
@@ -278,9 +281,10 @@ implements java.io.Closeable</pre>
           int&nbsp;desiredHeight,
           int&nbsp;bufferedImageType,
           int&nbsp;flags)</code>
-<div class="block">Decompress the JPEG source image or decode the YUV source image associated
- with this decompressor instance and return a <code>BufferedImage</code>
- instance containing the decompressed/decoded image.</div>
+<div class="block">Decompress the JPEG source image or decode the planar YUV source image
+ associated with this decompressor instance and return a
+ <code>BufferedImage</code> instance containing the packed-pixel
+ decompressed/decoded image.</div>
 </td>
 </tr>
 <tr class="altColor">
@@ -290,8 +294,9 @@ implements java.io.Closeable</pre>
           int&nbsp;desiredHeight,
           int&nbsp;pixelFormat,
           int&nbsp;flags)</code>
-<div class="block">Decompress the JPEG source image associated with this decompressor
- instance and return a buffer containing the decompressed image.</div>
+<div class="block">Decompress the JPEG source image or decode the planar YUV source image
+ associated with this decompressor instance and return a buffer containing
+ the packed-pixel decompressed image.</div>
 </td>
 </tr>
 <tr class="rowColor">
@@ -319,18 +324,18 @@ implements java.io.Closeable</pre>
                int&nbsp;flags)</code>
 <div class="block">Decompress the JPEG source image associated with this decompressor
  instance into a set of Y, U (Cb), and V (Cr) image planes and return a
- <code>YUVImage</code> instance containing the decompressed image planes.</div>
+ <a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg"><code>YUVImage</code></a> instance containing the decompressed image planes.</div>
 </td>
 </tr>
 <tr class="altColor">
 <td class="colFirst"><code><a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg">YUVImage</a></code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJDecompressor.html#decompressToYUV(int,%20int,%20int,%20int)">decompressToYUV</a></strong>(int&nbsp;desiredWidth,
-               int&nbsp;pad,
+               int&nbsp;align,
                int&nbsp;desiredHeight,
                int&nbsp;flags)</code>
 <div class="block">Decompress the JPEG source image associated with this decompressor
- instance into a unified YUV planar image buffer and return a
- <code>YUVImage</code> instance containing the decompressed image.</div>
+ instance into a unified planar YUV image and return a <a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg"><code>YUVImage</code></a>
+ instance containing the decompressed image.</div>
 </td>
 </tr>
 <tr class="rowColor">
@@ -338,8 +343,8 @@ implements java.io.Closeable</pre>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJDecompressor.html#decompressToYUV(org.libjpegturbo.turbojpeg.YUVImage,%20int)">decompressToYUV</a></strong>(<a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg">YUVImage</a>&nbsp;dstImage,
                int&nbsp;flags)</code>
 <div class="block">Decompress the JPEG source image associated with this decompressor
- instance into a YUV planar image and store it in the given
- <code>YUVImage</code> instance.</div>
+ instance into a planar YUV image and store it in the given
+ <a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg"><code>YUVImage</code></a> instance.</div>
 </td>
 </tr>
 <tr class="altColor">
@@ -363,7 +368,7 @@ implements java.io.Closeable</pre>
 <tr class="rowColor">
 <td class="colFirst"><code>byte[]</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJDecompressor.html#getJPEGBuf()">getJPEGBuf</a></strong>()</code>
-<div class="block">Returns the JPEG image buffer associated with this decompressor instance.</div>
+<div class="block">Returns the JPEG buffer associated with this decompressor instance.</div>
 </td>
 </tr>
 <tr class="altColor">
@@ -426,7 +431,7 @@ implements java.io.Closeable</pre>
 <tr class="rowColor">
 <td class="colFirst"><code>void</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJDecompressor.html#setSourceImage(org.libjpegturbo.turbojpeg.YUVImage)">setSourceImage</a></strong>(<a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg">YUVImage</a>&nbsp;srcImage)</code>
-<div class="block">Associate the specified YUV planar source image with this decompressor
+<div class="block">Associate the specified planar YUV source image with this decompressor
  instance.</div>
 </td>
 </tr>
@@ -554,9 +559,11 @@ implements java.io.Closeable</pre>
 <pre>public&nbsp;TJDecompressor(byte[]&nbsp;jpegImage)
                throws <a href="../../../org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg">TJException</a></pre>
 <div class="block">Create a TurboJPEG decompressor instance and associate the JPEG source
- image stored in <code>jpegImage</code> with the newly created instance.</div>
-<dl><dt><span class="strong">Parameters:</span></dt><dd><code>jpegImage</code> - JPEG image buffer (size of the JPEG image is assumed to
- be the length of the array.)  This buffer is not modified.</dd>
+ image or "abbreviated table specification" (AKA "tables-only") datastream
+ stored in <code>jpegImage</code> with the newly created instance.</div>
+<dl><dt><span class="strong">Parameters:</span></dt><dd><code>jpegImage</code> - buffer containing a JPEG source image or tables-only
+ datastream.  (The size of the JPEG image or datastream is assumed to be
+ the length of the array.)  This buffer is not modified.</dd>
 <dt><span class="strong">Throws:</span></dt>
 <dd><code><a href="../../../org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg">TJException</a></code></dd></dl>
 </li>
@@ -571,9 +578,12 @@ implements java.io.Closeable</pre>
               int&nbsp;imageSize)
                throws <a href="../../../org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg">TJException</a></pre>
 <div class="block">Create a TurboJPEG decompressor instance and associate the JPEG source
- image of length <code>imageSize</code> bytes stored in
- <code>jpegImage</code> with the newly created instance.</div>
-<dl><dt><span class="strong">Parameters:</span></dt><dd><code>jpegImage</code> - JPEG image buffer.  This buffer is not modified.</dd><dd><code>imageSize</code> - size of the JPEG image (in bytes)</dd>
+ image or "abbreviated table specification" (AKA "tables-only") datastream
+ of length <code>imageSize</code> bytes stored in <code>jpegImage</code>
+ with the newly created instance.</div>
+<dl><dt><span class="strong">Parameters:</span></dt><dd><code>jpegImage</code> - buffer containing a JPEG source image or tables-only
+ datastream.  This buffer is not modified.</dd><dd><code>imageSize</code> - size of the JPEG source image or tables-only datastream
+ (in bytes)</dd>
 <dt><span class="strong">Throws:</span></dt>
 <dd><code><a href="../../../org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg">TJException</a></code></dd></dl>
 </li>
@@ -586,10 +596,10 @@ implements java.io.Closeable</pre>
 <h4>TJDecompressor</h4>
 <pre>public&nbsp;TJDecompressor(<a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg">YUVImage</a>&nbsp;yuvImage)
                throws <a href="../../../org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg">TJException</a></pre>
-<div class="block">Create a TurboJPEG decompressor instance and associate the YUV planar
+<div class="block">Create a TurboJPEG decompressor instance and associate the planar YUV
  source image stored in <code>yuvImage</code> with the newly created
  instance.</div>
-<dl><dt><span class="strong">Parameters:</span></dt><dd><code>yuvImage</code> - <a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg"><code>YUVImage</code></a> instance containing a YUV planar
+<dl><dt><span class="strong">Parameters:</span></dt><dd><code>yuvImage</code> - <a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg"><code>YUVImage</code></a> instance containing a planar YUV source
  image to be decoded.  This image is not modified.</dd>
 <dt><span class="strong">Throws:</span></dt>
 <dd><code><a href="../../../org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg">TJException</a></code></dd></dl>
@@ -616,15 +626,15 @@ implements java.io.Closeable</pre>
  "tables-only") datastream of length <code>imageSize</code> bytes stored in
  <code>jpegImage</code> with this decompressor instance.  If
  <code>jpegImage</code> contains a JPEG image, then this image will be used
- as the source image for subsequent decompress operations.  Passing a
+ as the source image for subsequent decompression operations.  Passing a
  tables-only datastream to this method primes the decompressor with
  quantization and Huffman tables that can be used when decompressing
  subsequent "abbreviated image" datastreams.  This is useful, for instance,
  when decompressing video streams in which all frames share the same
  quantization and Huffman tables.</div>
-<dl><dt><span class="strong">Parameters:</span></dt><dd><code>jpegImage</code> - buffer containing a JPEG image or an "abbreviated table
- specification" (AKA "tables-only") datastream.  This buffer is not
- modified.</dd><dd><code>imageSize</code> - size of the JPEG image (in bytes)</dd>
+<dl><dt><span class="strong">Parameters:</span></dt><dd><code>jpegImage</code> - buffer containing a JPEG source image or tables-only
+ datastream.  This buffer is not modified.</dd><dd><code>imageSize</code> - size of the JPEG source image or tables-only datastream
+ (in bytes)</dd>
 <dt><span class="strong">Throws:</span></dt>
 <dd><code><a href="../../../org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg">TJException</a></code></dd></dl>
 </li>
@@ -651,11 +661,11 @@ public&nbsp;void&nbsp;setJPEGImage(byte[]&nbsp;jpegImage,
 <li class="blockList">
 <h4>setSourceImage</h4>
 <pre>public&nbsp;void&nbsp;setSourceImage(<a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg">YUVImage</a>&nbsp;srcImage)</pre>
-<div class="block">Associate the specified YUV planar source image with this decompressor
- instance.  Subsequent decompress operations will decode this image into an
- RGB or grayscale destination image.</div>
-<dl><dt><span class="strong">Parameters:</span></dt><dd><code>srcImage</code> - <a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg"><code>YUVImage</code></a> instance containing a YUV planar image to
- be decoded.  This image is not modified.</dd></dl>
+<div class="block">Associate the specified planar YUV source image with this decompressor
+ instance.  Subsequent decompression operations will decode this image into
+ a packed-pixel RGB or grayscale destination image.</div>
+<dl><dt><span class="strong">Parameters:</span></dt><dd><code>srcImage</code> - <a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg"><code>YUVImage</code></a> instance containing a planar YUV source
+ image to be decoded.  This image is not modified.</dd></dl>
 </li>
 </ul>
 <a name="getWidth()">
@@ -719,8 +729,8 @@ public&nbsp;void&nbsp;setJPEGImage(byte[]&nbsp;jpegImage,
 <li class="blockList">
 <h4>getJPEGBuf</h4>
 <pre>public&nbsp;byte[]&nbsp;getJPEGBuf()</pre>
-<div class="block">Returns the JPEG image buffer associated with this decompressor instance.</div>
-<dl><dt><span class="strong">Returns:</span></dt><dd>the JPEG image buffer associated with this decompressor instance.</dd></dl>
+<div class="block">Returns the JPEG buffer associated with this decompressor instance.</div>
+<dl><dt><span class="strong">Returns:</span></dt><dd>the JPEG buffer associated with this decompressor instance.</dd></dl>
 </li>
 </ul>
 <a name="getJPEGSize()">
@@ -748,12 +758,12 @@ public&nbsp;void&nbsp;setJPEGImage(byte[]&nbsp;jpegImage,
  decompressor can generate without exceeding the desired image width and
  height.</div>
 <dl><dt><span class="strong">Parameters:</span></dt><dd><code>desiredWidth</code> - desired width (in pixels) of the decompressed image.
- Setting this to 0 is the same as setting it to the width of the JPEG image
- (in other words, the width will not be considered when determining the
- scaled image size.)</dd><dd><code>desiredHeight</code> - desired height (in pixels) of the decompressed image.
+ Setting this to 0 is the same as setting it to the width of the JPEG
+ image.  (In other words, the width will not be considered when determining
+ the scaled image size.)</dd><dd><code>desiredHeight</code> - desired height (in pixels) of the decompressed image.
  Setting this to 0 is the same as setting it to the height of the JPEG
- image (in other words, the height will not be considered when determining
- the scaled image size.)</dd>
+ image.  (In other words, the height will not be considered when
+ determining the scaled image size.)</dd>
 <dt><span class="strong">Returns:</span></dt><dd>the width of the largest scaled-down image that the TurboJPEG
  decompressor can generate without exceeding the desired image width and
  height.</dd></dl>
@@ -771,12 +781,12 @@ public&nbsp;void&nbsp;setJPEGImage(byte[]&nbsp;jpegImage,
  decompressor can generate without exceeding the desired image width and
  height.</div>
 <dl><dt><span class="strong">Parameters:</span></dt><dd><code>desiredWidth</code> - desired width (in pixels) of the decompressed image.
- Setting this to 0 is the same as setting it to the width of the JPEG image
- (in other words, the width will not be considered when determining the
- scaled image size.)</dd><dd><code>desiredHeight</code> - desired height (in pixels) of the decompressed image.
+ Setting this to 0 is the same as setting it to the width of the JPEG
+ image.  (In other words, the width will not be considered when determining
+ the scaled image size.)</dd><dd><code>desiredHeight</code> - desired height (in pixels) of the decompressed image.
  Setting this to 0 is the same as setting it to the height of the JPEG
- image (in other words, the height will not be considered when determining
- the scaled image size.)</dd>
+ image.  (In other words, the height will not be considered when
+ determining the scaled image size.)</dd>
 <dt><span class="strong">Returns:</span></dt><dd>the height of the largest scaled-down image that the TurboJPEG
  decompressor can generate without exceeding the desired image width and
  height.</dd></dl>
@@ -797,25 +807,26 @@ public&nbsp;void&nbsp;setJPEGImage(byte[]&nbsp;jpegImage,
               int&nbsp;pixelFormat,
               int&nbsp;flags)
                 throws <a href="../../../org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg">TJException</a></pre>
-<div class="block">Decompress the JPEG source image or decode the YUV source image associated
- with this decompressor instance and output a grayscale, RGB, or CMYK image
- to the given destination buffer.
+<div class="block">Decompress the JPEG source image or decode the planar YUV source image
+ associated with this decompressor instance and output a packed-pixel
+ grayscale, RGB, or CMYK image to the given destination buffer.
  <p>
- NOTE: The output image is fully recoverable if this method throws a
+ NOTE: The destination image is fully recoverable if this method throws a
  non-fatal <a href="../../../org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg"><code>TJException</code></a> (unless
  <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#FLAG_STOPONWARNING"><code>TJ.FLAG_STOPONWARNING</code></a> is specified.)</div>
-<dl><dt><span class="strong">Parameters:</span></dt><dd><code>dstBuf</code> - buffer that will receive the decompressed/decoded image.
- If the source image is a JPEG image, then this buffer should normally be
- <code>pitch * scaledHeight</code> bytes in size, where
- <code>scaledHeight</code> can be determined by calling <code>
- scalingFactor.<a href="../../../org/libjpegturbo/turbojpeg/TJScalingFactor.html#getScaled(int)"><code>getScaled</code></a>(jpegHeight)
- </code> with one of the scaling factors returned from <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#getScalingFactors()"><code>TJ.getScalingFactors()</code></a> or by calling <a href="../../../org/libjpegturbo/turbojpeg/TJDecompressor.html#getScaledHeight(int,%20int)"><code>getScaledHeight(int, int)</code></a>.  If the
- source image is a YUV image, then this buffer should normally be
- <code>pitch * height</code> bytes in size, where <code>height</code> is
- the height of the YUV image.  However, the buffer may also be larger than
- the dimensions of the source image, in which case the <code>x</code>,
- <code>y</code>, and <code>pitch</code> parameters can be used to specify
- the region into which the source image should be decompressed/decoded.</dd><dd><code>x</code> - x offset (in pixels) of the region in the destination image into
+<dl><dt><span class="strong">Parameters:</span></dt><dd><code>dstBuf</code> - buffer that will receive the packed-pixel
+ decompressed/decoded image.  If the source image is a JPEG image, then
+ this buffer should normally be <code>pitch * scaledHeight</code> bytes in
+ size, where <code>scaledHeight</code> can be determined by calling
+ <code>scalingFactor.</code><a href="../../../org/libjpegturbo/turbojpeg/TJScalingFactor.html#getScaled(int)"><code>getScaled</code></a><code>(jpegHeight)</code>
+ with one of the scaling factors returned from <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#getScalingFactors()"><code>TJ.getScalingFactors()</code></a>
+ or by calling <a href="../../../org/libjpegturbo/turbojpeg/TJDecompressor.html#getScaledHeight(int,%20int)"><code>getScaledHeight(int, int)</code></a>.  If the source image is a YUV
+ image, then this buffer should normally be <code>pitch * height</code>
+ bytes in size, where <code>height</code> is the height of the YUV image.
+ However, the buffer may also be larger than the dimensions of the source
+ image, in which case the <code>x</code>, <code>y</code>, and
+ <code>pitch</code> parameters can be used to specify the region into which
+ the source image should be decompressed/decoded.</dd><dd><code>x</code> - x offset (in pixels) of the region in the destination image into
  which the source image should be decompressed/decoded</dd><dd><code>y</code> - y offset (in pixels) of the region in the destination image into
  which the source image should be decompressed/decoded</dd><dd><code>desiredWidth</code> - If the source image is a JPEG image, then this
  specifies the desired width (in pixels) of the decompressed image (or
@@ -823,27 +834,29 @@ public&nbsp;void&nbsp;setJPEGImage(byte[]&nbsp;jpegImage,
  than the source image dimensions, then TurboJPEG will use scaling in the
  JPEG decompressor to generate the largest possible image that will fit
  within the desired dimensions.  Setting this to 0 is the same as setting
- it to the width of the JPEG image (in other words, the width will not be
+ it to the width of the JPEG image.  (In other words, the width will not be
  considered when determining the scaled image size.)  This parameter is
- ignored if the source image is a YUV image.</dd><dd><code>pitch</code> - bytes per line of the destination image.  Normally, this
- should be set to <code>scaledWidth * TJ.pixelSize(pixelFormat)</code> if
- the destination image is unpadded, but you can use this to, for instance,
- pad each line of the destination image to a 4-byte boundary or to
- decompress/decode the source image into a region of a larger image.  NOTE:
- if the source image is a JPEG image, then <code>scaledWidth</code> can be
- determined by calling <code>
- scalingFactor.<a href="../../../org/libjpegturbo/turbojpeg/TJScalingFactor.html#getScaled(int)"><code>getScaled</code></a>(jpegWidth)
- </code> or by calling <a href="../../../org/libjpegturbo/turbojpeg/TJDecompressor.html#getScaledWidth(int,%20int)"><code>getScaledWidth(int, int)</code></a>.  If the source image is a
- YUV image, then <code>scaledWidth</code> is the width of the YUV image.
+ ignored if the source image is a YUV image.</dd><dd><code>pitch</code> - bytes per row in the destination image.  Normally this should
+ be set to <code>scaledWidth *
+ </code><a href="../../../org/libjpegturbo/turbojpeg/TJ.html#getPixelSize(int)"><code>TJ.getPixelSize</code></a><code>(pixelFormat)</code>,
+ if the destination image will be unpadded.  However, you can use this to,
+ for instance, pad each row of the destination image to the nearest
+ multiple of 4 bytes or to decompress/decode the source image into a region
+ of a larger image.  NOTE: if the source image is a JPEG image, then
+ <code>scaledWidth</code> can be determined by calling
+ <code>scalingFactor.</code><a href="../../../org/libjpegturbo/turbojpeg/TJScalingFactor.html#getScaled(int)"><code>getScaled</code></a><code>(jpegWidth)</code>
+ or by calling <a href="../../../org/libjpegturbo/turbojpeg/TJDecompressor.html#getScaledWidth(int,%20int)"><code>getScaledWidth(int, int)</code></a>.  If the source image is a YUV
+ image, then <code>scaledWidth</code> is the width of the YUV image.
  Setting this parameter to 0 is the equivalent of setting it to
- <code>scaledWidth * TJ.pixelSize(pixelFormat)</code>.</dd><dd><code>desiredHeight</code> - If the source image is a JPEG image, then this
+ <code>scaledWidth *
+ </code><a href="../../../org/libjpegturbo/turbojpeg/TJ.html#getPixelSize(int)"><code>TJ.getPixelSize</code></a><code>(pixelFormat)</code>.</dd><dd><code>desiredHeight</code> - If the source image is a JPEG image, then this
  specifies the desired height (in pixels) of the decompressed image (or
  image region.)  If the desired destination image dimensions are different
  than the source image dimensions, then TurboJPEG will use scaling in the
  JPEG decompressor to generate the largest possible image that will fit
  within the desired dimensions.  Setting this to 0 is the same as setting
- it to the height of the JPEG image (in other words, the height will not be
- considered when determining the scaled image size.)  This parameter is
+ it to the height of the JPEG image.  (In other words, the height will not
+ be considered when determining the scaled image size.)  This parameter is
  ignored if the source image is a YUV image.</dd><dd><code>pixelFormat</code> - pixel format of the decompressed/decoded image (one of
  <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#PF_RGB"><code>TJ.PF_*</code></a>)</dd><dd><code>flags</code> - the bitwise OR of one or more of
  <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#FLAG_BOTTOMUP"><code>TJ.FLAG_*</code></a></dd>
@@ -883,8 +896,9 @@ public&nbsp;void&nbsp;decompress(byte[]&nbsp;dstBuf,
                 int&nbsp;pixelFormat,
                 int&nbsp;flags)
                   throws <a href="../../../org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg">TJException</a></pre>
-<div class="block">Decompress the JPEG source image associated with this decompressor
- instance and return a buffer containing the decompressed image.</div>
+<div class="block">Decompress the JPEG source image or decode the planar YUV source image
+ associated with this decompressor instance and return a buffer containing
+ the packed-pixel decompressed image.</div>
 <dl><dt><span class="strong">Parameters:</span></dt><dd><code>desiredWidth</code> - see
  <a href="../../../org/libjpegturbo/turbojpeg/TJDecompressor.html#decompress(byte[],%20int,%20int,%20int,%20int,%20int,%20int,%20int)"><code>decompress(byte[], int, int, int, int, int, int, int)</code></a>
  for description</dd><dd><code>pitch</code> - see
@@ -894,7 +908,7 @@ public&nbsp;void&nbsp;decompress(byte[]&nbsp;dstBuf,
  for description</dd><dd><code>pixelFormat</code> - pixel format of the decompressed image (one of
  <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#PF_RGB"><code>TJ.PF_*</code></a>)</dd><dd><code>flags</code> - the bitwise OR of one or more of
  <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#FLAG_BOTTOMUP"><code>TJ.FLAG_*</code></a></dd>
-<dt><span class="strong">Returns:</span></dt><dd>a buffer containing the decompressed image.</dd>
+<dt><span class="strong">Returns:</span></dt><dd>a buffer containing the packed-pixel decompressed image.</dd>
 <dt><span class="strong">Throws:</span></dt>
 <dd><code><a href="../../../org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg">TJException</a></code></dd></dl>
 </li>
@@ -909,21 +923,21 @@ public&nbsp;void&nbsp;decompress(byte[]&nbsp;dstBuf,
                    int&nbsp;flags)
                      throws <a href="../../../org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg">TJException</a></pre>
 <div class="block">Decompress the JPEG source image associated with this decompressor
- instance into a YUV planar image and store it in the given
- <code>YUVImage</code> instance.  This method performs JPEG decompression
- but leaves out the color conversion step, so a planar YUV image is
- generated instead of an RGB or grayscale image.  This method cannot be
- used to decompress JPEG source images with the CMYK or YCCK colorspace.
+ instance into a planar YUV image and store it in the given
+ <a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg"><code>YUVImage</code></a> instance.  This method performs JPEG decompression but
+ leaves out the color conversion step, so a planar YUV image is generated
+ instead of a packed-pixel image.  This method cannot be used to decompress
+ JPEG source images with the CMYK or YCCK colorspace.
  <p>
- NOTE: The YUV planar output image is fully recoverable if this method
+ NOTE: The planar YUV destination image is fully recoverable if this method
  throws a non-fatal <a href="../../../org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg"><code>TJException</code></a> (unless
  <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#FLAG_STOPONWARNING"><code>TJ.FLAG_STOPONWARNING</code></a> is specified.)</div>
-<dl><dt><span class="strong">Parameters:</span></dt><dd><code>dstImage</code> - <a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg"><code>YUVImage</code></a> instance that will receive the YUV planar
- image.  The level of subsampling specified in this <code>YUVImage</code>
- instance must match that of the JPEG image, and the width and height
- specified in the <code>YUVImage</code> instance must match one of the
- scaled image sizes that TurboJPEG is capable of generating from the JPEG
- source image.</dd><dd><code>flags</code> - the bitwise OR of one or more of
+<dl><dt><span class="strong">Parameters:</span></dt><dd><code>dstImage</code> - <a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg"><code>YUVImage</code></a> instance that will receive the planar YUV
+ decompressed image.  The level of subsampling specified in this
+ <a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg"><code>YUVImage</code></a> instance must match that of the JPEG image, and the width
+ and height specified in the <a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg"><code>YUVImage</code></a> instance must match one of
+ the scaled image sizes that the decompressor is capable of generating from
+ the JPEG source image.</dd><dd><code>flags</code> - the bitwise OR of one or more of
  <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#FLAG_BOTTOMUP"><code>TJ.FLAG_*</code></a></dd>
 <dt><span class="strong">Throws:</span></dt>
 <dd><code><a href="../../../org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg">TJException</a></code></dd></dl>
@@ -957,32 +971,33 @@ public&nbsp;void&nbsp;decompressToYUV(byte[]&nbsp;dstBuf,
                          throws <a href="../../../org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg">TJException</a></pre>
 <div class="block">Decompress the JPEG source image associated with this decompressor
  instance into a set of Y, U (Cb), and V (Cr) image planes and return a
- <code>YUVImage</code> instance containing the decompressed image planes.
- This method performs JPEG decompression but leaves out the color
- conversion step, so a planar YUV image is generated instead of an RGB or
- grayscale image.  This method cannot be used to decompress JPEG source
- images with the CMYK or YCCK colorspace.</div>
+ <a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg"><code>YUVImage</code></a> instance containing the decompressed image planes.  This
+ method performs JPEG decompression but leaves out the color conversion
+ step, so a planar YUV image is generated instead of a packed-pixel image.
+ This method cannot be used to decompress JPEG source images with the CMYK
+ or YCCK colorspace.</div>
 <dl><dt><span class="strong">Parameters:</span></dt><dd><code>desiredWidth</code> - desired width (in pixels) of the YUV image.  If the
  desired image dimensions are different than the dimensions of the JPEG
  image being decompressed, then TurboJPEG will use scaling in the JPEG
  decompressor to generate the largest possible image that will fit within
  the desired dimensions.  Setting this to 0 is the same as setting it to
- the width of the JPEG image (in other words, the width will not be
+ the width of the JPEG image.  (In other words, the width will not be
  considered when determining the scaled image size.)</dd><dd><code>strides</code> - an array of integers, each specifying the number of bytes
- per line in the corresponding plane of the output image.  Setting the
- stride for any plane to 0 is the same as setting it to the scaled
- component width of the plane.  If <tt>strides</tt> is NULL, then the
- strides for all planes will be set to their respective scaled component
- widths.  You can adjust the strides in order to add an arbitrary amount of
- line padding to each plane.</dd><dd><code>desiredHeight</code> - desired height (in pixels) of the YUV image.  If the
+ per row in the corresponding plane of the YUV image.  Setting the stride
+ for any plane to 0 is the same as setting it to the scaled plane width
+ (see <a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg"><code>YUVImage</code></a>.)  If <code>strides</code> is null, then the strides
+ for all planes will be set to their respective scaled plane widths.  You
+ can adjust the strides in order to add an arbitrary amount of row padding
+ to each plane.</dd><dd><code>desiredHeight</code> - desired height (in pixels) of the YUV image.  If the
  desired image dimensions are different than the dimensions of the JPEG
  image being decompressed, then TurboJPEG will use scaling in the JPEG
  decompressor to generate the largest possible image that will fit within
  the desired dimensions.  Setting this to 0 is the same as setting it to
- the height of the JPEG image (in other words, the height will not be
+ the height of the JPEG image.  (In other words, the height will not be
  considered when determining the scaled image size.)</dd><dd><code>flags</code> - the bitwise OR of one or more of
  <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#FLAG_BOTTOMUP"><code>TJ.FLAG_*</code></a></dd>
-<dt><span class="strong">Returns:</span></dt><dd>a YUV planar image.</dd>
+<dt><span class="strong">Returns:</span></dt><dd>a <a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg"><code>YUVImage</code></a> instance containing the decompressed image
+ planes</dd>
 <dt><span class="strong">Throws:</span></dt>
 <dd><code><a href="../../../org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg">TJException</a></code></dd></dl>
 </li>
@@ -994,34 +1009,34 @@ public&nbsp;void&nbsp;decompressToYUV(byte[]&nbsp;dstBuf,
 <li class="blockList">
 <h4>decompressToYUV</h4>
 <pre>public&nbsp;<a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg">YUVImage</a>&nbsp;decompressToYUV(int&nbsp;desiredWidth,
-                       int&nbsp;pad,
+                       int&nbsp;align,
                        int&nbsp;desiredHeight,
                        int&nbsp;flags)
                          throws <a href="../../../org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg">TJException</a></pre>
 <div class="block">Decompress the JPEG source image associated with this decompressor
- instance into a unified YUV planar image buffer and return a
- <code>YUVImage</code> instance containing the decompressed image.  This
- method performs JPEG decompression but leaves out the color conversion
- step, so a planar YUV image is generated instead of an RGB or grayscale
- image.  This method cannot be used to decompress JPEG source images with
- the CMYK or YCCK colorspace.</div>
+ instance into a unified planar YUV image and return a <a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg"><code>YUVImage</code></a>
+ instance containing the decompressed image.  This method performs JPEG
+ decompression but leaves out the color conversion step, so a planar YUV
+ image is generated instead of a packed-pixel image.  This method cannot be
+ used to decompress JPEG source images with the CMYK or YCCK colorspace.</div>
 <dl><dt><span class="strong">Parameters:</span></dt><dd><code>desiredWidth</code> - desired width (in pixels) of the YUV image.  If the
  desired image dimensions are different than the dimensions of the JPEG
  image being decompressed, then TurboJPEG will use scaling in the JPEG
  decompressor to generate the largest possible image that will fit within
  the desired dimensions.  Setting this to 0 is the same as setting it to
- the width of the JPEG image (in other words, the width will not be
- considered when determining the scaled image size.)</dd><dd><code>pad</code> - the width of each line in each plane of the YUV image will be
- padded to the nearest multiple of this number of bytes (must be a power of
- 2.)</dd><dd><code>desiredHeight</code> - desired height (in pixels) of the YUV image.  If the
+ the width of the JPEG image.  (In other words, the width will not be
+ considered when determining the scaled image size.)</dd><dd><code>align</code> - row alignment (in bytes) of the YUV image (must be a power of
+ 2.)  Setting this parameter to n will cause each row in each plane of the
+ YUV image to be padded to the nearest multiple of n bytes (1 = unpadded.)</dd><dd><code>desiredHeight</code> - desired height (in pixels) of the YUV image.  If the
  desired image dimensions are different than the dimensions of the JPEG
  image being decompressed, then TurboJPEG will use scaling in the JPEG
  decompressor to generate the largest possible image that will fit within
  the desired dimensions.  Setting this to 0 is the same as setting it to
- the height of the JPEG image (in other words, the height will not be
+ the height of the JPEG image.  (In other words, the height will not be
  considered when determining the scaled image size.)</dd><dd><code>flags</code> - the bitwise OR of one or more of
  <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#FLAG_BOTTOMUP"><code>TJ.FLAG_*</code></a></dd>
-<dt><span class="strong">Returns:</span></dt><dd>a YUV planar image.</dd>
+<dt><span class="strong">Returns:</span></dt><dd>a <a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg"><code>YUVImage</code></a> instance containing the unified planar YUV
+ decompressed image</dd>
 <dt><span class="strong">Throws:</span></dt>
 <dd><code><a href="../../../org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg">TJException</a></code></dd></dl>
 </li>
@@ -1055,25 +1070,26 @@ public&nbsp;byte[]&nbsp;decompressToYUV(int&nbsp;flags)
               int&nbsp;pixelFormat,
               int&nbsp;flags)
                 throws <a href="../../../org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg">TJException</a></pre>
-<div class="block">Decompress the JPEG source image or decode the YUV source image associated
- with this decompressor instance and output a grayscale, RGB, or CMYK image
- to the given destination buffer.
+<div class="block">Decompress the JPEG source image or decode the planar YUV source image
+ associated with this decompressor instance and output a packed-pixel
+ grayscale, RGB, or CMYK image to the given destination buffer.
  <p>
- NOTE: The output image is fully recoverable if this method throws a
+ NOTE: The destination image is fully recoverable if this method throws a
  non-fatal <a href="../../../org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg"><code>TJException</code></a> (unless
  <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#FLAG_STOPONWARNING"><code>TJ.FLAG_STOPONWARNING</code></a> is specified.)</div>
-<dl><dt><span class="strong">Parameters:</span></dt><dd><code>dstBuf</code> - buffer that will receive the decompressed/decoded image.
- If the source image is a JPEG image, then this buffer should normally be
- <code>stride * scaledHeight</code> pixels in size, where
- <code>scaledHeight</code> can be determined by calling <code>
- scalingFactor.<a href="../../../org/libjpegturbo/turbojpeg/TJScalingFactor.html#getScaled(int)"><code>getScaled</code></a>(jpegHeight)
- </code> with one of the scaling factors returned from <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#getScalingFactors()"><code>TJ.getScalingFactors()</code></a> or by calling <a href="../../../org/libjpegturbo/turbojpeg/TJDecompressor.html#getScaledHeight(int,%20int)"><code>getScaledHeight(int, int)</code></a>.  If the
- source image is a YUV image, then this buffer should normally be
- <code>stride * height</code> pixels in size, where <code>height</code> is
- the height of the YUV image.  However, the buffer may also be larger than
- the dimensions of the JPEG image, in which case the <code>x</code>,
- <code>y</code>, and <code>stride</code> parameters can be used to specify
- the region into which the source image should be decompressed.</dd><dd><code>x</code> - x offset (in pixels) of the region in the destination image into
+<dl><dt><span class="strong">Parameters:</span></dt><dd><code>dstBuf</code> - buffer that will receive the packed-pixel
+ decompressed/decoded image.  If the source image is a JPEG image, then
+ this buffer should normally be <code>stride * scaledHeight</code> pixels
+ in size, where <code>scaledHeight</code> can be determined by calling
+ <code>scalingFactor.</code><a href="../../../org/libjpegturbo/turbojpeg/TJScalingFactor.html#getScaled(int)"><code>getScaled</code></a><code>(jpegHeight)</code>
+ with one of the scaling factors returned from <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#getScalingFactors()"><code>TJ.getScalingFactors()</code></a>
+ or by calling <a href="../../../org/libjpegturbo/turbojpeg/TJDecompressor.html#getScaledHeight(int,%20int)"><code>getScaledHeight(int, int)</code></a>.  If the source image is a YUV
+ image, then this buffer should normally be <code>stride * height</code>
+ pixels in size, where <code>height</code> is the height of the YUV image.
+ However, the buffer may also be larger than the dimensions of the JPEG
+ image, in which case the <code>x</code>, <code>y</code>, and
+ <code>stride</code> parameters can be used to specify the region into
+ which the source image should be decompressed.</dd><dd><code>x</code> - x offset (in pixels) of the region in the destination image into
  which the source image should be decompressed/decoded</dd><dd><code>y</code> - y offset (in pixels) of the region in the destination image into
  which the source image should be decompressed/decoded</dd><dd><code>desiredWidth</code> - If the source image is a JPEG image, then this
  specifies the desired width (in pixels) of the decompressed image (or
@@ -1081,16 +1097,16 @@ public&nbsp;byte[]&nbsp;decompressToYUV(int&nbsp;flags)
  than the source image dimensions, then TurboJPEG will use scaling in the
  JPEG decompressor to generate the largest possible image that will fit
  within the desired dimensions.  Setting this to 0 is the same as setting
- it to the width of the JPEG image (in other words, the width will not be
+ it to the width of the JPEG image.  (In other words, the width will not be
  considered when determining the scaled image size.)  This parameter is
- ignored if the source image is a YUV image.</dd><dd><code>stride</code> - pixels per line of the destination image.  Normally, this
+ ignored if the source image is a YUV image.</dd><dd><code>stride</code> - pixels per row in the destination image.  Normally this
  should be set to <code>scaledWidth</code>, but you can use this to, for
  instance, decompress the JPEG image into a region of a larger image.
  NOTE: if the source image is a JPEG image, then <code>scaledWidth</code>
- can be determined by calling <code>
- scalingFactor.<a href="../../../org/libjpegturbo/turbojpeg/TJScalingFactor.html#getScaled(int)"><code>getScaled</code></a>(jpegWidth)
- </code> or by calling <a href="../../../org/libjpegturbo/turbojpeg/TJDecompressor.html#getScaledWidth(int,%20int)"><code>getScaledWidth(int, int)</code></a>.  If the source image is a
- YUV image, then <code>scaledWidth</code> is the width of the YUV image.
+ can be determined by calling
+ <code>scalingFactor.</code><a href="../../../org/libjpegturbo/turbojpeg/TJScalingFactor.html#getScaled(int)"><code>getScaled</code></a><code>(jpegWidth)</code>
+ or by calling <a href="../../../org/libjpegturbo/turbojpeg/TJDecompressor.html#getScaledWidth(int,%20int)"><code>getScaledWidth(int, int)</code></a>.  If the source image is a YUV
+ image, then <code>scaledWidth</code> is the width of the YUV image.
  Setting this parameter to 0 is the equivalent of setting it to
  <code>scaledWidth</code>.</dd><dd><code>desiredHeight</code> - If the source image is a JPEG image, then this
  specifies the desired height (in pixels) of the decompressed image (or
@@ -1098,8 +1114,8 @@ public&nbsp;byte[]&nbsp;decompressToYUV(int&nbsp;flags)
  than the source image dimensions, then TurboJPEG will use scaling in the
  JPEG decompressor to generate the largest possible image that will fit
  within the desired dimensions.  Setting this to 0 is the same as setting
- it to the height of the JPEG image (in other words, the height will not be
- considered when determining the scaled image size.)  This parameter is
+ it to the height of the JPEG image.  (In other words, the height will not
+ be considered when determining the scaled image size.)  This parameter is
  ignored if the source image is a YUV image.</dd><dd><code>pixelFormat</code> - pixel format of the decompressed image (one of
  <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#PF_RGB"><code>TJ.PF_*</code></a>)</dd><dd><code>flags</code> - the bitwise OR of one or more of
  <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#FLAG_BOTTOMUP"><code>TJ.FLAG_*</code></a></dd>
@@ -1116,20 +1132,21 @@ public&nbsp;byte[]&nbsp;decompressToYUV(int&nbsp;flags)
 <pre>public&nbsp;void&nbsp;decompress(java.awt.image.BufferedImage&nbsp;dstImage,
               int&nbsp;flags)
                 throws <a href="../../../org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg">TJException</a></pre>
-<div class="block">Decompress the JPEG source image or decode the YUV source image associated
- with this decompressor instance and output a decompressed/decoded image to
- the given <code>BufferedImage</code> instance.
+<div class="block">Decompress the JPEG source image or decode the planar YUV source image
+ associated with this decompressor instance and output a packed-pixel
+ decompressed/decoded image to the given <code>BufferedImage</code>
+ instance.
  <p>
- NOTE: The output image is fully recoverable if this method throws a
+ NOTE: The destination image is fully recoverable if this method throws a
  non-fatal <a href="../../../org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg"><code>TJException</code></a> (unless
  <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#FLAG_STOPONWARNING"><code>TJ.FLAG_STOPONWARNING</code></a> is specified.)</div>
 <dl><dt><span class="strong">Parameters:</span></dt><dd><code>dstImage</code> - a <code>BufferedImage</code> instance that will receive
- the decompressed/decoded image.  If the source image is a JPEG image, then
- the width and height of the <code>BufferedImage</code> instance must match
- one of the scaled image sizes that TurboJPEG is capable of generating from
- the JPEG image.  If the source image is a YUV image, then the width and
- height of the <code>BufferedImage</code> instance must match the width and
- height of the YUV image.</dd><dd><code>flags</code> - the bitwise OR of one or more of
+ the packed-pixel decompressed/decoded image.  If the source image is a
+ JPEG image, then the width and height of the <code>BufferedImage</code>
+ instance must match one of the scaled image sizes that the decompressor is
+ capable of generating from the JPEG image.  If the source image is a YUV
+ image, then the width and height of the <code>BufferedImage</code>
+ instance must match the width and height of the YUV image.</dd><dd><code>flags</code> - the bitwise OR of one or more of
  <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#FLAG_BOTTOMUP"><code>TJ.FLAG_*</code></a></dd>
 <dt><span class="strong">Throws:</span></dt>
 <dd><code><a href="../../../org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg">TJException</a></code></dd></dl>
@@ -1146,9 +1163,10 @@ public&nbsp;byte[]&nbsp;decompressToYUV(int&nbsp;flags)
                                       int&nbsp;bufferedImageType,
                                       int&nbsp;flags)
                                         throws <a href="../../../org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg">TJException</a></pre>
-<div class="block">Decompress the JPEG source image or decode the YUV source image associated
- with this decompressor instance and return a <code>BufferedImage</code>
- instance containing the decompressed/decoded image.</div>
+<div class="block">Decompress the JPEG source image or decode the planar YUV source image
+ associated with this decompressor instance and return a
+ <code>BufferedImage</code> instance containing the packed-pixel
+ decompressed/decoded image.</div>
 <dl><dt><span class="strong">Parameters:</span></dt><dd><code>desiredWidth</code> - see
  <a href="../../../org/libjpegturbo/turbojpeg/TJDecompressor.html#decompress(byte[],%20int,%20int,%20int,%20int,%20int,%20int,%20int)"><code>decompress(byte[], int, int, int, int, int, int, int)</code></a> for
  description</dd><dd><code>desiredHeight</code> - see
@@ -1157,7 +1175,7 @@ public&nbsp;byte[]&nbsp;decompressToYUV(int&nbsp;flags)
  instance that will be created (for instance,
  <code>BufferedImage.TYPE_INT_RGB</code>)</dd><dd><code>flags</code> - the bitwise OR of one or more of
  <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#FLAG_BOTTOMUP"><code>TJ.FLAG_*</code></a></dd>
-<dt><span class="strong">Returns:</span></dt><dd>a <code>BufferedImage</code> instance containing the
+<dt><span class="strong">Returns:</span></dt><dd>a <code>BufferedImage</code> instance containing the packed-pixel
  decompressed/decoded image.</dd>
 <dt><span class="strong">Throws:</span></dt>
 <dd><code><a href="../../../org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg">TJException</a></code></dd></dl>
diff --git a/java/doc/org/libjpegturbo/turbojpeg/TJTransform.html b/java/doc/org/libjpegturbo/turbojpeg/TJTransform.html
index 5f22691..e528d79 100644
--- a/java/doc/org/libjpegturbo/turbojpeg/TJTransform.html
+++ b/java/doc/org/libjpegturbo/turbojpeg/TJTransform.html
@@ -167,7 +167,7 @@ extends java.awt.Rectangle</pre>
 <tr class="altColor">
 <td class="colFirst"><code>int</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJTransform.html#op">op</a></strong></code>
-<div class="block">Transform operation (one of <code>OP_*</code>)</div>
+<div class="block">Transform operation (one of <a href="../../../org/libjpegturbo/turbojpeg/TJTransform.html#OP_NONE"><code>OP_*</code></a>)</div>
 </td>
 </tr>
 <tr class="rowColor">
@@ -223,7 +223,7 @@ extends java.awt.Rectangle</pre>
 <td class="colFirst"><code>static int</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJTransform.html#OPT_COPYNONE">OPT_COPYNONE</a></strong></code>
 <div class="block">This option will prevent <a href="../../../org/libjpegturbo/turbojpeg/TJTransformer.html#transform(byte[][],%20org.libjpegturbo.turbojpeg.TJTransform[],%20int)"><code>TJTransformer.transform()</code></a> from copying any extra markers (including EXIF
- and ICC profile data) from the source image to the output image.</div>
+ and ICC profile data) from the source image to the destination image.</div>
 </td>
 </tr>
 <tr class="altColor">
@@ -235,8 +235,8 @@ extends java.awt.Rectangle</pre>
 <tr class="rowColor">
 <td class="colFirst"><code>static int</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJTransform.html#OPT_GRAY">OPT_GRAY</a></strong></code>
-<div class="block">This option will discard the color data in the input image and produce
- a grayscale output image.</div>
+<div class="block">This option will discard the color data in the source image and produce a
+ grayscale destination image.</div>
 </td>
 </tr>
 <tr class="altColor">
@@ -256,7 +256,7 @@ extends java.awt.Rectangle</pre>
 <tr class="altColor">
 <td class="colFirst"><code>static int</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJTransform.html#OPT_PROGRESSIVE">OPT_PROGRESSIVE</a></strong></code>
-<div class="block">This option will enable progressive entropy coding in the output image
+<div class="block">This option will enable progressive entropy coding in the JPEG image
  generated by this particular transform.</div>
 </td>
 </tr>
@@ -270,7 +270,8 @@ extends java.awt.Rectangle</pre>
 <tr class="altColor">
 <td class="colFirst"><code>int</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJTransform.html#options">options</a></strong></code>
-<div class="block">Transform options (bitwise OR of one or more of <code>OPT_*</code>)</div>
+<div class="block">Transform options (bitwise OR of one or more of
+ <a href="../../../org/libjpegturbo/turbojpeg/TJTransform.html#OPT_PERFECT"><code>OPT_*</code></a>)</div>
 </td>
 </tr>
 </table>
@@ -509,7 +510,7 @@ extends java.awt.Rectangle</pre>
  the level of chrominance subsampling used.  If the image's width or height
  is not evenly divisible by the MCU block size (see <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#getMCUWidth(int)"><code>TJ.getMCUWidth(int)</code></a>
  and <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#getMCUHeight(int)"><code>TJ.getMCUHeight(int)</code></a>), then there will be partial MCU blocks on the
- right and/or bottom edges.   It is not possible to move these partial MCU
+ right and/or bottom edges.  It is not possible to move these partial MCU
  blocks to the top or left of the image, so any transform that would
  require that is "imperfect."  If this option is not specified, then any
  partial MCU blocks that cannot be transformed will be left in place, which
@@ -547,8 +548,8 @@ extends java.awt.Rectangle</pre>
 <li class="blockList">
 <h4>OPT_GRAY</h4>
 <pre>public static final&nbsp;int OPT_GRAY</pre>
-<div class="block">This option will discard the color data in the input image and produce
- a grayscale output image.</div>
+<div class="block">This option will discard the color data in the source image and produce a
+ grayscale destination image.</div>
 <dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#org.libjpegturbo.turbojpeg.TJTransform.OPT_GRAY">Constant Field Values</a></dd></dl>
 </li>
 </ul>
@@ -573,11 +574,10 @@ extends java.awt.Rectangle</pre>
 <li class="blockList">
 <h4>OPT_PROGRESSIVE</h4>
 <pre>public static final&nbsp;int OPT_PROGRESSIVE</pre>
-<div class="block">This option will enable progressive entropy coding in the output image
+<div class="block">This option will enable progressive entropy coding in the JPEG image
  generated by this particular transform.  Progressive entropy coding will
  generally improve compression relative to baseline entropy coding (the
- default), but it will reduce compression and decompression performance
- considerably.</div>
+ default), but it will reduce decompression performance considerably.</div>
 <dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#org.libjpegturbo.turbojpeg.TJTransform.OPT_PROGRESSIVE">Constant Field Values</a></dd></dl>
 </li>
 </ul>
@@ -589,7 +589,7 @@ extends java.awt.Rectangle</pre>
 <h4>OPT_COPYNONE</h4>
 <pre>public static final&nbsp;int OPT_COPYNONE</pre>
 <div class="block">This option will prevent <a href="../../../org/libjpegturbo/turbojpeg/TJTransformer.html#transform(byte[][],%20org.libjpegturbo.turbojpeg.TJTransform[],%20int)"><code>TJTransformer.transform()</code></a> from copying any extra markers (including EXIF
- and ICC profile data) from the source image to the output image.</div>
+ and ICC profile data) from the source image to the destination image.</div>
 <dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#org.libjpegturbo.turbojpeg.TJTransform.OPT_COPYNONE">Constant Field Values</a></dd></dl>
 </li>
 </ul>
@@ -600,7 +600,7 @@ extends java.awt.Rectangle</pre>
 <li class="blockList">
 <h4>op</h4>
 <pre>public&nbsp;int op</pre>
-<div class="block">Transform operation (one of <code>OP_*</code>)</div>
+<div class="block">Transform operation (one of <a href="../../../org/libjpegturbo/turbojpeg/TJTransform.html#OP_NONE"><code>OP_*</code></a>)</div>
 </li>
 </ul>
 <a name="options">
@@ -610,7 +610,8 @@ extends java.awt.Rectangle</pre>
 <li class="blockList">
 <h4>options</h4>
 <pre>public&nbsp;int options</pre>
-<div class="block">Transform options (bitwise OR of one or more of <code>OPT_*</code>)</div>
+<div class="block">Transform options (bitwise OR of one or more of
+ <a href="../../../org/libjpegturbo/turbojpeg/TJTransform.html#OPT_PERFECT"><code>OPT_*</code></a>)</div>
 </li>
 </ul>
 <a name="cf">
@@ -661,8 +662,8 @@ extends java.awt.Rectangle</pre>
  equivalent of setting it to (width of the source JPEG image -
  <code>x</code>).</dd><dd><code>h</code> - the height of the cropping region.  Setting this to 0 is the
  equivalent of setting it to (height of the source JPEG image -
- <code>y</code>).</dd><dd><code>op</code> - one of the transform operations (<code>OP_*</code>)</dd><dd><code>options</code> - the bitwise OR of one or more of the transform options
- (<code>OPT_*</code>)</dd><dd><code>cf</code> - an instance of an object that implements the <a href="../../../org/libjpegturbo/turbojpeg/TJCustomFilter.html" title="interface in org.libjpegturbo.turbojpeg"><code>TJCustomFilter</code></a> interface, or null if no custom filter is needed</dd></dl>
+ <code>y</code>).</dd><dd><code>op</code> - one of the transform operations (<a href="../../../org/libjpegturbo/turbojpeg/TJTransform.html#OP_NONE"><code>OP_*</code></a>)</dd><dd><code>options</code> - the bitwise OR of one or more of the transform options
+ (<a href="../../../org/libjpegturbo/turbojpeg/TJTransform.html#OPT_PERFECT"><code>OPT_*</code></a>)</dd><dd><code>cf</code> - an instance of an object that implements the <a href="../../../org/libjpegturbo/turbojpeg/TJCustomFilter.html" title="interface in org.libjpegturbo.turbojpeg"><code>TJCustomFilter</code></a> interface, or null if no custom filter is needed</dd></dl>
 </li>
 </ul>
 <a name="TJTransform(java.awt.Rectangle, int, int, org.libjpegturbo.turbojpeg.TJCustomFilter)">
@@ -678,8 +679,8 @@ extends java.awt.Rectangle</pre>
 <div class="block">Create a new lossless transform instance with the given parameters.</div>
 <dl><dt><span class="strong">Parameters:</span></dt><dd><code>r</code> - a <code>Rectangle</code> instance that specifies the cropping
  region.  See <a href="../../../org/libjpegturbo/turbojpeg/TJTransform.html#TJTransform(int,%20int,%20int,%20int,%20int,%20int,%20org.libjpegturbo.turbojpeg.TJCustomFilter)"><code>TJTransform(int, int, int, int, int, int, TJCustomFilter)</code></a> for more
- detail.</dd><dd><code>op</code> - one of the transform operations (<code>OP_*</code>)</dd><dd><code>options</code> - the bitwise OR of one or more of the transform options
- (<code>OPT_*</code>)</dd><dd><code>cf</code> - an instance of an object that implements the <a href="../../../org/libjpegturbo/turbojpeg/TJCustomFilter.html" title="interface in org.libjpegturbo.turbojpeg"><code>TJCustomFilter</code></a> interface, or null if no custom filter is needed</dd></dl>
+ detail.</dd><dd><code>op</code> - one of the transform operations (<a href="../../../org/libjpegturbo/turbojpeg/TJTransform.html#OP_NONE"><code>OP_*</code></a>)</dd><dd><code>options</code> - the bitwise OR of one or more of the transform options
+ (<a href="../../../org/libjpegturbo/turbojpeg/TJTransform.html#OPT_PERFECT"><code>OPT_*</code></a>)</dd><dd><code>cf</code> - an instance of an object that implements the <a href="../../../org/libjpegturbo/turbojpeg/TJCustomFilter.html" title="interface in org.libjpegturbo.turbojpeg"><code>TJCustomFilter</code></a> interface, or null if no custom filter is needed</dd></dl>
 </li>
 </ul>
 </li>
diff --git a/java/doc/org/libjpegturbo/turbojpeg/TJTransformer.html b/java/doc/org/libjpegturbo/turbojpeg/TJTransformer.html
index a30fe30..6436b7f 100644
--- a/java/doc/org/libjpegturbo/turbojpeg/TJTransformer.html
+++ b/java/doc/org/libjpegturbo/turbojpeg/TJTransformer.html
@@ -148,14 +148,15 @@ extends <a href="../../../org/libjpegturbo/turbojpeg/TJDecompressor.html" title=
 <tr class="rowColor">
 <td class="colOne"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJTransformer.html#TJTransformer(byte[])">TJTransformer</a></strong>(byte[]&nbsp;jpegImage)</code>
 <div class="block">Create a TurboJPEG lossless transformer instance and associate the JPEG
- image stored in <code>jpegImage</code> with the newly created instance.</div>
+ source image stored in <code>jpegImage</code> with the newly created
+ instance.</div>
 </td>
 </tr>
 <tr class="altColor">
 <td class="colOne"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJTransformer.html#TJTransformer(byte[],%20int)">TJTransformer</a></strong>(byte[]&nbsp;jpegImage,
              int&nbsp;imageSize)</code>
 <div class="block">Create a TurboJPEG lossless transformer instance and associate the JPEG
- image of length <code>imageSize</code> bytes stored in
+ source image of length <code>imageSize</code> bytes stored in
  <code>jpegImage</code> with the newly created instance.</div>
 </td>
 </tr>
@@ -178,7 +179,7 @@ extends <a href="../../../org/libjpegturbo/turbojpeg/TJDecompressor.html" title=
 <td class="colFirst"><code>int[]</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJTransformer.html#getTransformedSizes()">getTransformedSizes</a></strong>()</code>
 <div class="block">Returns an array containing the sizes of the transformed JPEG images
- generated by the most recent transform operation.</div>
+ (in bytes) generated by the most recent transform operation.</div>
 </td>
 </tr>
 <tr class="rowColor">
@@ -186,18 +187,18 @@ extends <a href="../../../org/libjpegturbo/turbojpeg/TJDecompressor.html" title=
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJTransformer.html#transform(byte[][],%20org.libjpegturbo.turbojpeg.TJTransform[],%20int)">transform</a></strong>(byte[][]&nbsp;dstBufs,
          <a href="../../../org/libjpegturbo/turbojpeg/TJTransform.html" title="class in org.libjpegturbo.turbojpeg">TJTransform</a>[]&nbsp;transforms,
          int&nbsp;flags)</code>
-<div class="block">Losslessly transform the JPEG image associated with this transformer
- instance into one or more JPEG images stored in the given destination
- buffers.</div>
+<div class="block">Losslessly transform the JPEG source image associated with this
+ transformer instance into one or more JPEG images stored in the given
+ destination buffers.</div>
 </td>
 </tr>
 <tr class="altColor">
 <td class="colFirst"><code><a href="../../../org/libjpegturbo/turbojpeg/TJDecompressor.html" title="class in org.libjpegturbo.turbojpeg">TJDecompressor</a>[]</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJTransformer.html#transform(org.libjpegturbo.turbojpeg.TJTransform[],%20int)">transform</a></strong>(<a href="../../../org/libjpegturbo/turbojpeg/TJTransform.html" title="class in org.libjpegturbo.turbojpeg">TJTransform</a>[]&nbsp;transforms,
          int&nbsp;flags)</code>
-<div class="block">Losslessly transform the JPEG image associated with this transformer
- instance and return an array of <a href="../../../org/libjpegturbo/turbojpeg/TJDecompressor.html" title="class in org.libjpegturbo.turbojpeg"><code>TJDecompressor</code></a> instances, each of
- which has a transformed JPEG image associated with it.</div>
+<div class="block">Losslessly transform the JPEG source image associated with this
+ transformer instance and return an array of <a href="../../../org/libjpegturbo/turbojpeg/TJDecompressor.html" title="class in org.libjpegturbo.turbojpeg"><code>TJDecompressor</code></a>
+ instances, each of which has a transformed JPEG image associated with it.</div>
 </td>
 </tr>
 </table>
@@ -251,9 +252,11 @@ extends <a href="../../../org/libjpegturbo/turbojpeg/TJDecompressor.html" title=
 <pre>public&nbsp;TJTransformer(byte[]&nbsp;jpegImage)
               throws <a href="../../../org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg">TJException</a></pre>
 <div class="block">Create a TurboJPEG lossless transformer instance and associate the JPEG
- image stored in <code>jpegImage</code> with the newly created instance.</div>
-<dl><dt><span class="strong">Parameters:</span></dt><dd><code>jpegImage</code> - JPEG image buffer (size of the JPEG image is assumed to
- be the length of the array.)  This buffer is not modified.</dd>
+ source image stored in <code>jpegImage</code> with the newly created
+ instance.</div>
+<dl><dt><span class="strong">Parameters:</span></dt><dd><code>jpegImage</code> - buffer containing the JPEG source image to transform.
+ (The size of the JPEG image is assumed to be the length of the array.)
+ This buffer is not modified.</dd>
 <dt><span class="strong">Throws:</span></dt>
 <dd><code><a href="../../../org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg">TJException</a></code></dd></dl>
 </li>
@@ -268,9 +271,10 @@ extends <a href="../../../org/libjpegturbo/turbojpeg/TJDecompressor.html" title=
              int&nbsp;imageSize)
               throws <a href="../../../org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg">TJException</a></pre>
 <div class="block">Create a TurboJPEG lossless transformer instance and associate the JPEG
- image of length <code>imageSize</code> bytes stored in
+ source image of length <code>imageSize</code> bytes stored in
  <code>jpegImage</code> with the newly created instance.</div>
-<dl><dt><span class="strong">Parameters:</span></dt><dd><code>jpegImage</code> - JPEG image buffer.  This buffer is not modified.</dd><dd><code>imageSize</code> - size of the JPEG image (in bytes)</dd>
+<dl><dt><span class="strong">Parameters:</span></dt><dd><code>jpegImage</code> - buffer containing the JPEG source image to transform.
+ This buffer is not modified.</dd><dd><code>imageSize</code> - size of the JPEG source image (in bytes)</dd>
 <dt><span class="strong">Throws:</span></dt>
 <dd><code><a href="../../../org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg">TJException</a></code></dd></dl>
 </li>
@@ -293,25 +297,26 @@ extends <a href="../../../org/libjpegturbo/turbojpeg/TJDecompressor.html" title=
              <a href="../../../org/libjpegturbo/turbojpeg/TJTransform.html" title="class in org.libjpegturbo.turbojpeg">TJTransform</a>[]&nbsp;transforms,
              int&nbsp;flags)
                throws <a href="../../../org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg">TJException</a></pre>
-<div class="block">Losslessly transform the JPEG image associated with this transformer
- instance into one or more JPEG images stored in the given destination
- buffers.  Lossless transforms work by moving the raw coefficients from one
- JPEG image structure to another without altering the values of the
- coefficients.  While this is typically faster than decompressing the
- image, transforming it, and re-compressing it, lossless transforms are not
- free.  Each lossless transform requires reading and performing Huffman
- decoding on all of the coefficients in the source image, regardless of the
- size of the destination image.  Thus, this method provides a means of
- generating multiple transformed images from the same source or of applying
- multiple transformations simultaneously, in order to eliminate the need to
- read the source coefficients multiple times.</div>
-<dl><dt><span class="strong">Parameters:</span></dt><dd><code>dstBufs</code> - an array of image buffers.  <code>dstbufs[i]</code> will
- receive a JPEG image that has been transformed using the parameters in
- <code>transforms[i]</code>.  Use <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#bufSize(int,%20int,%20int)"><code>TJ.bufSize(int, int, int)</code></a> to determine the
- maximum size for each buffer based on the transformed or cropped width and
- height and the level of subsampling used in the source image.</dd><dd><code>transforms</code> - an array of <a href="../../../org/libjpegturbo/turbojpeg/TJTransform.html" title="class in org.libjpegturbo.turbojpeg"><code>TJTransform</code></a> instances, each of
+<div class="block">Losslessly transform the JPEG source image associated with this
+ transformer instance into one or more JPEG images stored in the given
+ destination buffers.  Lossless transforms work by moving the raw
+ coefficients from one JPEG image structure to another without altering the
+ values of the coefficients.  While this is typically faster than
+ decompressing the image, transforming it, and re-compressing it, lossless
+ transforms are not free.  Each lossless transform requires reading and
+ performing Huffman decoding on all of the coefficients in the source
+ image, regardless of the size of the destination image.  Thus, this method
+ provides a means of generating multiple transformed images from the same
+ source or of applying multiple transformations simultaneously, in order to
+ eliminate the need to read the source coefficients multiple times.</div>
+<dl><dt><span class="strong">Parameters:</span></dt><dd><code>dstBufs</code> - an array of JPEG destination buffers.
+ <code>dstbufs[i]</code> will receive a JPEG image that has been
+ transformed using the parameters in <code>transforms[i]</code>.  Use
+ <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#bufSize(int,%20int,%20int)"><code>TJ.bufSize(int, int, int)</code></a> to determine the maximum size for each buffer based on
+ the transformed or cropped width and height and the level of subsampling
+ used in the source image.</dd><dd><code>transforms</code> - an array of <a href="../../../org/libjpegturbo/turbojpeg/TJTransform.html" title="class in org.libjpegturbo.turbojpeg"><code>TJTransform</code></a> instances, each of
  which specifies the transform parameters and/or cropping region for the
- corresponding transformed output image</dd><dd><code>flags</code> - the bitwise OR of one or more of
+ corresponding transformed JPEG image</dd><dd><code>flags</code> - the bitwise OR of one or more of
  <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#FLAG_BOTTOMUP"><code>TJ.FLAG_*</code></a></dd>
 <dt><span class="strong">Throws:</span></dt>
 <dd><code><a href="../../../org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg">TJException</a></code></dd></dl>
@@ -326,12 +331,12 @@ extends <a href="../../../org/libjpegturbo/turbojpeg/TJDecompressor.html" title=
 <pre>public&nbsp;<a href="../../../org/libjpegturbo/turbojpeg/TJDecompressor.html" title="class in org.libjpegturbo.turbojpeg">TJDecompressor</a>[]&nbsp;transform(<a href="../../../org/libjpegturbo/turbojpeg/TJTransform.html" title="class in org.libjpegturbo.turbojpeg">TJTransform</a>[]&nbsp;transforms,
                          int&nbsp;flags)
                            throws <a href="../../../org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg">TJException</a></pre>
-<div class="block">Losslessly transform the JPEG image associated with this transformer
- instance and return an array of <a href="../../../org/libjpegturbo/turbojpeg/TJDecompressor.html" title="class in org.libjpegturbo.turbojpeg"><code>TJDecompressor</code></a> instances, each of
- which has a transformed JPEG image associated with it.</div>
+<div class="block">Losslessly transform the JPEG source image associated with this
+ transformer instance and return an array of <a href="../../../org/libjpegturbo/turbojpeg/TJDecompressor.html" title="class in org.libjpegturbo.turbojpeg"><code>TJDecompressor</code></a>
+ instances, each of which has a transformed JPEG image associated with it.</div>
 <dl><dt><span class="strong">Parameters:</span></dt><dd><code>transforms</code> - an array of <a href="../../../org/libjpegturbo/turbojpeg/TJTransform.html" title="class in org.libjpegturbo.turbojpeg"><code>TJTransform</code></a> instances, each of
  which specifies the transform parameters and/or cropping region for the
- corresponding transformed output image</dd><dd><code>flags</code> - the bitwise OR of one or more of
+ corresponding transformed JPEG image</dd><dd><code>flags</code> - the bitwise OR of one or more of
  <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#FLAG_BOTTOMUP"><code>TJ.FLAG_*</code></a></dd>
 <dt><span class="strong">Returns:</span></dt><dd>an array of <a href="../../../org/libjpegturbo/turbojpeg/TJDecompressor.html" title="class in org.libjpegturbo.turbojpeg"><code>TJDecompressor</code></a> instances, each of
  which has a transformed JPEG image associated with it.</dd>
@@ -347,9 +352,9 @@ extends <a href="../../../org/libjpegturbo/turbojpeg/TJDecompressor.html" title=
 <h4>getTransformedSizes</h4>
 <pre>public&nbsp;int[]&nbsp;getTransformedSizes()</pre>
 <div class="block">Returns an array containing the sizes of the transformed JPEG images
- generated by the most recent transform operation.</div>
+ (in bytes) generated by the most recent transform operation.</div>
 <dl><dt><span class="strong">Returns:</span></dt><dd>an array containing the sizes of the transformed JPEG images
- generated by the most recent transform operation.</dd></dl>
+ (in bytes) generated by the most recent transform operation.</dd></dl>
 </li>
 </ul>
 </li>
diff --git a/java/doc/org/libjpegturbo/turbojpeg/YUVImage.html b/java/doc/org/libjpegturbo/turbojpeg/YUVImage.html
index d4485ed..b08fcb3 100644
--- a/java/doc/org/libjpegturbo/turbojpeg/YUVImage.html
+++ b/java/doc/org/libjpegturbo/turbojpeg/YUVImage.html
@@ -98,7 +98,7 @@
 <br>
 <pre>public class <span class="strong">YUVImage</span>
 extends java.lang.Object</pre>
-<div class="block">This class encapsulates a YUV planar image and the metadata
+<div class="block">This class encapsulates a planar YUV image and the metadata
  associated with it.  The TurboJPEG API allows both the JPEG compression and
  decompression pipelines to be split into stages:  YUV encode, compress from
  YUV, decompress to YUV, and YUV decode.  A <code>YUVImage</code> instance
@@ -106,30 +106,32 @@ extends java.lang.Object</pre>
  operations and as the source image for compress-from-YUV and YUV decode
  operations.
  <p>
- Technically, the JPEG format uses the YCbCr colorspace (which technically is
- not a "colorspace" but rather a "color transform"), but per the convention
- of the digital video community, the TurboJPEG API uses "YUV" to refer to an
- image format consisting of Y, Cb, and Cr image planes.
+ Technically, the JPEG format uses the YCbCr colorspace (which is technically
+ not a colorspace but a color transform), but per the convention of the
+ digital video community, the TurboJPEG API uses "YUV" to refer to an image
+ format consisting of Y, Cb, and Cr image planes.
  <p>
  Each plane is simply a 2D array of bytes, each byte representing the value
  of one of the components (Y, Cb, or Cr) at a particular location in the
  image.  The width and height of each plane are determined by the image
  width, height, and level of chrominance subsampling.  The luminance plane
  width is the image width padded to the nearest multiple of the horizontal
- subsampling factor (2 in the case of 4:2:0 and 4:2:2, 4 in the case of
- 4:1:1, 1 in the case of 4:4:4 or grayscale.)  Similarly, the luminance plane
- height is the image height padded to the nearest multiple of the vertical
- subsampling factor (2 in the case of 4:2:0 or 4:4:0, 1 in the case of 4:4:4
- or grayscale.)  The chrominance plane width is equal to the luminance plane
- width divided by the horizontal subsampling factor, and the chrominance
- plane height is equal to the luminance plane height divided by the vertical
- subsampling factor.
+ subsampling factor (1 in the case of 4:4:4, grayscale, or 4:4:0; 2 in the
+ case of 4:2:2 or 4:2:0; 4 in the case of 4:1:1.)  Similarly, the luminance
+ plane height is the image height padded to the nearest multiple of the
+ vertical subsampling factor (1 in the case of 4:4:4, 4:2:2, grayscale, or
+ 4:1:1; 2 in the case of 4:2:0 or 4:4:0.)  This is irrespective of any
+ additional padding that may be specified as an argument to the various
+ YUVImage methods.  The chrominance plane width is equal to the luminance
+ plane width divided by the horizontal subsampling factor, and the
+ chrominance plane height is equal to the luminance plane height divided by
+ the vertical subsampling factor.
  <p>
  For example, if the source image is 35 x 35 pixels and 4:2:2 subsampling is
  used, then the luminance plane would be 36 x 35 bytes, and each of the
- chrominance planes would be 18 x 35 bytes.  If you specify a line padding of
- 4 bytes on top of this, then the luminance plane would be 36 x 35 bytes, and
- each of the chrominance planes would be 20 x 35 bytes.</div>
+ chrominance planes would be 18 x 35 bytes.  If you specify a row alignment
+ of 4 bytes on top of this, then the luminance plane would be 36 x 35 bytes,
+ and each of the chrominance planes would be 20 x 35 bytes.</div>
 </li>
 </ul>
 </div>
@@ -154,15 +156,15 @@ extends java.lang.Object</pre>
 </tr>
 <tr class="rowColor">
 <td class="colFirst"><code>protected int</code></td>
-<td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html#yuvHeight">yuvHeight</a></strong></code>&nbsp;</td>
+<td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html#yuvAlign">yuvAlign</a></strong></code>&nbsp;</td>
 </tr>
 <tr class="altColor">
-<td class="colFirst"><code>protected int[]</code></td>
-<td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html#yuvOffsets">yuvOffsets</a></strong></code>&nbsp;</td>
+<td class="colFirst"><code>protected int</code></td>
+<td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html#yuvHeight">yuvHeight</a></strong></code>&nbsp;</td>
 </tr>
 <tr class="rowColor">
-<td class="colFirst"><code>protected int</code></td>
-<td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html#yuvPad">yuvPad</a></strong></code>&nbsp;</td>
+<td class="colFirst"><code>protected int[]</code></td>
+<td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html#yuvOffsets">yuvOffsets</a></strong></code>&nbsp;</td>
 </tr>
 <tr class="altColor">
 <td class="colFirst"><code>protected byte[][]</code></td>
@@ -208,10 +210,10 @@ extends java.lang.Object</pre>
 <tr class="rowColor">
 <td class="colOne"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html#YUVImage(byte[],%20int,%20int,%20int,%20int)">YUVImage</a></strong>(byte[]&nbsp;yuvImage,
         int&nbsp;width,
-        int&nbsp;pad,
+        int&nbsp;align,
         int&nbsp;height,
         int&nbsp;subsamp)</code>
-<div class="block">Create a new <code>YUVImage</code> instance from an existing unified image
+<div class="block">Create a new <code>YUVImage</code> instance from an existing unified
  buffer.</div>
 </td>
 </tr>
@@ -226,11 +228,11 @@ extends java.lang.Object</pre>
 </tr>
 <tr class="rowColor">
 <td class="colOne"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html#YUVImage(int,%20int,%20int,%20int)">YUVImage</a></strong>(int&nbsp;width,
-        int&nbsp;pad,
+        int&nbsp;align,
         int&nbsp;height,
         int&nbsp;subsamp)</code>
-<div class="block">Create a new <code>YUVImage</code> instance backed by a unified image
- buffer, and allocate memory for the image buffer.</div>
+<div class="block">Create a new <code>YUVImage</code> instance backed by a unified buffer,
+ and allocate memory for the buffer.</div>
 </td>
 </tr>
 </table>
@@ -251,8 +253,8 @@ extends java.lang.Object</pre>
 <tr class="altColor">
 <td class="colFirst"><code>byte[]</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html#getBuf()">getBuf</a></strong>()</code>
-<div class="block">Returns the YUV image buffer (if this image is stored in a unified
- buffer rather than separate image planes.)</div>
+<div class="block">Returns the YUV buffer (if this image is stored in a unified buffer rather
+ than separate image planes.)</div>
 </td>
 </tr>
 <tr class="rowColor">
@@ -271,7 +273,7 @@ extends java.lang.Object</pre>
 <tr class="rowColor">
 <td class="colFirst"><code>int</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html#getPad()">getPad</a></strong>()</code>
-<div class="block">Returns the line padding used in the YUV image buffer (if this image is
+<div class="block">Returns the row alignment (in bytes) of the YUV buffer (if this image is
  stored in a unified buffer rather than separate image planes.)</div>
 </td>
 </tr>
@@ -284,14 +286,14 @@ extends java.lang.Object</pre>
 <tr class="rowColor">
 <td class="colFirst"><code>int</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html#getSize()">getSize</a></strong>()</code>
-<div class="block">Returns the size (in bytes) of the YUV image buffer (if this image is
- stored in a unified buffer rather than separate image planes.)</div>
+<div class="block">Returns the size (in bytes) of the YUV buffer (if this image is stored in
+ a unified buffer rather than separate image planes.)</div>
 </td>
 </tr>
 <tr class="altColor">
 <td class="colFirst"><code>int[]</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html#getStrides()">getStrides</a></strong>()</code>
-<div class="block">Returns the number of bytes per line of each plane in the YUV image.</div>
+<div class="block">Returns the number of bytes per row of each plane in the YUV image.</div>
 </td>
 </tr>
 <tr class="rowColor">
@@ -321,10 +323,10 @@ extends java.lang.Object</pre>
 <td class="colFirst"><code>void</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html#setBuf(byte[],%20int,%20int,%20int,%20int)">setBuf</a></strong>(byte[]&nbsp;yuvImage,
       int&nbsp;width,
-      int&nbsp;pad,
+      int&nbsp;align,
       int&nbsp;height,
       int&nbsp;subsamp)</code>
-<div class="block">Assign a unified image buffer to this <code>YUVImage</code> instance.</div>
+<div class="block">Assign a unified buffer to this <code>YUVImage</code> instance.</div>
 </td>
 </tr>
 </table>
@@ -385,13 +387,13 @@ extends java.lang.Object</pre>
 <pre>protected&nbsp;int[] yuvStrides</pre>
 </li>
 </ul>
-<a name="yuvPad">
+<a name="yuvAlign">
 <!--   -->
 </a>
 <ul class="blockList">
 <li class="blockList">
-<h4>yuvPad</h4>
-<pre>protected&nbsp;int yuvPad</pre>
+<h4>yuvAlign</h4>
+<pre>protected&nbsp;int yuvAlign</pre>
 </li>
 </ul>
 <a name="yuvWidth">
@@ -442,7 +444,7 @@ extends java.lang.Object</pre>
 <div class="block">Create a new <code>YUVImage</code> instance backed by separate image
  planes, and allocate memory for the image planes.</div>
 <dl><dt><span class="strong">Parameters:</span></dt><dd><code>width</code> - width (in pixels) of the YUV image</dd><dd><code>strides</code> - an array of integers, each specifying the number of bytes
- per line in the corresponding plane of the YUV image.  Setting the stride
+ per row in the corresponding plane of the YUV image.  Setting the stride
  for any plane to 0 is the same as setting it to the plane width (see
  <a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg"><code>above</code></a>.)  If <code>strides</code> is null, then the
  strides for all planes will be set to their respective plane widths.  When
@@ -458,13 +460,15 @@ extends java.lang.Object</pre>
 <li class="blockList">
 <h4>YUVImage</h4>
 <pre>public&nbsp;YUVImage(int&nbsp;width,
-        int&nbsp;pad,
+        int&nbsp;align,
         int&nbsp;height,
         int&nbsp;subsamp)</pre>
-<div class="block">Create a new <code>YUVImage</code> instance backed by a unified image
- buffer, and allocate memory for the image buffer.</div>
-<dl><dt><span class="strong">Parameters:</span></dt><dd><code>width</code> - width (in pixels) of the YUV image</dd><dd><code>pad</code> - Each line of each plane in the YUV image buffer will be padded
- to this number of bytes (must be a power of 2.)</dd><dd><code>height</code> - height (in pixels) of the YUV image</dd><dd><code>subsamp</code> - the level of chrominance subsampling to be used in the YUV
+<div class="block">Create a new <code>YUVImage</code> instance backed by a unified buffer,
+ and allocate memory for the buffer.</div>
+<dl><dt><span class="strong">Parameters:</span></dt><dd><code>width</code> - width (in pixels) of the YUV image</dd><dd><code>align</code> - row alignment (in bytes) of the YUV image (must be a power of
+ 2.)  Setting this parameter to n specifies that each row in each plane of
+ the YUV image will be padded to the nearest multiple of n bytes
+ (1 = unpadded.)</dd><dd><code>height</code> - height (in pixels) of the YUV image</dd><dd><code>subsamp</code> - the level of chrominance subsampling to be used in the YUV
  image (one of <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#SAMP_444"><code>TJ.SAMP_*</code></a>)</dd></dl>
 </li>
 </ul>
@@ -485,18 +489,18 @@ extends java.lang.Object</pre>
 <dl><dt><span class="strong">Parameters:</span></dt><dd><code>planes</code> - an array of buffers representing the Y, U (Cb), and V (Cr)
  image planes (or just the Y plane, if the image is grayscale.)   These
  planes can be contiguous or non-contiguous in memory.  Plane
- <code>i</code> should be at least <code>offsets[i] +
- <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#planeSizeYUV(int,%20int,%20int,%20int,%20int)"><code>TJ.planeSizeYUV</code></a>(i, width, strides[i], height, subsamp)</code>
+ <code>i</code> should be at least <code>offsets[i] + </code>
+ <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#planeSizeYUV(int,%20int,%20int,%20int,%20int)"><code>TJ.planeSizeYUV</code></a><code>(i, width, strides[i], height, subsamp)</code>
  bytes in size.</dd><dd><code>offsets</code> - If this <code>YUVImage</code> instance represents a
  subregion of a larger image, then <code>offsets[i]</code> specifies the
  offset (in bytes) of the subregion within plane <code>i</code> of the
  larger image.  Setting this to null is the same as setting the offsets for
  all planes to 0.</dd><dd><code>width</code> - width (in pixels) of the new YUV image (or subregion)</dd><dd><code>strides</code> - an array of integers, each specifying the number of bytes
- per line in the corresponding plane of the YUV image.  Setting the stride
+ per row in the corresponding plane of the YUV image.  Setting the stride
  for any plane to 0 is the same as setting it to the plane width (see
  <a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg"><code>above</code></a>.)  If <code>strides</code> is null, then the
  strides for all planes will be set to their respective plane widths.  You
- can adjust the strides in order to add an arbitrary amount of line padding
+ can adjust the strides in order to add an arbitrary amount of row padding
  to each plane or to specify that this <code>YUVImage</code> instance is a
  subregion of a larger image (in which case, <code>strides[i]</code> should
  be set to the plane width of plane <code>i</code> in the larger image.)</dd><dd><code>height</code> - height (in pixels) of the new YUV image (or subregion)</dd><dd><code>subsamp</code> - the level of chrominance subsampling used in the YUV
@@ -511,18 +515,19 @@ extends java.lang.Object</pre>
 <h4>YUVImage</h4>
 <pre>public&nbsp;YUVImage(byte[]&nbsp;yuvImage,
         int&nbsp;width,
-        int&nbsp;pad,
+        int&nbsp;align,
         int&nbsp;height,
         int&nbsp;subsamp)</pre>
-<div class="block">Create a new <code>YUVImage</code> instance from an existing unified image
+<div class="block">Create a new <code>YUVImage</code> instance from an existing unified
  buffer.</div>
-<dl><dt><span class="strong">Parameters:</span></dt><dd><code>yuvImage</code> - image buffer that contains or will contain YUV planar
- image data.  Use <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#bufSizeYUV(int,%20int,%20int,%20int)"><code>TJ.bufSizeYUV(int, int, int, int)</code></a> to determine the minimum size for
- this buffer.  The Y, U (Cb), and V (Cr) image planes are stored
- sequentially in the buffer (see <a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg"><code>above</code></a> for a description
- of the image format.)</dd><dd><code>width</code> - width (in pixels) of the YUV image</dd><dd><code>pad</code> - the line padding used in the YUV image buffer.  For
- instance, if each line in each plane of the buffer is padded to the
- nearest multiple of 4 bytes, then <code>pad</code> should be set to 4.</dd><dd><code>height</code> - height (in pixels) of the YUV image</dd><dd><code>subsamp</code> - the level of chrominance subsampling used in the YUV
+<dl><dt><span class="strong">Parameters:</span></dt><dd><code>yuvImage</code> - buffer that contains or will receive a unified planar YUV
+ image.  Use <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#bufSizeYUV(int,%20int,%20int,%20int)"><code>TJ.bufSizeYUV(int, int, int, int)</code></a> to determine the minimum size for this
+ buffer.  The Y, U (Cb), and V (Cr) image planes are stored sequentially in
+ the buffer.  (See <a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg"><code>above</code></a> for a description of the image
+ format.)</dd><dd><code>width</code> - width (in pixels) of the YUV image</dd><dd><code>align</code> - row alignment (in bytes) of the YUV image (must be a power of
+ 2.)  Setting this parameter to n specifies that each row in each plane of
+ the YUV image will be padded to the nearest multiple of n bytes
+ (1 = unpadded.)</dd><dd><code>height</code> - height (in pixels) of the YUV image</dd><dd><code>subsamp</code> - the level of chrominance subsampling used in the YUV
  image (one of <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#SAMP_444"><code>TJ.SAMP_*</code></a>)</dd></dl>
 </li>
 </ul>
@@ -550,19 +555,19 @@ extends java.lang.Object</pre>
 <dl><dt><span class="strong">Parameters:</span></dt><dd><code>planes</code> - an array of buffers representing the Y, U (Cb), and V (Cr)
  image planes (or just the Y plane, if the image is grayscale.)  These
  planes can be contiguous or non-contiguous in memory.  Plane
- <code>i</code> should be at least <code>offsets[i] +
- <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#planeSizeYUV(int,%20int,%20int,%20int,%20int)"><code>TJ.planeSizeYUV</code></a>(i, width, strides[i], height, subsamp)</code>
+ <code>i</code> should be at least <code>offsets[i] + </code>
+ <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#planeSizeYUV(int,%20int,%20int,%20int,%20int)"><code>TJ.planeSizeYUV</code></a><code>(i, width, strides[i], height, subsamp)</code>
  bytes in size.</dd><dd><code>offsets</code> - If this <code>YUVImage</code> instance represents a
  subregion of a larger image, then <code>offsets[i]</code> specifies the
  offset (in bytes) of the subregion within plane <code>i</code> of the
  larger image.  Setting this to null is the same as setting the offsets for
  all planes to 0.</dd><dd><code>width</code> - width (in pixels) of the YUV image (or subregion)</dd><dd><code>strides</code> - an array of integers, each specifying the number of bytes
- per line in the corresponding plane of the YUV image.  Setting the stride
+ per row in the corresponding plane of the YUV image.  Setting the stride
  for any plane to 0 is the same as setting it to the plane width (see
  <a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg"><code>above</code></a>.)  If <code>strides</code> is null, then the
  strides for all planes will be set to their respective plane widths.  You
- can adjust the strides in order to add an arbitrary amount of line padding
- to each plane or to specify that this <code>YUVImage</code> image is a
+ can adjust the strides in order to add an arbitrary amount of row padding
+ to each plane or to specify that this <code>YUVImage</code> instance is a
  subregion of a larger image (in which case, <code>strides[i]</code> should
  be set to the plane width of plane <code>i</code> in the larger image.)</dd><dd><code>height</code> - height (in pixels) of the YUV image (or subregion)</dd><dd><code>subsamp</code> - the level of chrominance subsampling used in the YUV
  image (one of <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#SAMP_444"><code>TJ.SAMP_*</code></a>)</dd></dl>
@@ -576,17 +581,18 @@ extends java.lang.Object</pre>
 <h4>setBuf</h4>
 <pre>public&nbsp;void&nbsp;setBuf(byte[]&nbsp;yuvImage,
           int&nbsp;width,
-          int&nbsp;pad,
+          int&nbsp;align,
           int&nbsp;height,
           int&nbsp;subsamp)</pre>
-<div class="block">Assign a unified image buffer to this <code>YUVImage</code> instance.</div>
-<dl><dt><span class="strong">Parameters:</span></dt><dd><code>yuvImage</code> - image buffer that contains or will contain YUV planar
- image data.  Use <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#bufSizeYUV(int,%20int,%20int,%20int)"><code>TJ.bufSizeYUV(int, int, int, int)</code></a> to determine the minimum size for
- this buffer.  The Y, U (Cb), and V (Cr) image planes are stored
- sequentially in the buffer (see <a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg"><code>above</code></a> for a description
- of the image format.)</dd><dd><code>width</code> - width (in pixels) of the YUV image</dd><dd><code>pad</code> - the line padding used in the YUV image buffer.  For
- instance, if each line in each plane of the buffer is padded to the
- nearest multiple of 4 bytes, then <code>pad</code> should be set to 4.</dd><dd><code>height</code> - height (in pixels) of the YUV image</dd><dd><code>subsamp</code> - the level of chrominance subsampling used in the YUV
+<div class="block">Assign a unified buffer to this <code>YUVImage</code> instance.</div>
+<dl><dt><span class="strong">Parameters:</span></dt><dd><code>yuvImage</code> - buffer that contains or will receive a unified planar YUV
+ image.  Use <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#bufSizeYUV(int,%20int,%20int,%20int)"><code>TJ.bufSizeYUV(int, int, int, int)</code></a> to determine the minimum size for this
+ buffer.  The Y, U (Cb), and V (Cr) image planes are stored sequentially in
+ the buffer.  (See <a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg"><code>above</code></a> for a description of the image
+ format.)</dd><dd><code>width</code> - width (in pixels) of the YUV image</dd><dd><code>align</code> - row alignment (in bytes) of the YUV image (must be a power of
+ 2.)  Setting this parameter to n specifies that each row in each plane of
+ the YUV image will be padded to the nearest multiple of n bytes
+ (1 = unpadded.)</dd><dd><code>height</code> - height (in pixels) of the YUV image</dd><dd><code>subsamp</code> - the level of chrominance subsampling used in the YUV
  image (one of <a href="../../../org/libjpegturbo/turbojpeg/TJ.html#SAMP_444"><code>TJ.SAMP_*</code></a>)</dd></dl>
 </li>
 </ul>
@@ -619,9 +625,9 @@ extends java.lang.Object</pre>
 <li class="blockList">
 <h4>getPad</h4>
 <pre>public&nbsp;int&nbsp;getPad()</pre>
-<div class="block">Returns the line padding used in the YUV image buffer (if this image is
+<div class="block">Returns the row alignment (in bytes) of the YUV buffer (if this image is
  stored in a unified buffer rather than separate image planes.)</div>
-<dl><dt><span class="strong">Returns:</span></dt><dd>the line padding used in the YUV image buffer</dd></dl>
+<dl><dt><span class="strong">Returns:</span></dt><dd>the row alignment of the YUV buffer</dd></dl>
 </li>
 </ul>
 <a name="getStrides()">
@@ -631,8 +637,8 @@ extends java.lang.Object</pre>
 <li class="blockList">
 <h4>getStrides</h4>
 <pre>public&nbsp;int[]&nbsp;getStrides()</pre>
-<div class="block">Returns the number of bytes per line of each plane in the YUV image.</div>
-<dl><dt><span class="strong">Returns:</span></dt><dd>the number of bytes per line of each plane in the YUV image</dd></dl>
+<div class="block">Returns the number of bytes per row of each plane in the YUV image.</div>
+<dl><dt><span class="strong">Returns:</span></dt><dd>the number of bytes per row of each plane in the YUV image</dd></dl>
 </li>
 </ul>
 <a name="getOffsets()">
@@ -679,9 +685,9 @@ extends java.lang.Object</pre>
 <li class="blockList">
 <h4>getBuf</h4>
 <pre>public&nbsp;byte[]&nbsp;getBuf()</pre>
-<div class="block">Returns the YUV image buffer (if this image is stored in a unified
- buffer rather than separate image planes.)</div>
-<dl><dt><span class="strong">Returns:</span></dt><dd>the YUV image buffer</dd></dl>
+<div class="block">Returns the YUV buffer (if this image is stored in a unified buffer rather
+ than separate image planes.)</div>
+<dl><dt><span class="strong">Returns:</span></dt><dd>the YUV buffer</dd></dl>
 </li>
 </ul>
 <a name="getSize()">
@@ -691,9 +697,9 @@ extends java.lang.Object</pre>
 <li class="blockList">
 <h4>getSize</h4>
 <pre>public&nbsp;int&nbsp;getSize()</pre>
-<div class="block">Returns the size (in bytes) of the YUV image buffer (if this image is
- stored in a unified buffer rather than separate image planes.)</div>
-<dl><dt><span class="strong">Returns:</span></dt><dd>the size (in bytes) of the YUV image buffer</dd></dl>
+<div class="block">Returns the size (in bytes) of the YUV buffer (if this image is stored in
+ a unified buffer rather than separate image planes.)</div>
+<dl><dt><span class="strong">Returns:</span></dt><dd>the size (in bytes) of the YUV buffer</dd></dl>
 </li>
 </ul>
 </li>
diff --git a/java/doc/org/libjpegturbo/turbojpeg/package-summary.html b/java/doc/org/libjpegturbo/turbojpeg/package-summary.html
index dedcce5..89dbe05 100644
--- a/java/doc/org/libjpegturbo/turbojpeg/package-summary.html
+++ b/java/doc/org/libjpegturbo/turbojpeg/package-summary.html
@@ -131,7 +131,7 @@
 <tr class="altColor">
 <td class="colFirst"><a href="../../../org/libjpegturbo/turbojpeg/YUVImage.html" title="class in org.libjpegturbo.turbojpeg">YUVImage</a></td>
 <td class="colLast">
-<div class="block">This class encapsulates a YUV planar image and the metadata
+<div class="block">This class encapsulates a planar YUV image and the metadata
  associated with it.</div>
 </td>
 </tr>
diff --git a/java/doc/serialized-form.html b/java/doc/serialized-form.html
index 45bbc86..e123f31 100644
--- a/java/doc/serialized-form.html
+++ b/java/doc/serialized-form.html
@@ -109,12 +109,13 @@
 <li class="blockList">
 <h4>op</h4>
 <pre>int op</pre>
-<div class="block">Transform operation (one of <code>OP_*</code>)</div>
+<div class="block">Transform operation (one of <a href="org/libjpegturbo/turbojpeg/TJTransform.html#OP_NONE"><code>OP_*</code></a>)</div>
 </li>
 <li class="blockList">
 <h4>options</h4>
 <pre>int options</pre>
-<div class="block">Transform options (bitwise OR of one or more of <code>OPT_*</code>)</div>
+<div class="block">Transform options (bitwise OR of one or more of
+ <a href="org/libjpegturbo/turbojpeg/TJTransform.html#OPT_PERFECT"><code>OPT_*</code></a>)</div>
 </li>
 <li class="blockListLast">
 <h4>cf</h4>
diff --git a/java/org/libjpegturbo/turbojpeg/TJ.java b/java/org/libjpegturbo/turbojpeg/TJ.java
index d791e00..3857087 100644
--- a/java/org/libjpegturbo/turbojpeg/TJ.java
+++ b/java/org/libjpegturbo/turbojpeg/TJ.java
@@ -1,6 +1,6 @@
 /*
- * Copyright (C)2011-2013, 2017-2018, 2020-2021 D. R. Commander.
- *                                              All Rights Reserved.
+ * Copyright (C)2011-2013, 2017-2018, 2020-2021, 2023 D. R. Commander.
+ *                                                    All Rights Reserved.
  * Copyright (C)2015 Viktor Szathmáry.  All Rights Reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -85,7 +85,7 @@ public final class TJ {
    * subsampling.
    *
    * @param subsamp the level of chrominance subsampling (one of
-   * <code>SAMP_*</code>)
+   * {@link #SAMP_444 SAMP_*})
    *
    * @return the MCU block width for the given level of chrominance
    * subsampling.
@@ -105,7 +105,7 @@ public final class TJ {
    * subsampling.
    *
    * @param subsamp the level of chrominance subsampling (one of
-   * <code>SAMP_*</code>)
+   * {@link #SAMP_444 SAMP_*})
    *
    * @return the MCU block height for the given level of chrominance
    * subsampling.
@@ -205,8 +205,8 @@ public final class TJ {
    * vice versa, but the mapping is typically not 1:1 or reversible, nor can it
    * be defined with a simple formula.  Thus, such a conversion is out of scope
    * for a codec library.  However, the TurboJPEG API allows for compressing
-   * CMYK pixels into a YCCK JPEG image (see {@link #CS_YCCK}) and
-   * decompressing YCCK JPEG images into CMYK pixels.
+   * packed-pixel CMYK images into YCCK JPEG images (see {@link #CS_YCCK}) and
+   * decompressing YCCK JPEG images into packed-pixel CMYK images.
    */
   public static final int PF_CMYK = 11;
 
@@ -214,7 +214,7 @@ public final class TJ {
   /**
    * Returns the pixel size (in bytes) for the given pixel format.
    *
-   * @param pixelFormat the pixel format (one of <code>PF_*</code>)
+   * @param pixelFormat the pixel format (one of {@link #PF_RGB PF_*})
    *
    * @return the pixel size (in bytes) for the given pixel format.
    */
@@ -235,7 +235,7 @@ public final class TJ {
    * then the red component will be
    * <code>pixel[TJ.getRedOffset(TJ.PF_BGRX)]</code>.
    *
-   * @param pixelFormat the pixel format (one of <code>PF_*</code>)
+   * @param pixelFormat the pixel format (one of {@link #PF_RGB PF_*})
    *
    * @return the red offset for the given pixel format, or -1 if the pixel
    * format does not have a red component.
@@ -257,7 +257,7 @@ public final class TJ {
    * then the green component will be
    * <code>pixel[TJ.getGreenOffset(TJ.PF_BGRX)]</code>.
    *
-   * @param pixelFormat the pixel format (one of <code>PF_*</code>)
+   * @param pixelFormat the pixel format (one of {@link #PF_RGB PF_*})
    *
    * @return the green offset for the given pixel format, or -1 if the pixel
    * format does not have a green component.
@@ -279,7 +279,7 @@ public final class TJ {
    * then the blue component will be
    * <code>pixel[TJ.getBlueOffset(TJ.PF_BGRX)]</code>.
    *
-   * @param pixelFormat the pixel format (one of <code>PF_*</code>)
+   * @param pixelFormat the pixel format (one of {@link #PF_RGB PF_*})
    *
    * @return the blue offset for the given pixel format, or -1 if the pixel
    * format does not have a blue component.
@@ -301,7 +301,7 @@ public final class TJ {
    * then the alpha component will be
    * <code>pixel[TJ.getAlphaOffset(TJ.PF_BGRA)]</code>.
    *
-   * @param pixelFormat the pixel format (one of <code>PF_*</code>)
+   * @param pixelFormat the pixel format (one of {@link #PF_RGB PF_*})
    *
    * @return the alpha offset for the given pixel format, or -1 if the pixel
    * format does not have a alpha component.
@@ -324,8 +324,9 @@ public final class TJ {
    * RGB colorspace.  When compressing the JPEG image, the R, G, and B
    * components in the source image are reordered into image planes, but no
    * colorspace conversion or subsampling is performed.  RGB JPEG images can be
-   * decompressed to any of the extended RGB pixel formats or grayscale, but
-   * they cannot be decompressed to YUV images.
+   * decompressed to packed-pixel images with any of the extended RGB or
+   * grayscale pixel formats, but they cannot be decompressed to planar YUV
+   * images.
    */
   public static final int CS_RGB = 0;
   /**
@@ -339,26 +340,28 @@ public final class TJ {
    * transformation allowed the same signal to drive both black &amp; white and
    * color televisions, but JPEG images use YCbCr primarily because it allows
    * the color data to be optionally subsampled for the purposes of reducing
-   * bandwidth or disk space.  YCbCr is the most common JPEG colorspace, and
-   * YCbCr JPEG images can be compressed from and decompressed to any of the
-   * extended RGB pixel formats or grayscale, or they can be decompressed to
-   * YUV planar images.
+   * network or disk usage.  YCbCr is the most common JPEG colorspace, and
+   * YCbCr JPEG images can be compressed from and decompressed to packed-pixel
+   * images with any of the extended RGB or grayscale pixel formats.  YCbCr
+   * JPEG images can also be compressed from and decompressed to planar YUV
+   * images.
    */
   @SuppressWarnings("checkstyle:ConstantName")
   public static final int CS_YCbCr = 1;
   /**
    * Grayscale colorspace.  The JPEG image retains only the luminance data (Y
    * component), and any color data from the source image is discarded.
-   * Grayscale JPEG images can be compressed from and decompressed to any of
-   * the extended RGB pixel formats or grayscale, or they can be decompressed
-   * to YUV planar images.
+   * Grayscale JPEG images can be compressed from and decompressed to
+   * packed-pixel images with any of the extended RGB or grayscale pixel
+   * formats, or they can be compressed from and decompressed to planar YUV
+   * images.
    */
   public static final int CS_GRAY = 2;
   /**
    * CMYK colorspace.  When compressing the JPEG image, the C, M, Y, and K
    * components in the source image are reordered into image planes, but no
    * colorspace conversion or subsampling is performed.  CMYK JPEG images can
-   * only be decompressed to CMYK pixels.
+   * only be decompressed to packed-pixel images with the CMYK pixel format.
    */
   public static final int CS_CMYK = 3;
   /**
@@ -368,14 +371,14 @@ public final class TJ {
    * reversibly transformed into YCCK, and as with YCbCr, the chrominance
    * components in the YCCK pixels can be subsampled without incurring major
    * perceptual loss.  YCCK JPEG images can only be compressed from and
-   * decompressed to CMYK pixels.
+   * decompressed to packed-pixel images with the CMYK pixel format.
    */
   public static final int CS_YCCK = 4;
 
 
   /**
-   * The uncompressed source/destination image is stored in bottom-up (Windows,
-   * OpenGL) order, not top-down (X11) order.
+   * Rows in the packed-pixel source/destination image are stored in bottom-up
+   * (Windows, OpenGL) order rather than in top-down (X11) order.
    */
   public static final int FLAG_BOTTOMUP      = 2;
 
@@ -394,41 +397,39 @@ public final class TJ {
 
   /**
    * When decompressing an image that was compressed using chrominance
-   * subsampling, use the fastest chrominance upsampling algorithm available in
-   * the underlying codec.  The default is to use smooth upsampling, which
-   * creates a smooth transition between neighboring chrominance components in
-   * order to reduce upsampling artifacts in the decompressed image.
+   * subsampling, use the fastest chrominance upsampling algorithm available.
+   * The default is to use smooth upsampling, which creates a smooth transition
+   * between neighboring chrominance components in order to reduce upsampling
+   * artifacts in the decompressed image.
    */
   public static final int FLAG_FASTUPSAMPLE  = 256;
   /**
-   * Use the fastest DCT/IDCT algorithm available in the underlying codec.  The
-   * default if this flag is not specified is implementation-specific.  For
-   * example, the implementation of TurboJPEG for libjpeg[-turbo] uses the fast
-   * algorithm by default when compressing, because this has been shown to have
-   * only a very slight effect on accuracy, but it uses the accurate algorithm
-   * when decompressing, because this has been shown to have a larger effect.
+   * Use the fastest DCT/IDCT algorithm available.  The default if this flag is
+   * not specified is implementation-specific.  For example, the implementation
+   * of the TurboJPEG API in libjpeg-turbo uses the fast algorithm by default
+   * when compressing, because this has been shown to have only a very slight
+   * effect on accuracy, but it uses the accurate algorithm when decompressing,
+   * because this has been shown to have a larger effect.
    */
   public static final int FLAG_FASTDCT       = 2048;
   /**
-   * Use the most accurate DCT/IDCT algorithm available in the underlying
-   * codec.  The default if this flag is not specified is
-   * implementation-specific.  For example, the implementation of TurboJPEG for
-   * libjpeg[-turbo] uses the fast algorithm by default when compressing,
-   * because this has been shown to have only a very slight effect on accuracy,
-   * but it uses the accurate algorithm when decompressing, because this has
-   * been shown to have a larger effect.
+   * Use the most accurate DCT/IDCT algorithm available.  The default if this
+   * flag is not specified is implementation-specific.  For example, the
+   * implementation of the TurboJPEG API in libjpeg-turbo uses the fast
+   * algorithm by default when compressing, because this has been shown to have
+   * only a very slight effect on accuracy, but it uses the accurate algorithm
+   * when decompressing, because this has been shown to have a larger effect.
    */
   public static final int FLAG_ACCURATEDCT   = 4096;
   /**
    * Immediately discontinue the current compression/decompression/transform
-   * operation if the underlying codec throws a warning (non-fatal error).  The
-   * default behavior is to allow the operation to complete unless a fatal
-   * error is encountered.
+   * operation if a warning (non-fatal error) occurs.  The default behavior is
+   * to allow the operation to complete unless a fatal error is encountered.
    * <p>
    * NOTE: due to the design of the TurboJPEG Java API, only certain methods
    * (specifically, {@link TJDecompressor TJDecompressor.decompress*()} methods
-   * with a void return type) will complete and leave the output image in a
-   * fully recoverable state after a non-fatal error occurs.
+   * with a void return type) will complete and leave the destination image in
+   * a fully recoverable state after a non-fatal error occurs.
    */
   public static final int FLAG_STOPONWARNING = 8192;
   /**
@@ -455,13 +456,13 @@ public final class TJ {
    */
   public static final int NUMERR = 2;
   /**
-   * The error was non-fatal and recoverable, but the image may still be
-   * corrupt.
+   * The error was non-fatal and recoverable, but the destination image may
+   * still be corrupt.
    * <p>
    * NOTE: due to the design of the TurboJPEG Java API, only certain methods
    * (specifically, {@link TJDecompressor TJDecompressor.decompress*()} methods
-   * with a void return type) will complete and leave the output image in a
-   * fully recoverable state after a non-fatal error occurs.
+   * with a void return type) will complete and leave the destination image in
+   * a fully recoverable state after a non-fatal error occurs.
    */
   public static final int ERR_WARNING = 0;
   /**
@@ -479,7 +480,7 @@ public final class TJ {
    * @param height the height (in pixels) of the JPEG image
    *
    * @param jpegSubsamp the level of chrominance subsampling to be used when
-   * generating the JPEG image (one of {@link TJ TJ.SAMP_*})
+   * generating the JPEG image (one of {@link #SAMP_444 TJ.SAMP_*})
    *
    * @return the maximum size of the buffer (in bytes) required to hold a JPEG
    * image with the given width, height, and level of chrominance subsampling.
@@ -487,23 +488,27 @@ public final class TJ {
   public static native int bufSize(int width, int height, int jpegSubsamp);
 
   /**
-   * Returns the size of the buffer (in bytes) required to hold a YUV planar
-   * image with the given width, height, and level of chrominance subsampling.
+   * Returns the size of the buffer (in bytes) required to hold a unified
+   * planar YUV image with the given width, height, and level of chrominance
+   * subsampling.
    *
    * @param width the width (in pixels) of the YUV image
    *
-   * @param pad the width of each line in each plane of the image is padded to
-   * the nearest multiple of this number of bytes (must be a power of 2.)
+   * @param align row alignment (in bytes) of the YUV image (must be a power of
+   * 2.)  Setting this parameter to n specifies that each row in each plane of
+   * the YUV image will be padded to the nearest multiple of n bytes
+   * (1 = unpadded.)
    *
    * @param height the height (in pixels) of the YUV image
    *
    * @param subsamp the level of chrominance subsampling used in the YUV
-   * image (one of {@link TJ TJ.SAMP_*})
+   * image (one of {@link #SAMP_444 TJ.SAMP_*})
    *
-   * @return the size of the buffer (in bytes) required to hold a YUV planar
-   * image with the given width, height, and level of chrominance subsampling.
+   * @return the size of the buffer (in bytes) required to hold a unified
+   * planar YUV image with the given width, height, and level of chrominance
+   * subsampling.
    */
-  public static native int bufSizeYUV(int width, int pad, int height,
+  public static native int bufSizeYUV(int width, int align, int height,
                                       int subsamp);
 
   /**
@@ -523,16 +528,16 @@ public final class TJ {
    * @param width width (in pixels) of the YUV image.  NOTE: this is the width
    * of the whole image, not the plane width.
    *
-   * @param stride bytes per line in the image plane.
+   * @param stride bytes per row in the image plane.
    *
    * @param height height (in pixels) of the YUV image.  NOTE: this is the
    * height of the whole image, not the plane height.
    *
    * @param subsamp the level of chrominance subsampling used in the YUV
-   * image (one of {@link TJ TJ.SAMP_*})
+   * image (one of {@link #SAMP_444 TJ.SAMP_*})
    *
-   * @return the size of the buffer (in bytes) required to hold a YUV planar
-   * image with the given parameters.
+   * @return the size of the buffer (in bytes) required to hold a YUV image
+   * plane with the given parameters.
    */
   public static native int planeSizeYUV(int componentID, int width, int stride,
                                         int height, int subsamp);
@@ -547,7 +552,7 @@ public final class TJ {
    * @param width width (in pixels) of the YUV image
    *
    * @param subsamp the level of chrominance subsampling used in the YUV image
-   * (one of {@link TJ TJ.SAMP_*})
+   * (one of {@link #SAMP_444 TJ.SAMP_*})
    *
    * @return the plane width of a YUV image plane with the given parameters.
    */
@@ -563,7 +568,7 @@ public final class TJ {
    * @param height height (in pixels) of the YUV image
    *
    * @param subsamp the level of chrominance subsampling used in the YUV image
-   * (one of {@link TJ TJ.SAMP_*})
+   * (one of {@link #SAMP_444 TJ.SAMP_*})
    *
    * @return the plane height of a YUV image plane with the given parameters.
    */
@@ -571,11 +576,11 @@ public final class TJ {
                                        int subsamp);
 
   /**
-   * Returns a list of fractional scaling factors that the JPEG decompressor in
-   * this implementation of TurboJPEG supports.
+   * Returns a list of fractional scaling factors that the JPEG decompressor
+   * supports.
    *
-   * @return a list of fractional scaling factors that the JPEG decompressor in
-   * this implementation of TurboJPEG supports.
+   * @return a list of fractional scaling factors that the JPEG decompressor
+   * supports.
    */
   public static native TJScalingFactor[] getScalingFactors();
 
diff --git a/java/org/libjpegturbo/turbojpeg/TJCompressor.java b/java/org/libjpegturbo/turbojpeg/TJCompressor.java
index 6d4830f..d5bbd82 100644
--- a/java/org/libjpegturbo/turbojpeg/TJCompressor.java
+++ b/java/org/libjpegturbo/turbojpeg/TJCompressor.java
@@ -1,5 +1,6 @@
 /*
- * Copyright (C)2011-2015, 2018, 2020 D. R. Commander.  All Rights Reserved.
+ * Copyright (C)2011-2015, 2018, 2020, 2023 D. R. Commander.
+ *                                          All Rights Reserved.
  * Copyright (C)2015 Viktor Szathmáry.  All Rights Reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -49,7 +50,7 @@ public class TJCompressor implements Closeable {
   }
 
   /**
-   * Create a TurboJPEG compressor instance and associate the uncompressed
+   * Create a TurboJPEG compressor instance and associate the packed-pixel
    * source image stored in <code>srcImage</code> with the newly created
    * instance.
    *
@@ -85,7 +86,7 @@ public class TJCompressor implements Closeable {
   }
 
   /**
-   * Create a TurboJPEG compressor instance and associate the uncompressed
+   * Create a TurboJPEG compressor instance and associate the packed-pixel
    * source image stored in <code>srcImage</code> with the newly created
    * instance.
    *
@@ -110,11 +111,11 @@ public class TJCompressor implements Closeable {
   }
 
   /**
-   * Associate an uncompressed RGB, grayscale, or CMYK source image with this
+   * Associate a packed-pixel RGB, grayscale, or CMYK source image with this
    * compressor instance.
    *
-   * @param srcImage image buffer containing RGB, grayscale, or CMYK pixels to
-   * be compressed or encoded.  This buffer is not modified.
+   * @param srcImage buffer containing a packed-pixel RGB, grayscale, or CMYK
+   * source image to be compressed or encoded.  This buffer is not modified.
    *
    * @param x x offset (in pixels) of the region in the source image from which
    * the JPEG or YUV image should be compressed/encoded
@@ -125,14 +126,16 @@ public class TJCompressor implements Closeable {
    * @param width width (in pixels) of the region in the source image from
    * which the JPEG or YUV image should be compressed/encoded
    *
-   * @param pitch bytes per line of the source image.  Normally, this should be
-   * <code>width * TJ.pixelSize(pixelFormat)</code> if the source image is
-   * unpadded, but you can use this parameter to, for instance, specify that
-   * the scanlines in the source image are padded to a 4-byte boundary or to
-   * compress/encode a JPEG or YUV image from a region of a larger source
-   * image.  You can also be clever and use this parameter to skip lines, etc.
-   * Setting this parameter to 0 is the equivalent of setting it to
-   * <code>width * TJ.pixelSize(pixelFormat)</code>.
+   * @param pitch bytes per row in the source image.  Normally this should be
+   * <code>width *
+   * </code>{@link TJ#getPixelSize TJ.getPixelSize}<code>(pixelFormat)</code>,
+   * if the source image is unpadded.  However, you can use this parameter to,
+   * for instance, specify that the rows in the source image are padded to the
+   * nearest multiple of 4 bytes or to compress/encode a JPEG or YUV image from
+   * a region of a larger source image.  You can also be clever and use this
+   * parameter to skip rows, etc.  Setting this parameter to 0 is the
+   * equivalent of setting it to <code>width *
+   * </code>{@link TJ#getPixelSize TJ.getPixelSize}<code>(pixelFormat)</code>.
    *
    * @param height height (in pixels) of the region in the source image from
    * which the JPEG or YUV image should be compressed/encoded
@@ -174,11 +177,12 @@ public class TJCompressor implements Closeable {
   }
 
   /**
-   * Associate an uncompressed RGB or grayscale source image with this
+   * Associate a packed-pixel RGB or grayscale source image with this
    * compressor instance.
    *
-   * @param srcImage a <code>BufferedImage</code> instance containing RGB or
-   * grayscale pixels to be compressed or encoded.  This image is not modified.
+   * @param srcImage a <code>BufferedImage</code> instance containing a
+   * packed-pixel RGB or grayscale source image to be compressed or encoded.
+   * This image is not modified.
    *
    * @param x x offset (in pixels) of the region in the source image from which
    * the JPEG or YUV image should be compressed/encoded
@@ -260,11 +264,10 @@ public class TJCompressor implements Closeable {
   }
 
   /**
-   * Associate an uncompressed YUV planar source image with this compressor
-   * instance.
+   * Associate a planar YUV source image with this compressor instance.
    *
-   * @param srcImage YUV planar image to be compressed.  This image is not
-   * modified.
+   * @param srcImage planar YUV source image to be compressed.  This image is
+   * not modified.
    */
   public void setSourceImage(YUVImage srcImage) throws TJException {
     if (handle == 0) init();
@@ -281,16 +284,16 @@ public class TJCompressor implements Closeable {
    * {@link TJ#CS_YCbCr}) or from CMYK to YCCK (see {@link TJ#CS_YCCK}) as part
    * of the JPEG compression process, some of the Cb and Cr (chrominance)
    * components can be discarded or averaged together to produce a smaller
-   * image with little perceptible loss of image clarity (the human eye is more
-   * sensitive to small changes in brightness than to small changes in color.)
-   * This is called "chrominance subsampling".
+   * image with little perceptible loss of image clarity.  (The human eye is
+   * more sensitive to small changes in brightness than to small changes in
+   * color.)  This is called "chrominance subsampling".
    * <p>
-   * NOTE: This method has no effect when compressing a JPEG image from a YUV
-   * planar source.  In that case, the level of chrominance subsampling in
-   * the JPEG image is determined by the source.  Furthermore, this method has
-   * no effect when encoding to a pre-allocated {@link YUVImage} instance.  In
-   * that case, the level of chrominance subsampling is determined by the
-   * destination.
+   * NOTE: This method has no effect when compressing a JPEG image from a
+   * planar YUV source image.  In that case, the level of chrominance
+   * subsampling in the JPEG image is determined by the source image.
+   * Furthermore, this method has no effect when encoding to a pre-allocated
+   * {@link YUVImage} instance.  In that case, the level of chrominance
+   * subsampling is determined by the destination image.
    *
    * @param newSubsamp the level of chrominance subsampling to use in
    * subsequent compress/encode oeprations (one of
@@ -315,8 +318,9 @@ public class TJCompressor implements Closeable {
   }
 
   /**
-   * Compress the uncompressed source image associated with this compressor
-   * instance and output a JPEG image to the given destination buffer.
+   * Compress the packed-pixel or planar YUV source image associated with this
+   * compressor instance and output a JPEG image to the given destination
+   * buffer.
    *
    * @param dstBuf buffer that will receive the JPEG image.  Use
    * {@link TJ#bufSize} to determine the maximum size for this buffer based on
@@ -366,8 +370,8 @@ public class TJCompressor implements Closeable {
   }
 
   /**
-   * Compress the uncompressed source image associated with this compressor
-   * instance and return a buffer containing a JPEG image.
+   * Compress the packed-pixel or planar YUV source image associated with this
+   * compressor instance and return a buffer containing a JPEG image.
    *
    * @param flags the bitwise OR of one or more of
    * {@link TJ#FLAG_BOTTOMUP TJ.FLAG_*}
@@ -417,14 +421,14 @@ public class TJCompressor implements Closeable {
   }
 
   /**
-   * Encode the uncompressed source image associated with this compressor
-   * instance into a YUV planar image and store it in the given
-   * <code>YUVImage</code> instance.   This method uses the accelerated color
-   * conversion routines in TurboJPEG's underlying codec but does not execute
-   * any of the other steps in the JPEG compression process.  Encoding
-   * CMYK source images to YUV is not supported.
-   *
-   * @param dstImage {@link YUVImage} instance that will receive the YUV planar
+   * Encode the packed-pixel source image associated with this compressor
+   * instance into a planar YUV image and store it in the given
+   * {@link YUVImage} instance.  This method performs color conversion (which
+   * is accelerated in the libjpeg-turbo implementation) but does not execute
+   * any of the other steps in the JPEG compression process.  Encoding CMYK
+   * source images into YUV images is not supported.
+   *
+   * @param dstImage {@link YUVImage} instance that will receive the planar YUV
    * image
    *
    * @param flags the bitwise OR of one or more of
@@ -469,52 +473,54 @@ public class TJCompressor implements Closeable {
   }
 
   /**
-   * Encode the uncompressed source image associated with this compressor
-   * instance into a unified YUV planar image buffer and return a
-   * <code>YUVImage</code> instance containing the encoded image.  This method
-   * uses the accelerated color conversion routines in TurboJPEG's underlying
-   * codec but does not execute any of the other steps in the JPEG compression
-   * process.  Encoding CMYK source images to YUV is not supported.
+   * Encode the packed-pixel source image associated with this compressor
+   * instance into a unified planar YUV image and return a {@link YUVImage}
+   * instance containing the encoded image.  This method performs color
+   * conversion (which is accelerated in the libjpeg-turbo implementation) but
+   * does not execute any of the other steps in the JPEG compression process.
+   * Encoding CMYK source images into YUV images is not supported.
    *
-   * @param pad the width of each line in each plane of the YUV image will be
-   * padded to the nearest multiple of this number of bytes (must be a power of
-   * 2.)
+   * @param align row alignment (in bytes) of the YUV image (must be a power of
+   * 2.)  Setting this parameter to n will cause each row in each plane of the
+   * YUV image to be padded to the nearest multiple of n bytes (1 = unpadded.)
    *
    * @param flags the bitwise OR of one or more of
    * {@link TJ#FLAG_BOTTOMUP TJ.FLAG_*}
    *
-   * @return a YUV planar image.
+   * @return a {@link YUVImage} instance containing the unified planar YUV
+   * encoded image
    */
-  public YUVImage encodeYUV(int pad, int flags) throws TJException {
+  public YUVImage encodeYUV(int align, int flags) throws TJException {
     checkSourceImage();
     checkSubsampling();
-    if (pad < 1 || ((pad & (pad - 1)) != 0))
+    if (align < 1 || ((align & (align - 1)) != 0))
       throw new IllegalStateException("Invalid argument in encodeYUV()");
-    YUVImage dstYUVImage = new YUVImage(srcWidth, pad, srcHeight, subsamp);
+    YUVImage dstYUVImage = new YUVImage(srcWidth, align, srcHeight, subsamp);
     encodeYUV(dstYUVImage, flags);
     return dstYUVImage;
   }
 
   /**
-   * Encode the uncompressed source image associated with this compressor
+   * Encode the packed-pixel source image associated with this compressor
    * instance into separate Y, U (Cb), and V (Cr) image planes and return a
-   * <code>YUVImage</code> instance containing the encoded image planes.  This
-   * method uses the accelerated color conversion routines in TurboJPEG's
-   * underlying codec but does not execute any of the other steps in the JPEG
-   * compression process.  Encoding CMYK source images to YUV is not supported.
+   * {@link YUVImage} instance containing the encoded image planes.  This
+   * method performs color conversion (which is accelerated in the
+   * libjpeg-turbo implementation) but does not execute any of the other steps
+   * in the JPEG compression process.  Encoding CMYK source images into YUV
+   * images is not supported.
    *
    * @param strides an array of integers, each specifying the number of bytes
-   * per line in the corresponding plane of the output image.  Setting the
-   * stride for any plane to 0 is the same as setting it to the component width
-   * of the plane.  If <code>strides</code> is null, then the strides for all
-   * planes will be set to their respective component widths.  You can adjust
-   * the strides in order to add an arbitrary amount of line padding to each
-   * plane.
+   * per row in the corresponding plane of the YUV source image.  Setting the
+   * stride for any plane to 0 is the same as setting it to the plane width
+   * (see {@link YUVImage}.)  If <code>strides</code> is null, then the strides
+   * for all planes will be set to their respective plane widths.  You can
+   * adjust the strides in order to add an arbitrary amount of row padding to
+   * each plane.
    *
    * @param flags the bitwise OR of one or more of
    * {@link TJ#FLAG_BOTTOMUP TJ.FLAG_*}
    *
-   * @return a YUV planar image.
+   * @return a {@link YUVImage} instance containing the encoded image planes
    */
   public YUVImage encodeYUV(int[] strides, int flags) throws TJException {
     checkSourceImage();
@@ -679,6 +685,5 @@ public class TJCompressor implements Closeable {
   private int subsamp = -1;
   private int jpegQuality = -1;
   private int compressedSize = 0;
-  private int yuvPad = 4;
   private ByteOrder byteOrder = null;
 }
diff --git a/java/org/libjpegturbo/turbojpeg/TJCustomFilter.java b/java/org/libjpegturbo/turbojpeg/TJCustomFilter.java
index 9a34587..3a66fd9 100644
--- a/java/org/libjpegturbo/turbojpeg/TJCustomFilter.java
+++ b/java/org/libjpegturbo/turbojpeg/TJCustomFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C)2011, 2013 D. R. Commander.  All Rights Reserved.
+ * Copyright (C)2011, 2013, 2023 D. R. Commander.  All Rights Reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -58,7 +58,7 @@ public interface TJCustomFilter {
    * component plane to which <code>coeffBuffer</code> belongs
    *
    * @param componentID ID number of the component plane to which
-   * <code>coeffBuffer</code> belongs (Y, Cb, and Cr have, respectively, ID's
+   * <code>coeffBuffer</code> belongs.  (Y, Cb, and Cr have, respectively, ID's
    * of 0, 1, and 2 in typical JPEG images.)
    *
    * @param transformID ID number of the transformed image to which
diff --git a/java/org/libjpegturbo/turbojpeg/TJDecompressor.java b/java/org/libjpegturbo/turbojpeg/TJDecompressor.java
index aba390b..e35f80a 100644
--- a/java/org/libjpegturbo/turbojpeg/TJDecompressor.java
+++ b/java/org/libjpegturbo/turbojpeg/TJDecompressor.java
@@ -1,5 +1,6 @@
 /*
- * Copyright (C)2011-2015, 2018, 2022 D. R. Commander.  All Rights Reserved.
+ * Copyright (C)2011-2015, 2018, 2022-2023 D. R. Commander.
+ *                                         All Rights Reserved.
  * Copyright (C)2015 Viktor Szathmáry.  All Rights Reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -50,10 +51,12 @@ public class TJDecompressor implements Closeable {
 
   /**
    * Create a TurboJPEG decompressor instance and associate the JPEG source
-   * image stored in <code>jpegImage</code> with the newly created instance.
+   * image or "abbreviated table specification" (AKA "tables-only") datastream
+   * stored in <code>jpegImage</code> with the newly created instance.
    *
-   * @param jpegImage JPEG image buffer (size of the JPEG image is assumed to
-   * be the length of the array.)  This buffer is not modified.
+   * @param jpegImage buffer containing a JPEG source image or tables-only
+   * datastream.  (The size of the JPEG image or datastream is assumed to be
+   * the length of the array.)  This buffer is not modified.
    */
   public TJDecompressor(byte[] jpegImage) throws TJException {
     init();
@@ -62,12 +65,15 @@ public class TJDecompressor implements Closeable {
 
   /**
    * Create a TurboJPEG decompressor instance and associate the JPEG source
-   * image of length <code>imageSize</code> bytes stored in
-   * <code>jpegImage</code> with the newly created instance.
+   * image or "abbreviated table specification" (AKA "tables-only") datastream
+   * of length <code>imageSize</code> bytes stored in <code>jpegImage</code>
+   * with the newly created instance.
    *
-   * @param jpegImage JPEG image buffer.  This buffer is not modified.
+   * @param jpegImage buffer containing a JPEG source image or tables-only
+   * datastream.  This buffer is not modified.
    *
-   * @param imageSize size of the JPEG image (in bytes)
+   * @param imageSize size of the JPEG source image or tables-only datastream
+   * (in bytes)
    */
   public TJDecompressor(byte[] jpegImage, int imageSize) throws TJException {
     init();
@@ -75,11 +81,11 @@ public class TJDecompressor implements Closeable {
   }
 
   /**
-   * Create a TurboJPEG decompressor instance and associate the YUV planar
+   * Create a TurboJPEG decompressor instance and associate the planar YUV
    * source image stored in <code>yuvImage</code> with the newly created
    * instance.
    *
-   * @param yuvImage {@link YUVImage} instance containing a YUV planar
+   * @param yuvImage {@link YUVImage} instance containing a planar YUV source
    * image to be decoded.  This image is not modified.
    */
   @SuppressWarnings("checkstyle:HiddenField")
@@ -93,18 +99,18 @@ public class TJDecompressor implements Closeable {
    * "tables-only") datastream of length <code>imageSize</code> bytes stored in
    * <code>jpegImage</code> with this decompressor instance.  If
    * <code>jpegImage</code> contains a JPEG image, then this image will be used
-   * as the source image for subsequent decompress operations.  Passing a
+   * as the source image for subsequent decompression operations.  Passing a
    * tables-only datastream to this method primes the decompressor with
    * quantization and Huffman tables that can be used when decompressing
    * subsequent "abbreviated image" datastreams.  This is useful, for instance,
    * when decompressing video streams in which all frames share the same
    * quantization and Huffman tables.
    *
-   * @param jpegImage buffer containing a JPEG image or an "abbreviated table
-   * specification" (AKA "tables-only") datastream.  This buffer is not
-   * modified.
+   * @param jpegImage buffer containing a JPEG source image or tables-only
+   * datastream.  This buffer is not modified.
    *
-   * @param imageSize size of the JPEG image (in bytes)
+   * @param imageSize size of the JPEG source image or tables-only datastream
+   * (in bytes)
    */
   public void setSourceImage(byte[] jpegImage, int imageSize)
                              throws TJException {
@@ -127,12 +133,12 @@ public class TJDecompressor implements Closeable {
   }
 
   /**
-   * Associate the specified YUV planar source image with this decompressor
-   * instance.  Subsequent decompress operations will decode this image into an
-   * RGB or grayscale destination image.
+   * Associate the specified planar YUV source image with this decompressor
+   * instance.  Subsequent decompression operations will decode this image into
+   * a packed-pixel RGB or grayscale destination image.
    *
-   * @param srcImage {@link YUVImage} instance containing a YUV planar image to
-   * be decoded.  This image is not modified.
+   * @param srcImage {@link YUVImage} instance containing a planar YUV source
+   * image to be decoded.  This image is not modified.
    */
   public void setSourceImage(YUVImage srcImage) {
     if (srcImage == null)
@@ -210,9 +216,9 @@ public class TJDecompressor implements Closeable {
   }
 
   /**
-   * Returns the JPEG image buffer associated with this decompressor instance.
+   * Returns the JPEG buffer associated with this decompressor instance.
    *
-   * @return the JPEG image buffer associated with this decompressor instance.
+   * @return the JPEG buffer associated with this decompressor instance.
    */
   public byte[] getJPEGBuf() {
     if (jpegBuf == null)
@@ -239,14 +245,14 @@ public class TJDecompressor implements Closeable {
    * height.
    *
    * @param desiredWidth desired width (in pixels) of the decompressed image.
-   * Setting this to 0 is the same as setting it to the width of the JPEG image
-   * (in other words, the width will not be considered when determining the
-   * scaled image size.)
+   * Setting this to 0 is the same as setting it to the width of the JPEG
+   * image.  (In other words, the width will not be considered when determining
+   * the scaled image size.)
    *
    * @param desiredHeight desired height (in pixels) of the decompressed image.
    * Setting this to 0 is the same as setting it to the height of the JPEG
-   * image (in other words, the height will not be considered when determining
-   * the scaled image size.)
+   * image.  (In other words, the height will not be considered when
+   * determining the scaled image size.)
    *
    * @return the width of the largest scaled-down image that the TurboJPEG
    * decompressor can generate without exceeding the desired image width and
@@ -280,14 +286,14 @@ public class TJDecompressor implements Closeable {
    * height.
    *
    * @param desiredWidth desired width (in pixels) of the decompressed image.
-   * Setting this to 0 is the same as setting it to the width of the JPEG image
-   * (in other words, the width will not be considered when determining the
-   * scaled image size.)
+   * Setting this to 0 is the same as setting it to the width of the JPEG
+   * image.  (In other words, the width will not be considered when determining
+   * the scaled image size.)
    *
    * @param desiredHeight desired height (in pixels) of the decompressed image.
    * Setting this to 0 is the same as setting it to the height of the JPEG
-   * image (in other words, the height will not be considered when determining
-   * the scaled image size.)
+   * image.  (In other words, the height will not be considered when
+   * determining the scaled image size.)
    *
    * @return the height of the largest scaled-down image that the TurboJPEG
    * decompressor can generate without exceeding the desired image width and
@@ -316,27 +322,27 @@ public class TJDecompressor implements Closeable {
   }
 
   /**
-   * Decompress the JPEG source image or decode the YUV source image associated
-   * with this decompressor instance and output a grayscale, RGB, or CMYK image
-   * to the given destination buffer.
+   * Decompress the JPEG source image or decode the planar YUV source image
+   * associated with this decompressor instance and output a packed-pixel
+   * grayscale, RGB, or CMYK image to the given destination buffer.
    * <p>
-   * NOTE: The output image is fully recoverable if this method throws a
+   * NOTE: The destination image is fully recoverable if this method throws a
    * non-fatal {@link TJException} (unless
    * {@link TJ#FLAG_STOPONWARNING TJ.FLAG_STOPONWARNING} is specified.)
    *
-   * @param dstBuf buffer that will receive the decompressed/decoded image.
-   * If the source image is a JPEG image, then this buffer should normally be
-   * <code>pitch * scaledHeight</code> bytes in size, where
-   * <code>scaledHeight</code> can be determined by calling <code>
-   * scalingFactor.{@link TJScalingFactor#getScaled getScaled}(jpegHeight)
-   * </code> with one of the scaling factors returned from {@link
-   * TJ#getScalingFactors} or by calling {@link #getScaledHeight}.  If the
-   * source image is a YUV image, then this buffer should normally be
-   * <code>pitch * height</code> bytes in size, where <code>height</code> is
-   * the height of the YUV image.  However, the buffer may also be larger than
-   * the dimensions of the source image, in which case the <code>x</code>,
-   * <code>y</code>, and <code>pitch</code> parameters can be used to specify
-   * the region into which the source image should be decompressed/decoded.
+   * @param dstBuf buffer that will receive the packed-pixel
+   * decompressed/decoded image.  If the source image is a JPEG image, then
+   * this buffer should normally be <code>pitch * scaledHeight</code> bytes in
+   * size, where <code>scaledHeight</code> can be determined by calling
+   * <code>scalingFactor.</code>{@link TJScalingFactor#getScaled getScaled}<code>(jpegHeight)</code>
+   * with one of the scaling factors returned from {@link TJ#getScalingFactors}
+   * or by calling {@link #getScaledHeight}.  If the source image is a YUV
+   * image, then this buffer should normally be <code>pitch * height</code>
+   * bytes in size, where <code>height</code> is the height of the YUV image.
+   * However, the buffer may also be larger than the dimensions of the source
+   * image, in which case the <code>x</code>, <code>y</code>, and
+   * <code>pitch</code> parameters can be used to specify the region into which
+   * the source image should be decompressed/decoded.
    *
    * @param x x offset (in pixels) of the region in the destination image into
    * which the source image should be decompressed/decoded
@@ -350,22 +356,24 @@ public class TJDecompressor implements Closeable {
    * than the source image dimensions, then TurboJPEG will use scaling in the
    * JPEG decompressor to generate the largest possible image that will fit
    * within the desired dimensions.  Setting this to 0 is the same as setting
-   * it to the width of the JPEG image (in other words, the width will not be
+   * it to the width of the JPEG image.  (In other words, the width will not be
    * considered when determining the scaled image size.)  This parameter is
    * ignored if the source image is a YUV image.
    *
-   * @param pitch bytes per line of the destination image.  Normally, this
-   * should be set to <code>scaledWidth * TJ.pixelSize(pixelFormat)</code> if
-   * the destination image is unpadded, but you can use this to, for instance,
-   * pad each line of the destination image to a 4-byte boundary or to
-   * decompress/decode the source image into a region of a larger image.  NOTE:
-   * if the source image is a JPEG image, then <code>scaledWidth</code> can be
-   * determined by calling <code>
-   * scalingFactor.{@link TJScalingFactor#getScaled getScaled}(jpegWidth)
-   * </code> or by calling {@link #getScaledWidth}.  If the source image is a
-   * YUV image, then <code>scaledWidth</code> is the width of the YUV image.
+   * @param pitch bytes per row in the destination image.  Normally this should
+   * be set to <code>scaledWidth *
+   * </code>{@link TJ#getPixelSize TJ.getPixelSize}<code>(pixelFormat)</code>,
+   * if the destination image will be unpadded.  However, you can use this to,
+   * for instance, pad each row of the destination image to the nearest
+   * multiple of 4 bytes or to decompress/decode the source image into a region
+   * of a larger image.  NOTE: if the source image is a JPEG image, then
+   * <code>scaledWidth</code> can be determined by calling
+   * <code>scalingFactor.</code>{@link TJScalingFactor#getScaled getScaled}<code>(jpegWidth)</code>
+   * or by calling {@link #getScaledWidth}.  If the source image is a YUV
+   * image, then <code>scaledWidth</code> is the width of the YUV image.
    * Setting this parameter to 0 is the equivalent of setting it to
-   * <code>scaledWidth * TJ.pixelSize(pixelFormat)</code>.
+   * <code>scaledWidth *
+   * </code>{@link TJ#getPixelSize TJ.getPixelSize}<code>(pixelFormat)</code>.
    *
    * @param desiredHeight If the source image is a JPEG image, then this
    * specifies the desired height (in pixels) of the decompressed image (or
@@ -373,8 +381,8 @@ public class TJDecompressor implements Closeable {
    * than the source image dimensions, then TurboJPEG will use scaling in the
    * JPEG decompressor to generate the largest possible image that will fit
    * within the desired dimensions.  Setting this to 0 is the same as setting
-   * it to the height of the JPEG image (in other words, the height will not be
-   * considered when determining the scaled image size.)  This parameter is
+   * it to the height of the JPEG image.  (In other words, the height will not
+   * be considered when determining the scaled image size.)  This parameter is
    * ignored if the source image is a YUV image.
    *
    * @param pixelFormat pixel format of the decompressed/decoded image (one of
@@ -387,7 +395,7 @@ public class TJDecompressor implements Closeable {
                          int pitch, int desiredHeight, int pixelFormat,
                          int flags) throws TJException {
     if (jpegBuf == null && yuvImage == null)
-      throw new IllegalStateException(NO_ASSOC_ERROR);
+      throw new IllegalStateException("No source image is associated with this instance");
     if (dstBuf == null || x < 0 || y < 0 || pitch < 0 ||
         (yuvImage != null && (desiredWidth < 0 || desiredHeight < 0)) ||
         pixelFormat < 0 || pixelFormat >= TJ.NUMPF || flags < 0)
@@ -421,8 +429,9 @@ public class TJDecompressor implements Closeable {
   }
 
   /**
-   * Decompress the JPEG source image associated with this decompressor
-   * instance and return a buffer containing the decompressed image.
+   * Decompress the JPEG source image or decode the planar YUV source image
+   * associated with this decompressor instance and return a buffer containing
+   * the packed-pixel decompressed image.
    *
    * @param desiredWidth see
    * {@link #decompress(byte[], int, int, int, int, int, int, int)}
@@ -442,7 +451,7 @@ public class TJDecompressor implements Closeable {
    * @param flags the bitwise OR of one or more of
    * {@link TJ#FLAG_BOTTOMUP TJ.FLAG_*}
    *
-   * @return a buffer containing the decompressed image.
+   * @return a buffer containing the packed-pixel decompressed image.
    */
   public byte[] decompress(int desiredWidth, int pitch, int desiredHeight,
                            int pixelFormat, int flags) throws TJException {
@@ -462,22 +471,22 @@ public class TJDecompressor implements Closeable {
 
   /**
    * Decompress the JPEG source image associated with this decompressor
-   * instance into a YUV planar image and store it in the given
-   * <code>YUVImage</code> instance.  This method performs JPEG decompression
-   * but leaves out the color conversion step, so a planar YUV image is
-   * generated instead of an RGB or grayscale image.  This method cannot be
-   * used to decompress JPEG source images with the CMYK or YCCK colorspace.
+   * instance into a planar YUV image and store it in the given
+   * {@link YUVImage} instance.  This method performs JPEG decompression but
+   * leaves out the color conversion step, so a planar YUV image is generated
+   * instead of a packed-pixel image.  This method cannot be used to decompress
+   * JPEG source images with the CMYK or YCCK colorspace.
    * <p>
-   * NOTE: The YUV planar output image is fully recoverable if this method
+   * NOTE: The planar YUV destination image is fully recoverable if this method
    * throws a non-fatal {@link TJException} (unless
    * {@link TJ#FLAG_STOPONWARNING TJ.FLAG_STOPONWARNING} is specified.)
    *
-   * @param dstImage {@link YUVImage} instance that will receive the YUV planar
-   * image.  The level of subsampling specified in this <code>YUVImage</code>
-   * instance must match that of the JPEG image, and the width and height
-   * specified in the <code>YUVImage</code> instance must match one of the
-   * scaled image sizes that TurboJPEG is capable of generating from the JPEG
-   * source image.
+   * @param dstImage {@link YUVImage} instance that will receive the planar YUV
+   * decompressed image.  The level of subsampling specified in this
+   * {@link YUVImage} instance must match that of the JPEG image, and the width
+   * and height specified in the {@link YUVImage} instance must match one of
+   * the scaled image sizes that the decompressor is capable of generating from
+   * the JPEG source image.
    *
    * @param flags the bitwise OR of one or more of
    * {@link TJ#FLAG_BOTTOMUP TJ.FLAG_*}
@@ -494,7 +503,7 @@ public class TJDecompressor implements Closeable {
                                        dstImage.getHeight());
     if (scaledWidth != dstImage.getWidth() ||
         scaledHeight != dstImage.getHeight())
-      throw new IllegalArgumentException("YUVImage dimensions do not match one of the scaled image sizes that TurboJPEG is capable of generating.");
+      throw new IllegalArgumentException("YUVImage dimensions do not match one of the scaled image sizes that the decompressor is capable of generating.");
     if (jpegSubsamp != dstImage.getSubsamp())
       throw new IllegalArgumentException("YUVImage subsampling level does not match that of the JPEG image");
 
@@ -517,40 +526,41 @@ public class TJDecompressor implements Closeable {
   /**
    * Decompress the JPEG source image associated with this decompressor
    * instance into a set of Y, U (Cb), and V (Cr) image planes and return a
-   * <code>YUVImage</code> instance containing the decompressed image planes.
-   * This method performs JPEG decompression but leaves out the color
-   * conversion step, so a planar YUV image is generated instead of an RGB or
-   * grayscale image.  This method cannot be used to decompress JPEG source
-   * images with the CMYK or YCCK colorspace.
+   * {@link YUVImage} instance containing the decompressed image planes.  This
+   * method performs JPEG decompression but leaves out the color conversion
+   * step, so a planar YUV image is generated instead of a packed-pixel image.
+   * This method cannot be used to decompress JPEG source images with the CMYK
+   * or YCCK colorspace.
    *
    * @param desiredWidth desired width (in pixels) of the YUV image.  If the
    * desired image dimensions are different than the dimensions of the JPEG
    * image being decompressed, then TurboJPEG will use scaling in the JPEG
    * decompressor to generate the largest possible image that will fit within
    * the desired dimensions.  Setting this to 0 is the same as setting it to
-   * the width of the JPEG image (in other words, the width will not be
+   * the width of the JPEG image.  (In other words, the width will not be
    * considered when determining the scaled image size.)
    *
    * @param strides an array of integers, each specifying the number of bytes
-   * per line in the corresponding plane of the output image.  Setting the
-   * stride for any plane to 0 is the same as setting it to the scaled
-   * component width of the plane.  If <tt>strides</tt> is NULL, then the
-   * strides for all planes will be set to their respective scaled component
-   * widths.  You can adjust the strides in order to add an arbitrary amount of
-   * line padding to each plane.
+   * per row in the corresponding plane of the YUV image.  Setting the stride
+   * for any plane to 0 is the same as setting it to the scaled plane width
+   * (see {@link YUVImage}.)  If <code>strides</code> is null, then the strides
+   * for all planes will be set to their respective scaled plane widths.  You
+   * can adjust the strides in order to add an arbitrary amount of row padding
+   * to each plane.
    *
    * @param desiredHeight desired height (in pixels) of the YUV image.  If the
    * desired image dimensions are different than the dimensions of the JPEG
    * image being decompressed, then TurboJPEG will use scaling in the JPEG
    * decompressor to generate the largest possible image that will fit within
    * the desired dimensions.  Setting this to 0 is the same as setting it to
-   * the height of the JPEG image (in other words, the height will not be
+   * the height of the JPEG image.  (In other words, the height will not be
    * considered when determining the scaled image size.)
    *
    * @param flags the bitwise OR of one or more of
    * {@link TJ#FLAG_BOTTOMUP TJ.FLAG_*}
    *
-   * @return a YUV planar image.
+   * @return a {@link YUVImage} instance containing the decompressed image
+   * planes
    */
   public YUVImage decompressToYUV(int desiredWidth, int[] strides,
                                   int desiredHeight,
@@ -574,40 +584,41 @@ public class TJDecompressor implements Closeable {
 
   /**
    * Decompress the JPEG source image associated with this decompressor
-   * instance into a unified YUV planar image buffer and return a
-   * <code>YUVImage</code> instance containing the decompressed image.  This
-   * method performs JPEG decompression but leaves out the color conversion
-   * step, so a planar YUV image is generated instead of an RGB or grayscale
-   * image.  This method cannot be used to decompress JPEG source images with
-   * the CMYK or YCCK colorspace.
+   * instance into a unified planar YUV image and return a {@link YUVImage}
+   * instance containing the decompressed image.  This method performs JPEG
+   * decompression but leaves out the color conversion step, so a planar YUV
+   * image is generated instead of a packed-pixel image.  This method cannot be
+   * used to decompress JPEG source images with the CMYK or YCCK colorspace.
    *
    * @param desiredWidth desired width (in pixels) of the YUV image.  If the
    * desired image dimensions are different than the dimensions of the JPEG
    * image being decompressed, then TurboJPEG will use scaling in the JPEG
    * decompressor to generate the largest possible image that will fit within
    * the desired dimensions.  Setting this to 0 is the same as setting it to
-   * the width of the JPEG image (in other words, the width will not be
+   * the width of the JPEG image.  (In other words, the width will not be
    * considered when determining the scaled image size.)
    *
-   * @param pad the width of each line in each plane of the YUV image will be
-   * padded to the nearest multiple of this number of bytes (must be a power of
-   * 2.)
+   * @param align row alignment (in bytes) of the YUV image (must be a power of
+   * 2.)  Setting this parameter to n will cause each row in each plane of the
+   * YUV image to be padded to the nearest multiple of n bytes (1 = unpadded.)
    *
    * @param desiredHeight desired height (in pixels) of the YUV image.  If the
    * desired image dimensions are different than the dimensions of the JPEG
    * image being decompressed, then TurboJPEG will use scaling in the JPEG
    * decompressor to generate the largest possible image that will fit within
    * the desired dimensions.  Setting this to 0 is the same as setting it to
-   * the height of the JPEG image (in other words, the height will not be
+   * the height of the JPEG image.  (In other words, the height will not be
    * considered when determining the scaled image size.)
    *
    * @param flags the bitwise OR of one or more of
    * {@link TJ#FLAG_BOTTOMUP TJ.FLAG_*}
    *
-   * @return a YUV planar image.
+   * @return a {@link YUVImage} instance containing the unified planar YUV
+   * decompressed image
    */
-  public YUVImage decompressToYUV(int desiredWidth, int pad, int desiredHeight,
-                                  int flags) throws TJException {
+  public YUVImage decompressToYUV(int desiredWidth, int align,
+                                  int desiredHeight, int flags)
+                                  throws TJException {
     if (flags < 0)
       throw new IllegalArgumentException("Invalid argument in decompressToYUV()");
     if (jpegWidth < 1 || jpegHeight < 1 || jpegSubsamp < 0)
@@ -619,7 +630,7 @@ public class TJDecompressor implements Closeable {
 
     int scaledWidth = getScaledWidth(desiredWidth, desiredHeight);
     int scaledHeight = getScaledHeight(desiredWidth, desiredHeight);
-    YUVImage dstYUVImage = new YUVImage(scaledWidth, pad, scaledHeight,
+    YUVImage dstYUVImage = new YUVImage(scaledWidth, align, scaledHeight,
                                         jpegSubsamp);
     decompressToYUV(dstYUVImage, flags);
     return dstYUVImage;
@@ -637,27 +648,27 @@ public class TJDecompressor implements Closeable {
   }
 
   /**
-   * Decompress the JPEG source image or decode the YUV source image associated
-   * with this decompressor instance and output a grayscale, RGB, or CMYK image
-   * to the given destination buffer.
+   * Decompress the JPEG source image or decode the planar YUV source image
+   * associated with this decompressor instance and output a packed-pixel
+   * grayscale, RGB, or CMYK image to the given destination buffer.
    * <p>
-   * NOTE: The output image is fully recoverable if this method throws a
+   * NOTE: The destination image is fully recoverable if this method throws a
    * non-fatal {@link TJException} (unless
    * {@link TJ#FLAG_STOPONWARNING TJ.FLAG_STOPONWARNING} is specified.)
    *
-   * @param dstBuf buffer that will receive the decompressed/decoded image.
-   * If the source image is a JPEG image, then this buffer should normally be
-   * <code>stride * scaledHeight</code> pixels in size, where
-   * <code>scaledHeight</code> can be determined by calling <code>
-   * scalingFactor.{@link TJScalingFactor#getScaled getScaled}(jpegHeight)
-   * </code> with one of the scaling factors returned from {@link
-   * TJ#getScalingFactors} or by calling {@link #getScaledHeight}.  If the
-   * source image is a YUV image, then this buffer should normally be
-   * <code>stride * height</code> pixels in size, where <code>height</code> is
-   * the height of the YUV image.  However, the buffer may also be larger than
-   * the dimensions of the JPEG image, in which case the <code>x</code>,
-   * <code>y</code>, and <code>stride</code> parameters can be used to specify
-   * the region into which the source image should be decompressed.
+   * @param dstBuf buffer that will receive the packed-pixel
+   * decompressed/decoded image.  If the source image is a JPEG image, then
+   * this buffer should normally be <code>stride * scaledHeight</code> pixels
+   * in size, where <code>scaledHeight</code> can be determined by calling
+   * <code>scalingFactor.</code>{@link TJScalingFactor#getScaled getScaled}<code>(jpegHeight)</code>
+   * with one of the scaling factors returned from {@link TJ#getScalingFactors}
+   * or by calling {@link #getScaledHeight}.  If the source image is a YUV
+   * image, then this buffer should normally be <code>stride * height</code>
+   * pixels in size, where <code>height</code> is the height of the YUV image.
+   * However, the buffer may also be larger than the dimensions of the JPEG
+   * image, in which case the <code>x</code>, <code>y</code>, and
+   * <code>stride</code> parameters can be used to specify the region into
+   * which the source image should be decompressed.
    *
    * @param x x offset (in pixels) of the region in the destination image into
    * which the source image should be decompressed/decoded
@@ -671,18 +682,18 @@ public class TJDecompressor implements Closeable {
    * than the source image dimensions, then TurboJPEG will use scaling in the
    * JPEG decompressor to generate the largest possible image that will fit
    * within the desired dimensions.  Setting this to 0 is the same as setting
-   * it to the width of the JPEG image (in other words, the width will not be
+   * it to the width of the JPEG image.  (In other words, the width will not be
    * considered when determining the scaled image size.)  This parameter is
    * ignored if the source image is a YUV image.
    *
-   * @param stride pixels per line of the destination image.  Normally, this
+   * @param stride pixels per row in the destination image.  Normally this
    * should be set to <code>scaledWidth</code>, but you can use this to, for
    * instance, decompress the JPEG image into a region of a larger image.
    * NOTE: if the source image is a JPEG image, then <code>scaledWidth</code>
-   * can be determined by calling <code>
-   * scalingFactor.{@link TJScalingFactor#getScaled getScaled}(jpegWidth)
-   * </code> or by calling {@link #getScaledWidth}.  If the source image is a
-   * YUV image, then <code>scaledWidth</code> is the width of the YUV image.
+   * can be determined by calling
+   * <code>scalingFactor.</code>{@link TJScalingFactor#getScaled getScaled}<code>(jpegWidth)</code>
+   * or by calling {@link #getScaledWidth}.  If the source image is a YUV
+   * image, then <code>scaledWidth</code> is the width of the YUV image.
    * Setting this parameter to 0 is the equivalent of setting it to
    * <code>scaledWidth</code>.
    *
@@ -692,8 +703,8 @@ public class TJDecompressor implements Closeable {
    * than the source image dimensions, then TurboJPEG will use scaling in the
    * JPEG decompressor to generate the largest possible image that will fit
    * within the desired dimensions.  Setting this to 0 is the same as setting
-   * it to the height of the JPEG image (in other words, the height will not be
-   * considered when determining the scaled image size.)  This parameter is
+   * it to the height of the JPEG image.  (In other words, the height will not
+   * be considered when determining the scaled image size.)  This parameter is
    * ignored if the source image is a YUV image.
    *
    * @param pixelFormat pixel format of the decompressed image (one of
@@ -706,7 +717,7 @@ public class TJDecompressor implements Closeable {
                          int stride, int desiredHeight, int pixelFormat,
                          int flags) throws TJException {
     if (jpegBuf == null && yuvImage == null)
-      throw new IllegalStateException(NO_ASSOC_ERROR);
+      throw new IllegalStateException("No source image is associated with this instance");
     if (dstBuf == null || x < 0 || y < 0 || stride < 0 ||
         (yuvImage != null && (desiredWidth < 0 || desiredHeight < 0)) ||
         pixelFormat < 0 || pixelFormat >= TJ.NUMPF || flags < 0)
@@ -722,21 +733,22 @@ public class TJDecompressor implements Closeable {
   }
 
   /**
-   * Decompress the JPEG source image or decode the YUV source image associated
-   * with this decompressor instance and output a decompressed/decoded image to
-   * the given <code>BufferedImage</code> instance.
+   * Decompress the JPEG source image or decode the planar YUV source image
+   * associated with this decompressor instance and output a packed-pixel
+   * decompressed/decoded image to the given <code>BufferedImage</code>
+   * instance.
    * <p>
-   * NOTE: The output image is fully recoverable if this method throws a
+   * NOTE: The destination image is fully recoverable if this method throws a
    * non-fatal {@link TJException} (unless
    * {@link TJ#FLAG_STOPONWARNING TJ.FLAG_STOPONWARNING} is specified.)
    *
    * @param dstImage a <code>BufferedImage</code> instance that will receive
-   * the decompressed/decoded image.  If the source image is a JPEG image, then
-   * the width and height of the <code>BufferedImage</code> instance must match
-   * one of the scaled image sizes that TurboJPEG is capable of generating from
-   * the JPEG image.  If the source image is a YUV image, then the width and
-   * height of the <code>BufferedImage</code> instance must match the width and
-   * height of the YUV image.
+   * the packed-pixel decompressed/decoded image.  If the source image is a
+   * JPEG image, then the width and height of the <code>BufferedImage</code>
+   * instance must match one of the scaled image sizes that the decompressor is
+   * capable of generating from the JPEG image.  If the source image is a YUV
+   * image, then the width and height of the <code>BufferedImage</code>
+   * instance must match the width and height of the YUV image.
    *
    * @param flags the bitwise OR of one or more of
    * {@link TJ#FLAG_BOTTOMUP TJ.FLAG_*}
@@ -759,7 +771,7 @@ public class TJDecompressor implements Closeable {
       scaledWidth = getScaledWidth(desiredWidth, desiredHeight);
       scaledHeight = getScaledHeight(desiredWidth, desiredHeight);
       if (scaledWidth != desiredWidth || scaledHeight != desiredHeight)
-        throw new IllegalArgumentException("BufferedImage dimensions do not match one of the scaled image sizes that TurboJPEG is capable of generating.");
+        throw new IllegalArgumentException("BufferedImage dimensions do not match one of the scaled image sizes that the decompressor is capable of generating.");
     }
     int pixelFormat;  boolean intPixels = false;
     if (byteOrder == null)
@@ -827,9 +839,10 @@ public class TJDecompressor implements Closeable {
   }
 
   /**
-   * Decompress the JPEG source image or decode the YUV source image associated
-   * with this decompressor instance and return a <code>BufferedImage</code>
-   * instance containing the decompressed/decoded image.
+   * Decompress the JPEG source image or decode the planar YUV source image
+   * associated with this decompressor instance and return a
+   * <code>BufferedImage</code> instance containing the packed-pixel
+   * decompressed/decoded image.
    *
    * @param desiredWidth see
    * {@link #decompress(byte[], int, int, int, int, int, int, int)} for
@@ -846,7 +859,7 @@ public class TJDecompressor implements Closeable {
    * @param flags the bitwise OR of one or more of
    * {@link TJ#FLAG_BOTTOMUP TJ.FLAG_*}
    *
-   * @return a <code>BufferedImage</code> instance containing the
+   * @return a <code>BufferedImage</code> instance containing the packed-pixel
    * decompressed/decoded image.
    */
   public BufferedImage decompress(int desiredWidth, int desiredHeight,
diff --git a/java/org/libjpegturbo/turbojpeg/TJTransform.java b/java/org/libjpegturbo/turbojpeg/TJTransform.java
index 41c4b45..91bcc6b 100644
--- a/java/org/libjpegturbo/turbojpeg/TJTransform.java
+++ b/java/org/libjpegturbo/turbojpeg/TJTransform.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C)2011, 2013, 2018 D. R. Commander.  All Rights Reserved.
+ * Copyright (C)2011, 2013, 2018, 2023 D. R. Commander.  All Rights Reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -97,7 +97,7 @@ public class TJTransform extends Rectangle {
    * the level of chrominance subsampling used.  If the image's width or height
    * is not evenly divisible by the MCU block size (see {@link TJ#getMCUWidth}
    * and {@link TJ#getMCUHeight}), then there will be partial MCU blocks on the
-   * right and/or bottom edges.   It is not possible to move these partial MCU
+   * right and/or bottom edges.  It is not possible to move these partial MCU
    * blocks to the top or left of the image, so any transform that would
    * require that is "imperfect."  If this option is not specified, then any
    * partial MCU blocks that cannot be transformed will be left in place, which
@@ -114,8 +114,8 @@ public class TJTransform extends Rectangle {
    */
   public static final int OPT_CROP        = 4;
   /**
-   * This option will discard the color data in the input image and produce
-   * a grayscale output image.
+   * This option will discard the color data in the source image and produce a
+   * grayscale destination image.
    */
   public static final int OPT_GRAY        = 8;
   /**
@@ -127,17 +127,16 @@ public class TJTransform extends Rectangle {
    */
   public static final int OPT_NOOUTPUT    = 16;
   /**
-   * This option will enable progressive entropy coding in the output image
+   * This option will enable progressive entropy coding in the JPEG image
    * generated by this particular transform.  Progressive entropy coding will
    * generally improve compression relative to baseline entropy coding (the
-   * default), but it will reduce compression and decompression performance
-   * considerably.
+   * default), but it will reduce decompression performance considerably.
    */
   public static final int OPT_PROGRESSIVE = 32;
   /**
    * This option will prevent {@link TJTransformer#transform
    * TJTransformer.transform()} from copying any extra markers (including EXIF
-   * and ICC profile data) from the source image to the output image.
+   * and ICC profile data) from the source image to the destination image.
    */
   public static final int OPT_COPYNONE    = 64;
 
@@ -165,10 +164,10 @@ public class TJTransform extends Rectangle {
    * equivalent of setting it to (height of the source JPEG image -
    * <code>y</code>).
    *
-   * @param op one of the transform operations (<code>OP_*</code>)
+   * @param op one of the transform operations ({@link #OP_NONE OP_*})
    *
    * @param options the bitwise OR of one or more of the transform options
-   * (<code>OPT_*</code>)
+   * ({@link #OPT_PERFECT OPT_*})
    *
    * @param cf an instance of an object that implements the {@link
    * TJCustomFilter} interface, or null if no custom filter is needed
@@ -190,10 +189,10 @@ public class TJTransform extends Rectangle {
    * #TJTransform(int, int, int, int, int, int, TJCustomFilter)} for more
    * detail.
    *
-   * @param op one of the transform operations (<code>OP_*</code>)
+   * @param op one of the transform operations ({@link #OP_NONE OP_*})
    *
    * @param options the bitwise OR of one or more of the transform options
-   * (<code>OPT_*</code>)
+   * ({@link #OPT_PERFECT OPT_*})
    *
    * @param cf an instance of an object that implements the {@link
    * TJCustomFilter} interface, or null if no custom filter is needed
@@ -208,13 +207,14 @@ public class TJTransform extends Rectangle {
   }
 
   /**
-   * Transform operation (one of <code>OP_*</code>)
+   * Transform operation (one of {@link #OP_NONE OP_*})
    */
   @SuppressWarnings("checkstyle:VisibilityModifier")
   public int op = 0;
 
   /**
-   * Transform options (bitwise OR of one or more of <code>OPT_*</code>)
+   * Transform options (bitwise OR of one or more of
+   * {@link #OPT_PERFECT OPT_*})
    */
   @SuppressWarnings("checkstyle:VisibilityModifier")
   public int options = 0;
diff --git a/java/org/libjpegturbo/turbojpeg/TJTransformer.java b/java/org/libjpegturbo/turbojpeg/TJTransformer.java
index d7a56f3..2cbf0bf 100644
--- a/java/org/libjpegturbo/turbojpeg/TJTransformer.java
+++ b/java/org/libjpegturbo/turbojpeg/TJTransformer.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C)2011, 2013-2015 D. R. Commander.  All Rights Reserved.
+ * Copyright (C)2011, 2013-2015, 2023 D. R. Commander.  All Rights Reserved.
  * Copyright (C)2015 Viktor Szathmáry.  All Rights Reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -43,10 +43,12 @@ public class TJTransformer extends TJDecompressor {
 
   /**
    * Create a TurboJPEG lossless transformer instance and associate the JPEG
-   * image stored in <code>jpegImage</code> with the newly created instance.
+   * source image stored in <code>jpegImage</code> with the newly created
+   * instance.
    *
-   * @param jpegImage JPEG image buffer (size of the JPEG image is assumed to
-   * be the length of the array.)  This buffer is not modified.
+   * @param jpegImage buffer containing the JPEG source image to transform.
+   * (The size of the JPEG image is assumed to be the length of the array.)
+   * This buffer is not modified.
    */
   public TJTransformer(byte[] jpegImage) throws TJException {
     init();
@@ -55,12 +57,13 @@ public class TJTransformer extends TJDecompressor {
 
   /**
    * Create a TurboJPEG lossless transformer instance and associate the JPEG
-   * image of length <code>imageSize</code> bytes stored in
+   * source image of length <code>imageSize</code> bytes stored in
    * <code>jpegImage</code> with the newly created instance.
    *
-   * @param jpegImage JPEG image buffer.  This buffer is not modified.
+   * @param jpegImage buffer containing the JPEG source image to transform.
+   * This buffer is not modified.
    *
-   * @param imageSize size of the JPEG image (in bytes)
+   * @param imageSize size of the JPEG source image (in bytes)
    */
   public TJTransformer(byte[] jpegImage, int imageSize) throws TJException {
     init();
@@ -68,28 +71,29 @@ public class TJTransformer extends TJDecompressor {
   }
 
   /**
-   * Losslessly transform the JPEG image associated with this transformer
-   * instance into one or more JPEG images stored in the given destination
-   * buffers.  Lossless transforms work by moving the raw coefficients from one
-   * JPEG image structure to another without altering the values of the
-   * coefficients.  While this is typically faster than decompressing the
-   * image, transforming it, and re-compressing it, lossless transforms are not
-   * free.  Each lossless transform requires reading and performing Huffman
-   * decoding on all of the coefficients in the source image, regardless of the
-   * size of the destination image.  Thus, this method provides a means of
-   * generating multiple transformed images from the same source or of applying
-   * multiple transformations simultaneously, in order to eliminate the need to
-   * read the source coefficients multiple times.
+   * Losslessly transform the JPEG source image associated with this
+   * transformer instance into one or more JPEG images stored in the given
+   * destination buffers.  Lossless transforms work by moving the raw
+   * coefficients from one JPEG image structure to another without altering the
+   * values of the coefficients.  While this is typically faster than
+   * decompressing the image, transforming it, and re-compressing it, lossless
+   * transforms are not free.  Each lossless transform requires reading and
+   * performing Huffman decoding on all of the coefficients in the source
+   * image, regardless of the size of the destination image.  Thus, this method
+   * provides a means of generating multiple transformed images from the same
+   * source or of applying multiple transformations simultaneously, in order to
+   * eliminate the need to read the source coefficients multiple times.
    *
-   * @param dstBufs an array of image buffers.  <code>dstbufs[i]</code> will
-   * receive a JPEG image that has been transformed using the parameters in
-   * <code>transforms[i]</code>.  Use {@link TJ#bufSize} to determine the
-   * maximum size for each buffer based on the transformed or cropped width and
-   * height and the level of subsampling used in the source image.
+   * @param dstBufs an array of JPEG destination buffers.
+   * <code>dstbufs[i]</code> will receive a JPEG image that has been
+   * transformed using the parameters in <code>transforms[i]</code>.  Use
+   * {@link TJ#bufSize} to determine the maximum size for each buffer based on
+   * the transformed or cropped width and height and the level of subsampling
+   * used in the source image.
    *
    * @param transforms an array of {@link TJTransform} instances, each of
    * which specifies the transform parameters and/or cropping region for the
-   * corresponding transformed output image
+   * corresponding transformed JPEG image
    *
    * @param flags the bitwise OR of one or more of
    * {@link TJ#FLAG_BOTTOMUP TJ.FLAG_*}
@@ -103,13 +107,13 @@ public class TJTransformer extends TJDecompressor {
   }
 
   /**
-   * Losslessly transform the JPEG image associated with this transformer
-   * instance and return an array of {@link TJDecompressor} instances, each of
-   * which has a transformed JPEG image associated with it.
+   * Losslessly transform the JPEG source image associated with this
+   * transformer instance and return an array of {@link TJDecompressor}
+   * instances, each of which has a transformed JPEG image associated with it.
    *
    * @param transforms an array of {@link TJTransform} instances, each of
    * which specifies the transform parameters and/or cropping region for the
-   * corresponding transformed output image
+   * corresponding transformed JPEG image
    *
    * @param flags the bitwise OR of one or more of
    * {@link TJ#FLAG_BOTTOMUP TJ.FLAG_*}
@@ -139,10 +143,10 @@ public class TJTransformer extends TJDecompressor {
 
   /**
    * Returns an array containing the sizes of the transformed JPEG images
-   * generated by the most recent transform operation.
+   * (in bytes) generated by the most recent transform operation.
    *
    * @return an array containing the sizes of the transformed JPEG images
-   * generated by the most recent transform operation.
+   * (in bytes) generated by the most recent transform operation.
    */
   public int[] getTransformedSizes() {
     if (transformedSizes == null)
diff --git a/java/org/libjpegturbo/turbojpeg/YUVImage.java b/java/org/libjpegturbo/turbojpeg/YUVImage.java
index 4da9843..9483046 100644
--- a/java/org/libjpegturbo/turbojpeg/YUVImage.java
+++ b/java/org/libjpegturbo/turbojpeg/YUVImage.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C)2014, 2017 D. R. Commander.  All Rights Reserved.
+ * Copyright (C)2014, 2017, 2023 D. R. Commander.  All Rights Reserved.
  * Copyright (C)2015 Viktor Szathmáry.  All Rights Reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -30,7 +30,7 @@
 package org.libjpegturbo.turbojpeg;
 
 /**
- * This class encapsulates a YUV planar image and the metadata
+ * This class encapsulates a planar YUV image and the metadata
  * associated with it.  The TurboJPEG API allows both the JPEG compression and
  * decompression pipelines to be split into stages:  YUV encode, compress from
  * YUV, decompress to YUV, and YUV decode.  A <code>YUVImage</code> instance
@@ -38,30 +38,32 @@ package org.libjpegturbo.turbojpeg;
  * operations and as the source image for compress-from-YUV and YUV decode
  * operations.
  * <p>
- * Technically, the JPEG format uses the YCbCr colorspace (which technically is
- * not a "colorspace" but rather a "color transform"), but per the convention
- * of the digital video community, the TurboJPEG API uses "YUV" to refer to an
- * image format consisting of Y, Cb, and Cr image planes.
+ * Technically, the JPEG format uses the YCbCr colorspace (which is technically
+ * not a colorspace but a color transform), but per the convention of the
+ * digital video community, the TurboJPEG API uses "YUV" to refer to an image
+ * format consisting of Y, Cb, and Cr image planes.
  * <p>
  * Each plane is simply a 2D array of bytes, each byte representing the value
  * of one of the components (Y, Cb, or Cr) at a particular location in the
  * image.  The width and height of each plane are determined by the image
  * width, height, and level of chrominance subsampling.  The luminance plane
  * width is the image width padded to the nearest multiple of the horizontal
- * subsampling factor (2 in the case of 4:2:0 and 4:2:2, 4 in the case of
- * 4:1:1, 1 in the case of 4:4:4 or grayscale.)  Similarly, the luminance plane
- * height is the image height padded to the nearest multiple of the vertical
- * subsampling factor (2 in the case of 4:2:0 or 4:4:0, 1 in the case of 4:4:4
- * or grayscale.)  The chrominance plane width is equal to the luminance plane
- * width divided by the horizontal subsampling factor, and the chrominance
- * plane height is equal to the luminance plane height divided by the vertical
- * subsampling factor.
+ * subsampling factor (1 in the case of 4:4:4, grayscale, or 4:4:0; 2 in the
+ * case of 4:2:2 or 4:2:0; 4 in the case of 4:1:1.)  Similarly, the luminance
+ * plane height is the image height padded to the nearest multiple of the
+ * vertical subsampling factor (1 in the case of 4:4:4, 4:2:2, grayscale, or
+ * 4:1:1; 2 in the case of 4:2:0 or 4:4:0.)  This is irrespective of any
+ * additional padding that may be specified as an argument to the various
+ * YUVImage methods.  The chrominance plane width is equal to the luminance
+ * plane width divided by the horizontal subsampling factor, and the
+ * chrominance plane height is equal to the luminance plane height divided by
+ * the vertical subsampling factor.
  * <p>
  * For example, if the source image is 35 x 35 pixels and 4:2:2 subsampling is
  * used, then the luminance plane would be 36 x 35 bytes, and each of the
- * chrominance planes would be 18 x 35 bytes.  If you specify a line padding of
- * 4 bytes on top of this, then the luminance plane would be 36 x 35 bytes, and
- * each of the chrominance planes would be 20 x 35 bytes.
+ * chrominance planes would be 18 x 35 bytes.  If you specify a row alignment
+ * of 4 bytes on top of this, then the luminance plane would be 36 x 35 bytes,
+ * and each of the chrominance planes would be 20 x 35 bytes.
  */
 public class YUVImage {
 
@@ -75,7 +77,7 @@ public class YUVImage {
    * @param width width (in pixels) of the YUV image
    *
    * @param strides an array of integers, each specifying the number of bytes
-   * per line in the corresponding plane of the YUV image.  Setting the stride
+   * per row in the corresponding plane of the YUV image.  Setting the stride
    * for any plane to 0 is the same as setting it to the plane width (see
    * {@link YUVImage above}.)  If <code>strides</code> is null, then the
    * strides for all planes will be set to their respective plane widths.  When
@@ -92,22 +94,24 @@ public class YUVImage {
   }
 
   /**
-   * Create a new <code>YUVImage</code> instance backed by a unified image
-   * buffer, and allocate memory for the image buffer.
+   * Create a new <code>YUVImage</code> instance backed by a unified buffer,
+   * and allocate memory for the buffer.
    *
    * @param width width (in pixels) of the YUV image
    *
-   * @param pad Each line of each plane in the YUV image buffer will be padded
-   * to this number of bytes (must be a power of 2.)
+   * @param align row alignment (in bytes) of the YUV image (must be a power of
+   * 2.)  Setting this parameter to n specifies that each row in each plane of
+   * the YUV image will be padded to the nearest multiple of n bytes
+   * (1 = unpadded.)
    *
    * @param height height (in pixels) of the YUV image
    *
    * @param subsamp the level of chrominance subsampling to be used in the YUV
    * image (one of {@link TJ#SAMP_444 TJ.SAMP_*})
    */
-  public YUVImage(int width, int pad, int height, int subsamp) {
-    setBuf(new byte[TJ.bufSizeYUV(width, pad, height, subsamp)], width, pad,
-           height, subsamp);
+  public YUVImage(int width, int align, int height, int subsamp) {
+    setBuf(new byte[TJ.bufSizeYUV(width, align, height, subsamp)], width,
+           align, height, subsamp);
   }
 
   /**
@@ -117,8 +121,8 @@ public class YUVImage {
    * @param planes an array of buffers representing the Y, U (Cb), and V (Cr)
    * image planes (or just the Y plane, if the image is grayscale.)   These
    * planes can be contiguous or non-contiguous in memory.  Plane
-   * <code>i</code> should be at least <code>offsets[i] +
-   * {@link TJ#planeSizeYUV TJ.planeSizeYUV}(i, width, strides[i], height, subsamp)</code>
+   * <code>i</code> should be at least <code>offsets[i] + </code>
+   * {@link TJ#planeSizeYUV TJ.planeSizeYUV}<code>(i, width, strides[i], height, subsamp)</code>
    * bytes in size.
    *
    * @param offsets If this <code>YUVImage</code> instance represents a
@@ -130,11 +134,11 @@ public class YUVImage {
    * @param width width (in pixels) of the new YUV image (or subregion)
    *
    * @param strides an array of integers, each specifying the number of bytes
-   * per line in the corresponding plane of the YUV image.  Setting the stride
+   * per row in the corresponding plane of the YUV image.  Setting the stride
    * for any plane to 0 is the same as setting it to the plane width (see
    * {@link YUVImage above}.)  If <code>strides</code> is null, then the
    * strides for all planes will be set to their respective plane widths.  You
-   * can adjust the strides in order to add an arbitrary amount of line padding
+   * can adjust the strides in order to add an arbitrary amount of row padding
    * to each plane or to specify that this <code>YUVImage</code> instance is a
    * subregion of a larger image (in which case, <code>strides[i]</code> should
    * be set to the plane width of plane <code>i</code> in the larger image.)
@@ -150,29 +154,30 @@ public class YUVImage {
   }
 
   /**
-   * Create a new <code>YUVImage</code> instance from an existing unified image
+   * Create a new <code>YUVImage</code> instance from an existing unified
    * buffer.
    *
-   * @param yuvImage image buffer that contains or will contain YUV planar
-   * image data.  Use {@link TJ#bufSizeYUV} to determine the minimum size for
-   * this buffer.  The Y, U (Cb), and V (Cr) image planes are stored
-   * sequentially in the buffer (see {@link YUVImage above} for a description
-   * of the image format.)
+   * @param yuvImage buffer that contains or will receive a unified planar YUV
+   * image.  Use {@link TJ#bufSizeYUV} to determine the minimum size for this
+   * buffer.  The Y, U (Cb), and V (Cr) image planes are stored sequentially in
+   * the buffer.  (See {@link YUVImage above} for a description of the image
+   * format.)
    *
    * @param width width (in pixels) of the YUV image
    *
-   * @param pad the line padding used in the YUV image buffer.  For
-   * instance, if each line in each plane of the buffer is padded to the
-   * nearest multiple of 4 bytes, then <code>pad</code> should be set to 4.
+   * @param align row alignment (in bytes) of the YUV image (must be a power of
+   * 2.)  Setting this parameter to n specifies that each row in each plane of
+   * the YUV image will be padded to the nearest multiple of n bytes
+   * (1 = unpadded.)
    *
    * @param height height (in pixels) of the YUV image
    *
    * @param subsamp the level of chrominance subsampling used in the YUV
    * image (one of {@link TJ#SAMP_444 TJ.SAMP_*})
    */
-  public YUVImage(byte[] yuvImage, int width, int pad, int height,
+  public YUVImage(byte[] yuvImage, int width, int align, int height,
                   int subsamp) {
-    setBuf(yuvImage, width, pad, height, subsamp);
+    setBuf(yuvImage, width, align, height, subsamp);
   }
 
   /**
@@ -181,8 +186,8 @@ public class YUVImage {
    * @param planes an array of buffers representing the Y, U (Cb), and V (Cr)
    * image planes (or just the Y plane, if the image is grayscale.)  These
    * planes can be contiguous or non-contiguous in memory.  Plane
-   * <code>i</code> should be at least <code>offsets[i] +
-   * {@link TJ#planeSizeYUV TJ.planeSizeYUV}(i, width, strides[i], height, subsamp)</code>
+   * <code>i</code> should be at least <code>offsets[i] + </code>
+   * {@link TJ#planeSizeYUV TJ.planeSizeYUV}<code>(i, width, strides[i], height, subsamp)</code>
    * bytes in size.
    *
    * @param offsets If this <code>YUVImage</code> instance represents a
@@ -194,12 +199,12 @@ public class YUVImage {
    * @param width width (in pixels) of the YUV image (or subregion)
    *
    * @param strides an array of integers, each specifying the number of bytes
-   * per line in the corresponding plane of the YUV image.  Setting the stride
+   * per row in the corresponding plane of the YUV image.  Setting the stride
    * for any plane to 0 is the same as setting it to the plane width (see
    * {@link YUVImage above}.)  If <code>strides</code> is null, then the
    * strides for all planes will be set to their respective plane widths.  You
-   * can adjust the strides in order to add an arbitrary amount of line padding
-   * to each plane or to specify that this <code>YUVImage</code> image is a
+   * can adjust the strides in order to add an arbitrary amount of row padding
+   * to each plane or to specify that this <code>YUVImage</code> instance is a
    * subregion of a larger image (in which case, <code>strides[i]</code> should
    * be set to the plane width of plane <code>i</code> in the larger image.)
    *
@@ -263,32 +268,34 @@ public class YUVImage {
   }
 
   /**
-   * Assign a unified image buffer to this <code>YUVImage</code> instance.
+   * Assign a unified buffer to this <code>YUVImage</code> instance.
    *
-   * @param yuvImage image buffer that contains or will contain YUV planar
-   * image data.  Use {@link TJ#bufSizeYUV} to determine the minimum size for
-   * this buffer.  The Y, U (Cb), and V (Cr) image planes are stored
-   * sequentially in the buffer (see {@link YUVImage above} for a description
-   * of the image format.)
+   * @param yuvImage buffer that contains or will receive a unified planar YUV
+   * image.  Use {@link TJ#bufSizeYUV} to determine the minimum size for this
+   * buffer.  The Y, U (Cb), and V (Cr) image planes are stored sequentially in
+   * the buffer.  (See {@link YUVImage above} for a description of the image
+   * format.)
    *
    * @param width width (in pixels) of the YUV image
    *
-   * @param pad the line padding used in the YUV image buffer.  For
-   * instance, if each line in each plane of the buffer is padded to the
-   * nearest multiple of 4 bytes, then <code>pad</code> should be set to 4.
+   * @param align row alignment (in bytes) of the YUV image (must be a power of
+   * 2.)  Setting this parameter to n specifies that each row in each plane of
+   * the YUV image will be padded to the nearest multiple of n bytes
+   * (1 = unpadded.)
    *
    * @param height height (in pixels) of the YUV image
    *
    * @param subsamp the level of chrominance subsampling used in the YUV
    * image (one of {@link TJ#SAMP_444 TJ.SAMP_*})
    */
-  public void setBuf(byte[] yuvImage, int width, int pad, int height,
+  public void setBuf(byte[] yuvImage, int width, int align, int height,
                      int subsamp) {
-    if (yuvImage == null || width < 1 || pad < 1 || ((pad & (pad - 1)) != 0) ||
-        height < 1 || subsamp < 0 || subsamp >= TJ.NUMSAMP)
+    if (yuvImage == null || width < 1 || align < 1 ||
+        ((align & (align - 1)) != 0) || height < 1 || subsamp < 0 ||
+        subsamp >= TJ.NUMSAMP)
       throw new IllegalArgumentException("Invalid argument in YUVImage::setBuf()");
-    if (yuvImage.length < TJ.bufSizeYUV(width, pad, height, subsamp))
-      throw new IllegalArgumentException("YUV image buffer is not large enough");
+    if (yuvImage.length < TJ.bufSizeYUV(width, align, height, subsamp))
+      throw new IllegalArgumentException("YUV buffer is not large enough");
 
     int nc = (subsamp == TJ.SAMP_GRAY ? 1 : 3);
     byte[][] planes = new byte[nc][];
@@ -296,9 +303,9 @@ public class YUVImage {
     int[] offsets = new int[nc];
 
     planes[0] = yuvImage;
-    strides[0] = pad(TJ.planeWidth(0, width, subsamp), pad);
+    strides[0] = pad(TJ.planeWidth(0, width, subsamp), align);
     if (subsamp != TJ.SAMP_GRAY) {
-      strides[1] = strides[2] = pad(TJ.planeWidth(1, width, subsamp), pad);
+      strides[1] = strides[2] = pad(TJ.planeWidth(1, width, subsamp), align);
       planes[1] = planes[2] = yuvImage;
       offsets[1] = offsets[0] +
         strides[0] * TJ.planeHeight(0, height, subsamp);
@@ -306,7 +313,7 @@ public class YUVImage {
         strides[1] * TJ.planeHeight(1, height, subsamp);
     }
 
-    yuvPad = pad;
+    yuvAlign = align;
     setBuf(planes, offsets, width, strides, height, subsamp);
   }
 
@@ -333,23 +340,23 @@ public class YUVImage {
   }
 
   /**
-   * Returns the line padding used in the YUV image buffer (if this image is
+   * Returns the row alignment (in bytes) of the YUV buffer (if this image is
    * stored in a unified buffer rather than separate image planes.)
    *
-   * @return the line padding used in the YUV image buffer
+   * @return the row alignment of the YUV buffer
    */
   public int getPad() {
     if (yuvPlanes == null)
       throw new IllegalStateException(NO_ASSOC_ERROR);
-    if (yuvPad < 1 || ((yuvPad & (yuvPad - 1)) != 0))
+    if (yuvAlign < 1 || ((yuvAlign & (yuvAlign - 1)) != 0))
       throw new IllegalStateException("Image is not stored in a unified buffer");
-    return yuvPad;
+    return yuvAlign;
   }
 
   /**
-   * Returns the number of bytes per line of each plane in the YUV image.
+   * Returns the number of bytes per row of each plane in the YUV image.
    *
-   * @return the number of bytes per line of each plane in the YUV image
+   * @return the number of bytes per row of each plane in the YUV image
    */
   public int[] getStrides() {
     if (yuvStrides == null)
@@ -395,10 +402,10 @@ public class YUVImage {
   }
 
   /**
-   * Returns the YUV image buffer (if this image is stored in a unified
-   * buffer rather than separate image planes.)
+   * Returns the YUV buffer (if this image is stored in a unified buffer rather
+   * than separate image planes.)
    *
-   * @return the YUV image buffer
+   * @return the YUV buffer
    */
   public byte[] getBuf() {
     if (yuvPlanes == null || yuvSubsamp < 0 || yuvSubsamp >= TJ.NUMSAMP)
@@ -412,22 +419,22 @@ public class YUVImage {
   }
 
   /**
-   * Returns the size (in bytes) of the YUV image buffer (if this image is
-   * stored in a unified buffer rather than separate image planes.)
+   * Returns the size (in bytes) of the YUV buffer (if this image is stored in
+   * a unified buffer rather than separate image planes.)
    *
-   * @return the size (in bytes) of the YUV image buffer
+   * @return the size (in bytes) of the YUV buffer
    */
   public int getSize() {
     if (yuvPlanes == null || yuvSubsamp < 0 || yuvSubsamp >= TJ.NUMSAMP)
       throw new IllegalStateException(NO_ASSOC_ERROR);
     int nc = (yuvSubsamp == TJ.SAMP_GRAY ? 1 : 3);
-    if (yuvPad < 1)
+    if (yuvAlign < 1)
       throw new IllegalStateException("Image is not stored in a unified buffer");
     for (int i = 1; i < nc; i++) {
       if (yuvPlanes[i] != yuvPlanes[0])
         throw new IllegalStateException("Image is not stored in a unified buffer");
     }
-    return TJ.bufSizeYUV(yuvWidth, yuvPad, yuvHeight, yuvSubsamp);
+    return TJ.bufSizeYUV(yuvWidth, yuvAlign, yuvHeight, yuvSubsamp);
   }
 
   private static int pad(int v, int p) {
@@ -438,7 +445,7 @@ public class YUVImage {
   protected byte[][] yuvPlanes = null;
   protected int[] yuvOffsets = null;
   protected int[] yuvStrides = null;
-  protected int yuvPad = 0;
+  protected int yuvAlign = 1;
   protected int yuvWidth = 0;
   protected int yuvHeight = 0;
   protected int yuvSubsamp = -1;
diff --git a/jccolext.c b/jccolext.c
index 303b322..20f891a 100644
--- a/jccolext.c
+++ b/jccolext.c
@@ -4,7 +4,7 @@
  * This file was part of the Independent JPEG Group's software:
  * Copyright (C) 1991-1996, Thomas G. Lane.
  * libjpeg-turbo Modifications:
- * Copyright (C) 2009-2012, 2015, D. R. Commander.
+ * Copyright (C) 2009-2012, 2015, 2022, D. R. Commander.
  * For conditions of distribution and use, see the accompanying README.ijg
  * file.
  *
@@ -48,9 +48,9 @@ rgb_ycc_convert_internal(j_compress_ptr cinfo, JSAMPARRAY input_buf,
     outptr2 = output_buf[2][output_row];
     output_row++;
     for (col = 0; col < num_cols; col++) {
-      r = inptr[RGB_RED];
-      g = inptr[RGB_GREEN];
-      b = inptr[RGB_BLUE];
+      r = RANGE_LIMIT(inptr[RGB_RED]);
+      g = RANGE_LIMIT(inptr[RGB_GREEN]);
+      b = RANGE_LIMIT(inptr[RGB_BLUE]);
       inptr += RGB_PIXELSIZE;
       /* If the inputs are 0..MAXJSAMPLE, the outputs of these equations
        * must be too; we do not need an explicit range-limiting operation.
@@ -100,9 +100,9 @@ rgb_gray_convert_internal(j_compress_ptr cinfo, JSAMPARRAY input_buf,
     outptr = output_buf[0][output_row];
     output_row++;
     for (col = 0; col < num_cols; col++) {
-      r = inptr[RGB_RED];
-      g = inptr[RGB_GREEN];
-      b = inptr[RGB_BLUE];
+      r = RANGE_LIMIT(inptr[RGB_RED]);
+      g = RANGE_LIMIT(inptr[RGB_GREEN]);
+      b = RANGE_LIMIT(inptr[RGB_BLUE]);
       inptr += RGB_PIXELSIZE;
       /* Y */
       outptr[col] = (JSAMPLE)((ctab[r + R_Y_OFF] + ctab[g + G_Y_OFF] +
diff --git a/jccolor.c b/jccolor.c
index bdc563c..fb9f1cc 100644
--- a/jccolor.c
+++ b/jccolor.c
@@ -5,7 +5,7 @@
  * Copyright (C) 1991-1996, Thomas G. Lane.
  * libjpeg-turbo Modifications:
  * Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
- * Copyright (C) 2009-2012, 2015, D. R. Commander.
+ * Copyright (C) 2009-2012, 2015, 2022, D. R. Commander.
  * Copyright (C) 2014, MIPS Technologies, Inc., California.
  * For conditions of distribution and use, see the accompanying README.ijg
  * file.
@@ -17,7 +17,6 @@
 #include "jinclude.h"
 #include "jpeglib.h"
 #include "jsimd.h"
-#include "jconfigint.h"
 
 
 /* Private subobject */
@@ -84,6 +83,18 @@ typedef my_color_converter *my_cconvert_ptr;
 #define B_CR_OFF        (7 * (MAXJSAMPLE + 1))
 #define TABLE_SIZE      (8 * (MAXJSAMPLE + 1))
 
+/* 12-bit samples use a 16-bit data type, so it is possible to pass
+ * out-of-range sample values (< 0 or > 4095) to jpeg_write_scanlines().
+ * Thus, we mask the incoming 12-bit samples to guard against overrunning
+ * or underrunning the conversion tables.
+ */
+
+#if BITS_IN_JSAMPLE == 12
+#define RANGE_LIMIT(value)  ((value) & 0xFFF)
+#else
+#define RANGE_LIMIT(value)  (value)
+#endif
+
 
 /* Include inline routines for colorspace extensions */
 
@@ -392,9 +403,9 @@ cmyk_ycck_convert(j_compress_ptr cinfo, JSAMPARRAY input_buf,
     outptr3 = output_buf[3][output_row];
     output_row++;
     for (col = 0; col < num_cols; col++) {
-      r = MAXJSAMPLE - inptr[0];
-      g = MAXJSAMPLE - inptr[1];
-      b = MAXJSAMPLE - inptr[2];
+      r = MAXJSAMPLE - RANGE_LIMIT(inptr[0]);
+      g = MAXJSAMPLE - RANGE_LIMIT(inptr[1]);
+      b = MAXJSAMPLE - RANGE_LIMIT(inptr[2]);
       /* K passes through as-is */
       outptr3[col] = inptr[3];
       inptr += 4;
diff --git a/jchuff.c b/jchuff.c
index f4dfa1c..5d0276a 100644
--- a/jchuff.c
+++ b/jchuff.c
@@ -27,7 +27,6 @@
 #include "jinclude.h"
 #include "jpeglib.h"
 #include "jsimd.h"
-#include "jconfigint.h"
 #include <limits.h>
 
 /*
diff --git a/jchuff.h b/jchuff.h
index 314a232..da7809a 100644
--- a/jchuff.h
+++ b/jchuff.h
@@ -3,8 +3,8 @@
  *
  * This file was part of the Independent JPEG Group's software:
  * Copyright (C) 1991-1997, Thomas G. Lane.
- * It was modified by The libjpeg-turbo Project to include only code relevant
- * to libjpeg-turbo.
+ * libjpeg-turbo Modifications:
+ * Copyright (C) 2022, D. R. Commander.
  * For conditions of distribution and use, see the accompanying README.ijg
  * file.
  *
@@ -25,6 +25,14 @@
 #define MAX_COEF_BITS  14
 #endif
 
+/* The progressive Huffman encoder uses an unsigned 16-bit data type to store
+ * absolute values of coefficients, because it is possible to inject a
+ * coefficient value of -32768 into the encoder by attempting to transform a
+ * malformed 12-bit JPEG image, and the absolute value of -32768 would overflow
+ * a signed 16-bit integer.
+ */
+typedef unsigned short UJCOEF;
+
 /* Derived data constructed for each Huffman table */
 
 typedef struct {
diff --git a/jcmaster.c b/jcmaster.c
index c2b2600..b821710 100644
--- a/jcmaster.c
+++ b/jcmaster.c
@@ -19,7 +19,6 @@
 #include "jinclude.h"
 #include "jpeglib.h"
 #include "jpegcomp.h"
-#include "jconfigint.h"
 
 
 /* Private state */
diff --git a/jcphuff.c b/jcphuff.c
index 872e570..5006b67 100644
--- a/jcphuff.c
+++ b/jcphuff.c
@@ -5,7 +5,7 @@
  * Copyright (C) 1995-1997, Thomas G. Lane.
  * libjpeg-turbo Modifications:
  * Copyright (C) 2011, 2015, 2018, 2021-2022, D. R. Commander.
- * Copyright (C) 2016, 2018, Matthieu Darbois.
+ * Copyright (C) 2016, 2018, 2022, Matthieu Darbois.
  * Copyright (C) 2020, Arm Limited.
  * Copyright (C) 2021, Alex Richardson.
  * For conditions of distribution and use, see the accompanying README.ijg
@@ -22,7 +22,6 @@
 #include "jinclude.h"
 #include "jpeglib.h"
 #include "jsimd.h"
-#include "jconfigint.h"
 #include <limits.h>
 
 #ifdef HAVE_INTRIN_H
@@ -83,11 +82,11 @@ typedef struct {
   /* Pointer to routine to prepare data for encode_mcu_AC_first() */
   void (*AC_first_prepare) (const JCOEF *block,
                             const int *jpeg_natural_order_start, int Sl,
-                            int Al, JCOEF *values, size_t *zerobits);
+                            int Al, UJCOEF *values, size_t *zerobits);
   /* Pointer to routine to prepare data for encode_mcu_AC_refine() */
   int (*AC_refine_prepare) (const JCOEF *block,
                             const int *jpeg_natural_order_start, int Sl,
-                            int Al, JCOEF *absvalues, size_t *bits);
+                            int Al, UJCOEF *absvalues, size_t *bits);
 
   /* Mode flag: TRUE for optimization, FALSE for actual data output */
   boolean gather_statistics;
@@ -157,14 +156,14 @@ METHODDEF(boolean) encode_mcu_DC_first(j_compress_ptr cinfo,
                                        JBLOCKROW *MCU_data);
 METHODDEF(void) encode_mcu_AC_first_prepare
   (const JCOEF *block, const int *jpeg_natural_order_start, int Sl, int Al,
-   JCOEF *values, size_t *zerobits);
+   UJCOEF *values, size_t *zerobits);
 METHODDEF(boolean) encode_mcu_AC_first(j_compress_ptr cinfo,
                                        JBLOCKROW *MCU_data);
 METHODDEF(boolean) encode_mcu_DC_refine(j_compress_ptr cinfo,
                                         JBLOCKROW *MCU_data);
 METHODDEF(int) encode_mcu_AC_refine_prepare
   (const JCOEF *block, const int *jpeg_natural_order_start, int Sl, int Al,
-   JCOEF *absvalues, size_t *bits);
+   UJCOEF *absvalues, size_t *bits);
 METHODDEF(boolean) encode_mcu_AC_refine(j_compress_ptr cinfo,
                                         JBLOCKROW *MCU_data);
 METHODDEF(void) finish_pass_phuff(j_compress_ptr cinfo);
@@ -584,8 +583,8 @@ encode_mcu_DC_first(j_compress_ptr cinfo, JBLOCKROW *MCU_data)
       continue; \
     /* For a negative coef, want temp2 = bitwise complement of abs(coef) */ \
     temp2 ^= temp; \
-    values[k] = (JCOEF)temp; \
-    values[k + DCTSIZE2] = (JCOEF)temp2; \
+    values[k] = (UJCOEF)temp; \
+    values[k + DCTSIZE2] = (UJCOEF)temp2; \
     zerobits |= ((size_t)1U) << k; \
   } \
 }
@@ -593,7 +592,7 @@ encode_mcu_DC_first(j_compress_ptr cinfo, JBLOCKROW *MCU_data)
 METHODDEF(void)
 encode_mcu_AC_first_prepare(const JCOEF *block,
                             const int *jpeg_natural_order_start, int Sl,
-                            int Al, JCOEF *values, size_t *bits)
+                            int Al, UJCOEF *values, size_t *bits)
 {
   register int k, temp, temp2;
   size_t zerobits = 0U;
@@ -666,9 +665,9 @@ encode_mcu_AC_first(j_compress_ptr cinfo, JBLOCKROW *MCU_data)
   register int nbits, r;
   int Sl = cinfo->Se - cinfo->Ss + 1;
   int Al = cinfo->Al;
-  JCOEF values_unaligned[2 * DCTSIZE2 + 15];
-  JCOEF *values;
-  const JCOEF *cvalue;
+  UJCOEF values_unaligned[2 * DCTSIZE2 + 15];
+  UJCOEF *values;
+  const UJCOEF *cvalue;
   size_t zerobits;
   size_t bits[8 / SIZEOF_SIZE_T];
 
@@ -681,7 +680,7 @@ encode_mcu_AC_first(j_compress_ptr cinfo, JBLOCKROW *MCU_data)
       emit_restart(entropy, entropy->next_restart_num);
 
 #ifdef WITH_SIMD
-  cvalue = values = (JCOEF *)PAD((JUINTPTR)values_unaligned, 16);
+  cvalue = values = (UJCOEF *)PAD((JUINTPTR)values_unaligned, 16);
 #else
   /* Not using SIMD, so alignment is not needed */
   cvalue = values = values_unaligned;
@@ -815,7 +814,7 @@ encode_mcu_DC_refine(j_compress_ptr cinfo, JBLOCKROW *MCU_data)
       zerobits |= ((size_t)1U) << k; \
       signbits |= ((size_t)(temp2 + 1)) << k; \
     } \
-    absvalues[k] = (JCOEF)temp; /* save abs value for main pass */ \
+    absvalues[k] = (UJCOEF)temp; /* save abs value for main pass */ \
     if (temp == 1) \
       EOB = k + koffset;        /* EOB = index of last newly-nonzero coef */ \
   } \
@@ -824,7 +823,7 @@ encode_mcu_DC_refine(j_compress_ptr cinfo, JBLOCKROW *MCU_data)
 METHODDEF(int)
 encode_mcu_AC_refine_prepare(const JCOEF *block,
                              const int *jpeg_natural_order_start, int Sl,
-                             int Al, JCOEF *absvalues, size_t *bits)
+                             int Al, UJCOEF *absvalues, size_t *bits)
 {
   register int k, temp, temp2;
   int EOB = 0;
@@ -931,9 +930,9 @@ encode_mcu_AC_refine(j_compress_ptr cinfo, JBLOCKROW *MCU_data)
   unsigned int BR;
   int Sl = cinfo->Se - cinfo->Ss + 1;
   int Al = cinfo->Al;
-  JCOEF absvalues_unaligned[DCTSIZE2 + 15];
-  JCOEF *absvalues;
-  const JCOEF *cabsvalue, *EOBPTR;
+  UJCOEF absvalues_unaligned[DCTSIZE2 + 15];
+  UJCOEF *absvalues;
+  const UJCOEF *cabsvalue, *EOBPTR;
   size_t zerobits, signbits;
   size_t bits[16 / SIZEOF_SIZE_T];
 
@@ -946,7 +945,7 @@ encode_mcu_AC_refine(j_compress_ptr cinfo, JBLOCKROW *MCU_data)
       emit_restart(entropy, entropy->next_restart_num);
 
 #ifdef WITH_SIMD
-  cabsvalue = absvalues = (JCOEF *)PAD((JUINTPTR)absvalues_unaligned, 16);
+  cabsvalue = absvalues = (UJCOEF *)PAD((JUINTPTR)absvalues_unaligned, 16);
 #else
   /* Not using SIMD, so alignment is not needed */
   cabsvalue = absvalues = absvalues_unaligned;
diff --git a/jdapimin.c b/jdapimin.c
index f50c27e..30126a0 100644
--- a/jdapimin.c
+++ b/jdapimin.c
@@ -23,7 +23,6 @@
 #include "jinclude.h"
 #include "jpeglib.h"
 #include "jdmaster.h"
-#include "jconfigint.h"
 
 
 /*
diff --git a/jdcolext.c b/jdcolext.c
index 863c7a2..fc7e7b8 100644
--- a/jdcolext.c
+++ b/jdcolext.c
@@ -4,7 +4,7 @@
  * This file was part of the Independent JPEG Group's software:
  * Copyright (C) 1991-1997, Thomas G. Lane.
  * libjpeg-turbo Modifications:
- * Copyright (C) 2009, 2011, 2015, D. R. Commander.
+ * Copyright (C) 2009, 2011, 2015, 2023, D. R. Commander.
  * For conditions of distribution and use, see the accompanying README.ijg
  * file.
  *
@@ -62,10 +62,10 @@ ycc_rgb_convert_internal(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,
                               ((int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr],
                                                 SCALEBITS))];
       outptr[RGB_BLUE] =  range_limit[y + Cbbtab[cb]];
-      /* Set unused byte to 0xFF so it can be interpreted as an opaque */
+      /* Set unused byte to MAXJSAMPLE so it can be interpreted as an opaque */
       /* alpha channel value */
 #ifdef RGB_ALPHA
-      outptr[RGB_ALPHA] = 0xFF;
+      outptr[RGB_ALPHA] = MAXJSAMPLE;
 #endif
       outptr += RGB_PIXELSIZE;
     }
@@ -94,10 +94,10 @@ gray_rgb_convert_internal(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,
     outptr = *output_buf++;
     for (col = 0; col < num_cols; col++) {
       outptr[RGB_RED] = outptr[RGB_GREEN] = outptr[RGB_BLUE] = inptr[col];
-      /* Set unused byte to 0xFF so it can be interpreted as an opaque */
+      /* Set unused byte to MAXJSAMPLE so it can be interpreted as an opaque */
       /* alpha channel value */
 #ifdef RGB_ALPHA
-      outptr[RGB_ALPHA] = 0xFF;
+      outptr[RGB_ALPHA] = MAXJSAMPLE;
 #endif
       outptr += RGB_PIXELSIZE;
     }
@@ -130,10 +130,10 @@ rgb_rgb_convert_internal(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,
       outptr[RGB_RED] = inptr0[col];
       outptr[RGB_GREEN] = inptr1[col];
       outptr[RGB_BLUE] = inptr2[col];
-      /* Set unused byte to 0xFF so it can be interpreted as an opaque */
+      /* Set unused byte to MAXJSAMPLE so it can be interpreted as an opaque */
       /* alpha channel value */
 #ifdef RGB_ALPHA
-      outptr[RGB_ALPHA] = 0xFF;
+      outptr[RGB_ALPHA] = MAXJSAMPLE;
 #endif
       outptr += RGB_PIXELSIZE;
     }
diff --git a/jdcolor.c b/jdcolor.c
index 8da2b4e..735190b 100644
--- a/jdcolor.c
+++ b/jdcolor.c
@@ -18,7 +18,6 @@
 #include "jinclude.h"
 #include "jpeglib.h"
 #include "jsimd.h"
-#include "jconfigint.h"
 
 
 /* Private subobject */
diff --git a/jdmainct.c b/jdmainct.c
index f466b25..d332e6b 100644
--- a/jdmainct.c
+++ b/jdmainct.c
@@ -18,7 +18,6 @@
 
 #include "jinclude.h"
 #include "jdmainct.h"
-#include "jconfigint.h"
 
 
 /*
diff --git a/jdmerge.c b/jdmerge.c
index 3a456d6..38b0027 100644
--- a/jdmerge.c
+++ b/jdmerge.c
@@ -42,7 +42,6 @@
 #include "jpeglib.h"
 #include "jdmerge.h"
 #include "jsimd.h"
-#include "jconfigint.h"
 
 #ifdef UPSAMPLE_MERGING_SUPPORTED
 
diff --git a/jdmrgext.c b/jdmrgext.c
index 9bf4f1a..038abc7 100644
--- a/jdmrgext.c
+++ b/jdmrgext.c
@@ -4,7 +4,7 @@
  * This file was part of the Independent JPEG Group's software:
  * Copyright (C) 1994-1996, Thomas G. Lane.
  * libjpeg-turbo Modifications:
- * Copyright (C) 2011, 2015, 2020, D. R. Commander.
+ * Copyright (C) 2011, 2015, 2020, 2023, D. R. Commander.
  * For conditions of distribution and use, see the accompanying README.ijg
  * file.
  *
@@ -57,7 +57,7 @@ h2v1_merged_upsample_internal(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,
     outptr[RGB_GREEN] = range_limit[y + cgreen];
     outptr[RGB_BLUE] =  range_limit[y + cblue];
 #ifdef RGB_ALPHA
-    outptr[RGB_ALPHA] = 0xFF;
+    outptr[RGB_ALPHA] = MAXJSAMPLE;
 #endif
     outptr += RGB_PIXELSIZE;
     y  = *inptr0++;
@@ -65,7 +65,7 @@ h2v1_merged_upsample_internal(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,
     outptr[RGB_GREEN] = range_limit[y + cgreen];
     outptr[RGB_BLUE] =  range_limit[y + cblue];
 #ifdef RGB_ALPHA
-    outptr[RGB_ALPHA] = 0xFF;
+    outptr[RGB_ALPHA] = MAXJSAMPLE;
 #endif
     outptr += RGB_PIXELSIZE;
   }
@@ -81,7 +81,7 @@ h2v1_merged_upsample_internal(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,
     outptr[RGB_GREEN] = range_limit[y + cgreen];
     outptr[RGB_BLUE] =  range_limit[y + cblue];
 #ifdef RGB_ALPHA
-    outptr[RGB_ALPHA] = 0xFF;
+    outptr[RGB_ALPHA] = MAXJSAMPLE;
 #endif
   }
 }
@@ -131,7 +131,7 @@ h2v2_merged_upsample_internal(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,
     outptr0[RGB_GREEN] = range_limit[y + cgreen];
     outptr0[RGB_BLUE] =  range_limit[y + cblue];
 #ifdef RGB_ALPHA
-    outptr0[RGB_ALPHA] = 0xFF;
+    outptr0[RGB_ALPHA] = MAXJSAMPLE;
 #endif
     outptr0 += RGB_PIXELSIZE;
     y  = *inptr00++;
@@ -139,7 +139,7 @@ h2v2_merged_upsample_internal(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,
     outptr0[RGB_GREEN] = range_limit[y + cgreen];
     outptr0[RGB_BLUE] =  range_limit[y + cblue];
 #ifdef RGB_ALPHA
-    outptr0[RGB_ALPHA] = 0xFF;
+    outptr0[RGB_ALPHA] = MAXJSAMPLE;
 #endif
     outptr0 += RGB_PIXELSIZE;
     y  = *inptr01++;
@@ -147,7 +147,7 @@ h2v2_merged_upsample_internal(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,
     outptr1[RGB_GREEN] = range_limit[y + cgreen];
     outptr1[RGB_BLUE] =  range_limit[y + cblue];
 #ifdef RGB_ALPHA
-    outptr1[RGB_ALPHA] = 0xFF;
+    outptr1[RGB_ALPHA] = MAXJSAMPLE;
 #endif
     outptr1 += RGB_PIXELSIZE;
     y  = *inptr01++;
@@ -155,7 +155,7 @@ h2v2_merged_upsample_internal(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,
     outptr1[RGB_GREEN] = range_limit[y + cgreen];
     outptr1[RGB_BLUE] =  range_limit[y + cblue];
 #ifdef RGB_ALPHA
-    outptr1[RGB_ALPHA] = 0xFF;
+    outptr1[RGB_ALPHA] = MAXJSAMPLE;
 #endif
     outptr1 += RGB_PIXELSIZE;
   }
@@ -171,14 +171,14 @@ h2v2_merged_upsample_internal(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,
     outptr0[RGB_GREEN] = range_limit[y + cgreen];
     outptr0[RGB_BLUE] =  range_limit[y + cblue];
 #ifdef RGB_ALPHA
-    outptr0[RGB_ALPHA] = 0xFF;
+    outptr0[RGB_ALPHA] = MAXJSAMPLE;
 #endif
     y  = *inptr01;
     outptr1[RGB_RED] =   range_limit[y + cred];
     outptr1[RGB_GREEN] = range_limit[y + cgreen];
     outptr1[RGB_BLUE] =  range_limit[y + cblue];
 #ifdef RGB_ALPHA
-    outptr1[RGB_ALPHA] = 0xFF;
+    outptr1[RGB_ALPHA] = MAXJSAMPLE;
 #endif
   }
 }
diff --git a/jdsample.c b/jdsample.c
index eaad72a..02eaed6 100644
--- a/jdsample.c
+++ b/jdsample.c
@@ -478,7 +478,7 @@ jinit_upsampler(j_decompress_ptr cinfo)
                v_in_group * 2 == v_out_group && do_fancy) {
       /* Non-fancy upsampling is handled by the generic method */
 #if defined(__arm__) || defined(__aarch64__) || \
-    defined(_M_ARM) || defined(_M_ARM64)
+    defined(_M_ARM) || defined(_M_ARM64) || defined(__riscv)
       if (jsimd_can_h1v2_fancy_upsample())
         upsample->methods[ci] = jsimd_h1v2_fancy_upsample;
       else
diff --git a/jpegtran.1 b/jpegtran.1
index 5b1ded2..aaf5274 100644
--- a/jpegtran.1
+++ b/jpegtran.1
@@ -167,7 +167,7 @@ on an iMCU boundary.  If it doesn't, then it is silently moved up and/or left
 to the nearest iMCU boundary (the lower right corner is unchanged.)  Thus, the
 output image covers at least the requested region, but it may cover more.  The
 adjustment of the region dimensions may be optionally disabled by attaching an
-'f' character ("force") to the width or height number.
+\'f\' character ("force") to the width or height number.
 
 The image can be losslessly cropped by giving the switch:
 .TP
diff --git a/jsimd.h b/jsimd.h
index 6c20365..74d480a 100644
--- a/jsimd.h
+++ b/jsimd.h
@@ -2,8 +2,8 @@
  * jsimd.h
  *
  * Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
- * Copyright (C) 2011, 2014, D. R. Commander.
- * Copyright (C) 2015-2016, 2018, Matthieu Darbois.
+ * Copyright (C) 2011, 2014, 2022, D. R. Commander.
+ * Copyright (C) 2015-2016, 2018, 2022, Matthieu Darbois.
  * Copyright (C) 2020, Arm Limited.
  *
  * Based on the x86 SIMD extension for IJG JPEG library,
@@ -114,10 +114,10 @@ EXTERN(int) jsimd_can_encode_mcu_AC_first_prepare(void);
 
 EXTERN(void) jsimd_encode_mcu_AC_first_prepare
   (const JCOEF *block, const int *jpeg_natural_order_start, int Sl, int Al,
-   JCOEF *values, size_t *zerobits);
+   UJCOEF *values, size_t *zerobits);
 
 EXTERN(int) jsimd_can_encode_mcu_AC_refine_prepare(void);
 
 EXTERN(int) jsimd_encode_mcu_AC_refine_prepare
   (const JCOEF *block, const int *jpeg_natural_order_start, int Sl, int Al,
-   JCOEF *absvalues, size_t *bits);
+   UJCOEF *absvalues, size_t *bits);
diff --git a/jsimd_none.c b/jsimd_none.c
index 5b38a9f..a25db73 100644
--- a/jsimd_none.c
+++ b/jsimd_none.c
@@ -2,8 +2,8 @@
  * jsimd_none.c
  *
  * Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
- * Copyright (C) 2009-2011, 2014, D. R. Commander.
- * Copyright (C) 2015-2016, 2018, Matthieu Darbois.
+ * Copyright (C) 2009-2011, 2014, 2022, D. R. Commander.
+ * Copyright (C) 2015-2016, 2018, 2022, Matthieu Darbois.
  * Copyright (C) 2020, Arm Limited.
  *
  * Based on the x86 SIMD extension for IJG JPEG library,
@@ -412,7 +412,7 @@ jsimd_can_encode_mcu_AC_first_prepare(void)
 GLOBAL(void)
 jsimd_encode_mcu_AC_first_prepare(const JCOEF *block,
                                   const int *jpeg_natural_order_start, int Sl,
-                                  int Al, JCOEF *values, size_t *zerobits)
+                                  int Al, UJCOEF *values, size_t *zerobits)
 {
 }
 
@@ -425,7 +425,7 @@ jsimd_can_encode_mcu_AC_refine_prepare(void)
 GLOBAL(int)
 jsimd_encode_mcu_AC_refine_prepare(const JCOEF *block,
                                    const int *jpeg_natural_order_start, int Sl,
-                                   int Al, JCOEF *absvalues, size_t *bits)
+                                   int Al, UJCOEF *absvalues, size_t *bits)
 {
   return 0;
 }
diff --git a/jversion.h.in b/jversion.h.in
index dca4f08..dee6c02 100644
--- a/jversion.h.in
+++ b/jversion.h.in
@@ -4,7 +4,7 @@
  * This file was part of the Independent JPEG Group's software:
  * Copyright (C) 1991-2020, Thomas G. Lane, Guido Vollbeding.
  * libjpeg-turbo Modifications:
- * Copyright (C) 2010, 2012-2022, D. R. Commander.
+ * Copyright (C) 2010, 2012-2023, D. R. Commander.
  * For conditions of distribution and use, see the accompanying README.ijg
  * file.
  *
@@ -37,7 +37,7 @@
  */
 
 #define JCOPYRIGHT \
-  "Copyright (C) 2009-2022 D. R. Commander\n" \
+  "Copyright (C) 2009-2023 D. R. Commander\n" \
   "Copyright (C) 2015, 2020 Google, Inc.\n" \
   "Copyright (C) 2019-2020 Arm Limited\n" \
   "Copyright (C) 2015-2016, 2018 Matthieu Darbois\n" \
diff --git a/rdppm.c b/rdppm.c
index 294749a..883641d 100644
--- a/rdppm.c
+++ b/rdppm.c
@@ -5,7 +5,7 @@
  * Copyright (C) 1991-1997, Thomas G. Lane.
  * Modified 2009 by Bill Allombert, Guido Vollbeding.
  * libjpeg-turbo Modifications:
- * Copyright (C) 2015-2017, 2020-2022, D. R. Commander.
+ * Copyright (C) 2015-2017, 2020-2023, D. R. Commander.
  * For conditions of distribution and use, see the accompanying README.ijg
  * file.
  *
@@ -179,13 +179,13 @@ get_text_gray_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)
   if (maxval == MAXJSAMPLE) {
     if (aindex >= 0)
       GRAY_RGB_READ_LOOP((JSAMPLE)read_pbm_integer(cinfo, infile, maxval),
-                         ptr[aindex] = 0xFF;)
+                         ptr[aindex] = MAXJSAMPLE;)
     else
       GRAY_RGB_READ_LOOP((JSAMPLE)read_pbm_integer(cinfo, infile, maxval), {})
   } else {
     if (aindex >= 0)
       GRAY_RGB_READ_LOOP(rescale[read_pbm_integer(cinfo, infile, maxval)],
-                         ptr[aindex] = 0xFF;)
+                         ptr[aindex] = MAXJSAMPLE;)
     else
       GRAY_RGB_READ_LOOP(rescale[read_pbm_integer(cinfo, infile, maxval)], {})
   }
@@ -253,13 +253,13 @@ get_text_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)
   if (maxval == MAXJSAMPLE) {
     if (aindex >= 0)
       RGB_READ_LOOP((JSAMPLE)read_pbm_integer(cinfo, infile, maxval),
-                    ptr[aindex] = 0xFF;)
+                    ptr[aindex] = MAXJSAMPLE;)
     else
       RGB_READ_LOOP((JSAMPLE)read_pbm_integer(cinfo, infile, maxval), {})
   } else {
     if (aindex >= 0)
       RGB_READ_LOOP(rescale[read_pbm_integer(cinfo, infile, maxval)],
-                    ptr[aindex] = 0xFF;)
+                    ptr[aindex] = MAXJSAMPLE;)
     else
       RGB_READ_LOOP(rescale[read_pbm_integer(cinfo, infile, maxval)], {})
   }
@@ -345,12 +345,12 @@ get_gray_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)
   bufferptr = source->iobuffer;
   if (maxval == MAXJSAMPLE) {
     if (aindex >= 0)
-      GRAY_RGB_READ_LOOP(*bufferptr++, ptr[aindex] = 0xFF;)
+      GRAY_RGB_READ_LOOP(*bufferptr++, ptr[aindex] = MAXJSAMPLE;)
     else
       GRAY_RGB_READ_LOOP(*bufferptr++, {})
   } else {
     if (aindex >= 0)
-      GRAY_RGB_READ_LOOP(rescale[UCH(*bufferptr++)], ptr[aindex] = 0xFF;)
+      GRAY_RGB_READ_LOOP(rescale[UCH(*bufferptr++)], ptr[aindex] = MAXJSAMPLE;)
     else
       GRAY_RGB_READ_LOOP(rescale[UCH(*bufferptr++)], {})
   }
@@ -413,12 +413,12 @@ get_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)
   bufferptr = source->iobuffer;
   if (maxval == MAXJSAMPLE) {
     if (aindex >= 0)
-      RGB_READ_LOOP(*bufferptr++, ptr[aindex] = 0xFF;)
+      RGB_READ_LOOP(*bufferptr++, ptr[aindex] = MAXJSAMPLE;)
     else
       RGB_READ_LOOP(*bufferptr++, {})
   } else {
     if (aindex >= 0)
-      RGB_READ_LOOP(rescale[UCH(*bufferptr++)], ptr[aindex] = 0xFF;)
+      RGB_READ_LOOP(rescale[UCH(*bufferptr++)], ptr[aindex] = MAXJSAMPLE;)
     else
       RGB_READ_LOOP(rescale[UCH(*bufferptr++)], {})
   }
@@ -543,7 +543,7 @@ get_word_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)
       ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);
     ptr[bindex] = rescale[temp];
     if (aindex >= 0)
-      ptr[aindex] = 0xFF;
+      ptr[aindex] = MAXJSAMPLE;
     ptr += ps;
   }
   return 1;
diff --git a/simd/CMakeLists.txt b/simd/CMakeLists.txt
index 6024900..66b44c9 100644
--- a/simd/CMakeLists.txt
+++ b/simd/CMakeLists.txt
@@ -21,7 +21,7 @@ set(CMAKE_ASM_NASM_FLAGS_RELWITHDEBINFO_INIT "-g")
 # environment variable.  This should happen automatically, but unfortunately
 # enable_language(ASM_NASM) doesn't parse the ASM_NASM environment variable
 # until after CMAKE_ASM_NASM_COMPILER has been populated with the results of
-# searching for NASM or Yasm in the PATH.
+# searching for NASM or YASM in the PATH.
 if(NOT DEFINED CMAKE_ASM_NASM_COMPILER AND DEFINED ENV{ASM_NASM})
   set(CMAKE_ASM_NASM_COMPILER $ENV{ASM_NASM})
 endif()
@@ -258,30 +258,28 @@ endif()
 check_c_source_compiles("
   #include <arm_neon.h>
   int main(int argc, char **argv) {
-    int16_t input[] = {
+    const int16_t input[] = {
       (int16_t)argc, (int16_t)argc, (int16_t)argc, (int16_t)argc,
       (int16_t)argc, (int16_t)argc, (int16_t)argc, (int16_t)argc,
       (int16_t)argc, (int16_t)argc, (int16_t)argc, (int16_t)argc
     };
     int16x4x3_t output = vld1_s16_x3(input);
-    vst3_s16(input, output);
-    return (int)input[0];
+    return (int)output.val[0][0];
   }" HAVE_VLD1_S16_X3)
 check_c_source_compiles("
   #include <arm_neon.h>
   int main(int argc, char **argv) {
-    uint16_t input[] = {
+    const uint16_t input[] = {
       (uint16_t)argc, (uint16_t)argc, (uint16_t)argc, (uint16_t)argc,
       (uint16_t)argc, (uint16_t)argc, (uint16_t)argc, (uint16_t)argc
     };
     uint16x4x2_t output = vld1_u16_x2(input);
-    vst2_u16(input, output);
-    return (int)input[0];
+    return (int)output.val[0][0];
   }" HAVE_VLD1_U16_X2)
 check_c_source_compiles("
   #include <arm_neon.h>
   int main(int argc, char **argv) {
-    uint8_t input[] = {
+    const uint8_t input[] = {
       (uint8_t)argc, (uint8_t)argc, (uint8_t)argc, (uint8_t)argc,
       (uint8_t)argc, (uint8_t)argc, (uint8_t)argc, (uint8_t)argc,
       (uint8_t)argc, (uint8_t)argc, (uint8_t)argc, (uint8_t)argc,
@@ -300,8 +298,7 @@ check_c_source_compiles("
       (uint8_t)argc, (uint8_t)argc, (uint8_t)argc, (uint8_t)argc
     };
     uint8x16x4_t output = vld1q_u8_x4(input);
-    vst4q_u8(input, output);
-    return (int)input[0];
+    return (int)output.val[0][0];
   }" HAVE_VLD1Q_U8_X4)
 if(BITS EQUAL 32)
   unset(CMAKE_REQUIRED_FLAGS)
@@ -531,6 +528,45 @@ if(CMAKE_POSITION_INDEPENDENT_CODE OR ENABLE_SHARED)
   set_target_properties(simd PROPERTIES POSITION_INDEPENDENT_CODE 1)
 endif()
 
+###############################################################################
+# RVV 64-bit (Intrinsics)
+###############################################################################
+
+elseif(CPU_TYPE STREQUAL "riscv64")
+
+set(CMAKE_REQUIRED_FLAGS "-march=rv64gcv_zba_zbb_zbc_zbs")
+
+check_c_source_compiles("
+  #include <riscv_vector.h>
+  int main(void) {
+    const float src[] = { 0.0f, 0.0f, 0.0f, 0.0f };
+    vfloat32m1_t val = __riscv_vle32_v_f32m1((const float*)(src), 4);
+    return (int)__riscv_vfmv_f_s_f32m1_f32(val);
+  }" HAVE_RVV)
+
+unset(CMAKE_REQUIRED_FLAGS)
+
+if(NOT HAVE_RVV)
+  simd_fail("SIMD extensions not available for this CPU (riscv64)")
+  return()
+endif()
+
+set(SIMD_SOURCES rvv/jccolor-rvv.c rvv/jcgray-rvv.c
+  rvv/jcsample-rvv.c rvv/jdcolor-rvv.c
+  rvv/jdmerge-rvv.c rvv/jdsample-rvv.c
+  rvv/jfdctfst-rvv.c rvv/jfdctint-rvv.c
+  rvv/jidctfst-rvv.c rvv/jidctint-rvv.c
+  rvv/jquanti-rvv.c rvv/jidctred-rvv.c)
+
+set_source_files_properties(${SIMD_SOURCES} PROPERTIES
+  COMPILE_FLAGS -march=rv64gcv_zba_zbb_zbc_zbs)
+
+add_library(simd OBJECT ${SIMD_SOURCES} rvv/jsimd.c)
+
+if(CMAKE_POSITION_INDEPENDENT_CODE OR ENABLE_SHARED)
+  set_target_properties(simd PROPERTIES POSITION_INDEPENDENT_CODE 1)
+endif()
+
 
 ###############################################################################
 # None
diff --git a/simd/arm/aarch32/jsimd.c b/simd/arm/aarch32/jsimd.c
index 920f765..04d6452 100644
--- a/simd/arm/aarch32/jsimd.c
+++ b/simd/arm/aarch32/jsimd.c
@@ -4,7 +4,7 @@
  * Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
  * Copyright (C) 2011, Nokia Corporation and/or its subsidiary(-ies).
  * Copyright (C) 2009-2011, 2013-2014, 2016, 2018, 2022, D. R. Commander.
- * Copyright (C) 2015-2016, 2018, Matthieu Darbois.
+ * Copyright (C) 2015-2016, 2018, 2022, Matthieu Darbois.
  * Copyright (C) 2019, Google LLC.
  * Copyright (C) 2020, Arm Limited.
  *
@@ -27,8 +27,8 @@
 
 #include <ctype.h>
 
-static unsigned int simd_support = ~0;
-static unsigned int simd_huffman = 1;
+static THREAD_LOCAL unsigned int simd_support = ~0;
+static THREAD_LOCAL unsigned int simd_huffman = 1;
 
 #if !defined(__ARM_NEON__) && (defined(__linux__) || defined(ANDROID) || defined(__ANDROID__))
 
@@ -96,8 +96,6 @@ parse_proc_cpuinfo(int bufsize)
 
 /*
  * Check what SIMD accelerations are supported.
- *
- * FIXME: This code is racy under a multi-threaded environment.
  */
 LOCAL(void)
 init_simd(void)
@@ -945,7 +943,7 @@ jsimd_can_encode_mcu_AC_first_prepare(void)
 GLOBAL(void)
 jsimd_encode_mcu_AC_first_prepare(const JCOEF *block,
                                   const int *jpeg_natural_order_start, int Sl,
-                                  int Al, JCOEF *values, size_t *zerobits)
+                                  int Al, UJCOEF *values, size_t *zerobits)
 {
   jsimd_encode_mcu_AC_first_prepare_neon(block, jpeg_natural_order_start,
                                          Sl, Al, values, zerobits);
@@ -970,7 +968,7 @@ jsimd_can_encode_mcu_AC_refine_prepare(void)
 GLOBAL(int)
 jsimd_encode_mcu_AC_refine_prepare(const JCOEF *block,
                                    const int *jpeg_natural_order_start, int Sl,
-                                   int Al, JCOEF *absvalues, size_t *bits)
+                                   int Al, UJCOEF *absvalues, size_t *bits)
 {
   return jsimd_encode_mcu_AC_refine_prepare_neon(block,
                                                  jpeg_natural_order_start, Sl,
diff --git a/simd/arm/aarch64/jsimd.c b/simd/arm/aarch64/jsimd.c
index 41c06d3..358e159 100644
--- a/simd/arm/aarch64/jsimd.c
+++ b/simd/arm/aarch64/jsimd.c
@@ -4,7 +4,7 @@
  * Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
  * Copyright (C) 2011, Nokia Corporation and/or its subsidiary(-ies).
  * Copyright (C) 2009-2011, 2013-2014, 2016, 2018, 2020, 2022, D. R. Commander.
- * Copyright (C) 2015-2016, 2018, Matthieu Darbois.
+ * Copyright (C) 2015-2016, 2018, 2022, Matthieu Darbois.
  * Copyright (C) 2020, Arm Limited.
  *
  * Based on the x86 SIMD extension for IJG JPEG library,
@@ -23,7 +23,6 @@
 #include "../../../jdct.h"
 #include "../../../jsimddct.h"
 #include "../../jsimd.h"
-#include "jconfigint.h"
 
 #include <ctype.h>
 
@@ -31,10 +30,10 @@
 #define JSIMD_FASTST3  2
 #define JSIMD_FASTTBL  4
 
-static unsigned int simd_support = ~0;
-static unsigned int simd_huffman = 1;
-static unsigned int simd_features = JSIMD_FASTLD3 | JSIMD_FASTST3 |
-                                    JSIMD_FASTTBL;
+static THREAD_LOCAL unsigned int simd_support = ~0;
+static THREAD_LOCAL unsigned int simd_huffman = 1;
+static THREAD_LOCAL unsigned int simd_features = JSIMD_FASTLD3 |
+                                                 JSIMD_FASTST3 | JSIMD_FASTTBL;
 
 #if defined(__linux__) || defined(ANDROID) || defined(__ANDROID__)
 
@@ -109,8 +108,6 @@ parse_proc_cpuinfo(int bufsize)
 
 /*
  * Check what SIMD accelerations are supported.
- *
- * FIXME: This code is racy under a multi-threaded environment.
  */
 
 /*
@@ -1021,7 +1018,7 @@ jsimd_can_encode_mcu_AC_first_prepare(void)
 GLOBAL(void)
 jsimd_encode_mcu_AC_first_prepare(const JCOEF *block,
                                   const int *jpeg_natural_order_start, int Sl,
-                                  int Al, JCOEF *values, size_t *zerobits)
+                                  int Al, UJCOEF *values, size_t *zerobits)
 {
   jsimd_encode_mcu_AC_first_prepare_neon(block, jpeg_natural_order_start,
                                          Sl, Al, values, zerobits);
@@ -1048,7 +1045,7 @@ jsimd_can_encode_mcu_AC_refine_prepare(void)
 GLOBAL(int)
 jsimd_encode_mcu_AC_refine_prepare(const JCOEF *block,
                                    const int *jpeg_natural_order_start, int Sl,
-                                   int Al, JCOEF *absvalues, size_t *bits)
+                                   int Al, UJCOEF *absvalues, size_t *bits)
 {
   return jsimd_encode_mcu_AC_refine_prepare_neon(block,
                                                  jpeg_natural_order_start,
diff --git a/simd/arm/jcphuff-neon.c b/simd/arm/jcphuff-neon.c
index b91c5db..51db3c5 100644
--- a/simd/arm/jcphuff-neon.c
+++ b/simd/arm/jcphuff-neon.c
@@ -2,6 +2,8 @@
  * jcphuff-neon.c - prepare data for progressive Huffman encoding (Arm Neon)
  *
  * Copyright (C) 2020-2021, Arm Limited.  All Rights Reserved.
+ * Copyright (C) 2022, Matthieu Darbois.  All Rights Reserved.
+ * Copyright (C) 2022, D. R. Commander.  All Rights Reserved.
  *
  * This software is provided 'as-is', without any express or implied
  * warranty.  In no event will the authors be held liable for any damages
@@ -21,7 +23,6 @@
  */
 
 #define JPEG_INTERNALS
-#include "jconfigint.h"
 #include "../../jinclude.h"
 #include "../../jpeglib.h"
 #include "../../jsimd.h"
@@ -41,10 +42,10 @@
 
 void jsimd_encode_mcu_AC_first_prepare_neon
   (const JCOEF *block, const int *jpeg_natural_order_start, int Sl, int Al,
-   JCOEF *values, size_t *zerobits)
+   UJCOEF *values, size_t *zerobits)
 {
-  JCOEF *values_ptr = values;
-  JCOEF *diff_values_ptr = values + DCTSIZE2;
+  UJCOEF *values_ptr = values;
+  UJCOEF *diff_values_ptr = values + DCTSIZE2;
 
   /* Rows of coefficients to zero (since they haven't been processed) */
   int i, rows_to_zero = 8;
@@ -68,23 +69,23 @@ void jsimd_encode_mcu_AC_first_prepare_neon
     coefs2 = vld1q_lane_s16(block + jpeg_natural_order_start[15], coefs2, 7);
 
     /* Isolate sign of coefficients. */
-    int16x8_t sign_coefs1 = vshrq_n_s16(coefs1, 15);
-    int16x8_t sign_coefs2 = vshrq_n_s16(coefs2, 15);
+    uint16x8_t sign_coefs1 = vreinterpretq_u16_s16(vshrq_n_s16(coefs1, 15));
+    uint16x8_t sign_coefs2 = vreinterpretq_u16_s16(vshrq_n_s16(coefs2, 15));
     /* Compute absolute value of coefficients and apply point transform Al. */
-    int16x8_t abs_coefs1 = vabsq_s16(coefs1);
-    int16x8_t abs_coefs2 = vabsq_s16(coefs2);
-    coefs1 = vshlq_s16(abs_coefs1, vdupq_n_s16(-Al));
-    coefs2 = vshlq_s16(abs_coefs2, vdupq_n_s16(-Al));
+    uint16x8_t abs_coefs1 = vreinterpretq_u16_s16(vabsq_s16(coefs1));
+    uint16x8_t abs_coefs2 = vreinterpretq_u16_s16(vabsq_s16(coefs2));
+    abs_coefs1 = vshlq_u16(abs_coefs1, vdupq_n_s16(-Al));
+    abs_coefs2 = vshlq_u16(abs_coefs2, vdupq_n_s16(-Al));
 
     /* Compute diff values. */
-    int16x8_t diff1 = veorq_s16(coefs1, sign_coefs1);
-    int16x8_t diff2 = veorq_s16(coefs2, sign_coefs2);
+    uint16x8_t diff1 = veorq_u16(abs_coefs1, sign_coefs1);
+    uint16x8_t diff2 = veorq_u16(abs_coefs2, sign_coefs2);
 
     /* Store transformed coefficients and diff values. */
-    vst1q_s16(values_ptr, coefs1);
-    vst1q_s16(values_ptr + DCTSIZE, coefs2);
-    vst1q_s16(diff_values_ptr, diff1);
-    vst1q_s16(diff_values_ptr + DCTSIZE, diff2);
+    vst1q_u16(values_ptr, abs_coefs1);
+    vst1q_u16(values_ptr + DCTSIZE, abs_coefs2);
+    vst1q_u16(diff_values_ptr, diff1);
+    vst1q_u16(diff_values_ptr + DCTSIZE, diff2);
     values_ptr += 16;
     diff_values_ptr += 16;
     jpeg_natural_order_start += 16;
@@ -130,23 +131,23 @@ void jsimd_encode_mcu_AC_first_prepare_neon
     }
 
     /* Isolate sign of coefficients. */
-    int16x8_t sign_coefs1 = vshrq_n_s16(coefs1, 15);
-    int16x8_t sign_coefs2 = vshrq_n_s16(coefs2, 15);
+    uint16x8_t sign_coefs1 = vreinterpretq_u16_s16(vshrq_n_s16(coefs1, 15));
+    uint16x8_t sign_coefs2 = vreinterpretq_u16_s16(vshrq_n_s16(coefs2, 15));
     /* Compute absolute value of coefficients and apply point transform Al. */
-    int16x8_t abs_coefs1 = vabsq_s16(coefs1);
-    int16x8_t abs_coefs2 = vabsq_s16(coefs2);
-    coefs1 = vshlq_s16(abs_coefs1, vdupq_n_s16(-Al));
-    coefs2 = vshlq_s16(abs_coefs2, vdupq_n_s16(-Al));
+    uint16x8_t abs_coefs1 = vreinterpretq_u16_s16(vabsq_s16(coefs1));
+    uint16x8_t abs_coefs2 = vreinterpretq_u16_s16(vabsq_s16(coefs2));
+    abs_coefs1 = vshlq_u16(abs_coefs1, vdupq_n_s16(-Al));
+    abs_coefs2 = vshlq_u16(abs_coefs2, vdupq_n_s16(-Al));
 
     /* Compute diff values. */
-    int16x8_t diff1 = veorq_s16(coefs1, sign_coefs1);
-    int16x8_t diff2 = veorq_s16(coefs2, sign_coefs2);
+    uint16x8_t diff1 = veorq_u16(abs_coefs1, sign_coefs1);
+    uint16x8_t diff2 = veorq_u16(abs_coefs2, sign_coefs2);
 
     /* Store transformed coefficients and diff values. */
-    vst1q_s16(values_ptr, coefs1);
-    vst1q_s16(values_ptr + DCTSIZE, coefs2);
-    vst1q_s16(diff_values_ptr, diff1);
-    vst1q_s16(diff_values_ptr + DCTSIZE, diff2);
+    vst1q_u16(values_ptr, abs_coefs1);
+    vst1q_u16(values_ptr + DCTSIZE, abs_coefs2);
+    vst1q_u16(diff_values_ptr, diff1);
+    vst1q_u16(diff_values_ptr + DCTSIZE, diff2);
     values_ptr += 16;
     diff_values_ptr += 16;
     rows_to_zero -= 2;
@@ -184,17 +185,17 @@ void jsimd_encode_mcu_AC_first_prepare_neon
     }
 
     /* Isolate sign of coefficients. */
-    int16x8_t sign_coefs = vshrq_n_s16(coefs, 15);
+    uint16x8_t sign_coefs = vreinterpretq_u16_s16(vshrq_n_s16(coefs, 15));
     /* Compute absolute value of coefficients and apply point transform Al. */
-    int16x8_t abs_coefs = vabsq_s16(coefs);
-    coefs = vshlq_s16(abs_coefs, vdupq_n_s16(-Al));
+    uint16x8_t abs_coefs = vreinterpretq_u16_s16(vabsq_s16(coefs));
+    abs_coefs = vshlq_u16(abs_coefs, vdupq_n_s16(-Al));
 
     /* Compute diff values. */
-    int16x8_t diff = veorq_s16(coefs, sign_coefs);
+    uint16x8_t diff = veorq_u16(abs_coefs, sign_coefs);
 
     /* Store transformed coefficients and diff values. */
-    vst1q_s16(values_ptr, coefs);
-    vst1q_s16(diff_values_ptr, diff);
+    vst1q_u16(values_ptr, abs_coefs);
+    vst1q_u16(diff_values_ptr, diff);
     values_ptr += 8;
     diff_values_ptr += 8;
     rows_to_zero--;
@@ -202,8 +203,8 @@ void jsimd_encode_mcu_AC_first_prepare_neon
 
   /* Zero remaining memory in the values and diff_values blocks. */
   for (i = 0; i < rows_to_zero; i++) {
-    vst1q_s16(values_ptr, vdupq_n_s16(0));
-    vst1q_s16(diff_values_ptr, vdupq_n_s16(0));
+    vst1q_u16(values_ptr, vdupq_n_u16(0));
+    vst1q_u16(diff_values_ptr, vdupq_n_u16(0));
     values_ptr += 8;
     diff_values_ptr += 8;
   }
@@ -211,23 +212,23 @@ void jsimd_encode_mcu_AC_first_prepare_neon
   /* Construct zerobits bitmap.  A set bit means that the corresponding
    * coefficient != 0.
    */
-  int16x8_t row0 = vld1q_s16(values + 0 * DCTSIZE);
-  int16x8_t row1 = vld1q_s16(values + 1 * DCTSIZE);
-  int16x8_t row2 = vld1q_s16(values + 2 * DCTSIZE);
-  int16x8_t row3 = vld1q_s16(values + 3 * DCTSIZE);
-  int16x8_t row4 = vld1q_s16(values + 4 * DCTSIZE);
-  int16x8_t row5 = vld1q_s16(values + 5 * DCTSIZE);
-  int16x8_t row6 = vld1q_s16(values + 6 * DCTSIZE);
-  int16x8_t row7 = vld1q_s16(values + 7 * DCTSIZE);
-
-  uint8x8_t row0_eq0 = vmovn_u16(vceqq_s16(row0, vdupq_n_s16(0)));
-  uint8x8_t row1_eq0 = vmovn_u16(vceqq_s16(row1, vdupq_n_s16(0)));
-  uint8x8_t row2_eq0 = vmovn_u16(vceqq_s16(row2, vdupq_n_s16(0)));
-  uint8x8_t row3_eq0 = vmovn_u16(vceqq_s16(row3, vdupq_n_s16(0)));
-  uint8x8_t row4_eq0 = vmovn_u16(vceqq_s16(row4, vdupq_n_s16(0)));
-  uint8x8_t row5_eq0 = vmovn_u16(vceqq_s16(row5, vdupq_n_s16(0)));
-  uint8x8_t row6_eq0 = vmovn_u16(vceqq_s16(row6, vdupq_n_s16(0)));
-  uint8x8_t row7_eq0 = vmovn_u16(vceqq_s16(row7, vdupq_n_s16(0)));
+  uint16x8_t row0 = vld1q_u16(values + 0 * DCTSIZE);
+  uint16x8_t row1 = vld1q_u16(values + 1 * DCTSIZE);
+  uint16x8_t row2 = vld1q_u16(values + 2 * DCTSIZE);
+  uint16x8_t row3 = vld1q_u16(values + 3 * DCTSIZE);
+  uint16x8_t row4 = vld1q_u16(values + 4 * DCTSIZE);
+  uint16x8_t row5 = vld1q_u16(values + 5 * DCTSIZE);
+  uint16x8_t row6 = vld1q_u16(values + 6 * DCTSIZE);
+  uint16x8_t row7 = vld1q_u16(values + 7 * DCTSIZE);
+
+  uint8x8_t row0_eq0 = vmovn_u16(vceqq_u16(row0, vdupq_n_u16(0)));
+  uint8x8_t row1_eq0 = vmovn_u16(vceqq_u16(row1, vdupq_n_u16(0)));
+  uint8x8_t row2_eq0 = vmovn_u16(vceqq_u16(row2, vdupq_n_u16(0)));
+  uint8x8_t row3_eq0 = vmovn_u16(vceqq_u16(row3, vdupq_n_u16(0)));
+  uint8x8_t row4_eq0 = vmovn_u16(vceqq_u16(row4, vdupq_n_u16(0)));
+  uint8x8_t row5_eq0 = vmovn_u16(vceqq_u16(row5, vdupq_n_u16(0)));
+  uint8x8_t row6_eq0 = vmovn_u16(vceqq_u16(row6, vdupq_n_u16(0)));
+  uint8x8_t row7_eq0 = vmovn_u16(vceqq_u16(row7, vdupq_n_u16(0)));
 
   /* { 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80 } */
   const uint8x8_t bitmap_mask =
@@ -274,7 +275,7 @@ void jsimd_encode_mcu_AC_first_prepare_neon
 
 int jsimd_encode_mcu_AC_refine_prepare_neon
   (const JCOEF *block, const int *jpeg_natural_order_start, int Sl, int Al,
-   JCOEF *absvalues, size_t *bits)
+   UJCOEF *absvalues, size_t *bits)
 {
   /* Temporary storage buffers for data used to compute the signbits bitmap and
    * the end-of-block (EOB) position
@@ -282,7 +283,7 @@ int jsimd_encode_mcu_AC_refine_prepare_neon
   uint8_t coef_sign_bits[64];
   uint8_t coef_eq1_bits[64];
 
-  JCOEF *absvalues_ptr = absvalues;
+  UJCOEF *absvalues_ptr = absvalues;
   uint8_t *coef_sign_bits_ptr = coef_sign_bits;
   uint8_t *eq1_bits_ptr = coef_eq1_bits;
 
@@ -316,18 +317,18 @@ int jsimd_encode_mcu_AC_refine_prepare_neon
     vst1_u8(coef_sign_bits_ptr + DCTSIZE, sign_coefs2);
 
     /* Compute absolute value of coefficients and apply point transform Al. */
-    int16x8_t abs_coefs1 = vabsq_s16(coefs1);
-    int16x8_t abs_coefs2 = vabsq_s16(coefs2);
-    coefs1 = vshlq_s16(abs_coefs1, vdupq_n_s16(-Al));
-    coefs2 = vshlq_s16(abs_coefs2, vdupq_n_s16(-Al));
-    vst1q_s16(absvalues_ptr, coefs1);
-    vst1q_s16(absvalues_ptr + DCTSIZE, coefs2);
+    uint16x8_t abs_coefs1 = vreinterpretq_u16_s16(vabsq_s16(coefs1));
+    uint16x8_t abs_coefs2 = vreinterpretq_u16_s16(vabsq_s16(coefs2));
+    abs_coefs1 = vshlq_u16(abs_coefs1, vdupq_n_s16(-Al));
+    abs_coefs2 = vshlq_u16(abs_coefs2, vdupq_n_s16(-Al));
+    vst1q_u16(absvalues_ptr, abs_coefs1);
+    vst1q_u16(absvalues_ptr + DCTSIZE, abs_coefs2);
 
     /* Test whether transformed coefficient values == 1 (used to find EOB
      * position.)
      */
-    uint8x8_t coefs_eq11 = vmovn_u16(vceqq_s16(coefs1, vdupq_n_s16(1)));
-    uint8x8_t coefs_eq12 = vmovn_u16(vceqq_s16(coefs2, vdupq_n_s16(1)));
+    uint8x8_t coefs_eq11 = vmovn_u16(vceqq_u16(abs_coefs1, vdupq_n_u16(1)));
+    uint8x8_t coefs_eq12 = vmovn_u16(vceqq_u16(abs_coefs2, vdupq_n_u16(1)));
     vst1_u8(eq1_bits_ptr, coefs_eq11);
     vst1_u8(eq1_bits_ptr + DCTSIZE, coefs_eq12);
 
@@ -385,18 +386,18 @@ int jsimd_encode_mcu_AC_refine_prepare_neon
     vst1_u8(coef_sign_bits_ptr + DCTSIZE, sign_coefs2);
 
     /* Compute absolute value of coefficients and apply point transform Al. */
-    int16x8_t abs_coefs1 = vabsq_s16(coefs1);
-    int16x8_t abs_coefs2 = vabsq_s16(coefs2);
-    coefs1 = vshlq_s16(abs_coefs1, vdupq_n_s16(-Al));
-    coefs2 = vshlq_s16(abs_coefs2, vdupq_n_s16(-Al));
-    vst1q_s16(absvalues_ptr, coefs1);
-    vst1q_s16(absvalues_ptr + DCTSIZE, coefs2);
+    uint16x8_t abs_coefs1 = vreinterpretq_u16_s16(vabsq_s16(coefs1));
+    uint16x8_t abs_coefs2 = vreinterpretq_u16_s16(vabsq_s16(coefs2));
+    abs_coefs1 = vshlq_u16(abs_coefs1, vdupq_n_s16(-Al));
+    abs_coefs2 = vshlq_u16(abs_coefs2, vdupq_n_s16(-Al));
+    vst1q_u16(absvalues_ptr, abs_coefs1);
+    vst1q_u16(absvalues_ptr + DCTSIZE, abs_coefs2);
 
     /* Test whether transformed coefficient values == 1 (used to find EOB
      * position.)
      */
-    uint8x8_t coefs_eq11 = vmovn_u16(vceqq_s16(coefs1, vdupq_n_s16(1)));
-    uint8x8_t coefs_eq12 = vmovn_u16(vceqq_s16(coefs2, vdupq_n_s16(1)));
+    uint8x8_t coefs_eq11 = vmovn_u16(vceqq_u16(abs_coefs1, vdupq_n_u16(1)));
+    uint8x8_t coefs_eq12 = vmovn_u16(vceqq_u16(abs_coefs2, vdupq_n_u16(1)));
     vst1_u8(eq1_bits_ptr, coefs_eq11);
     vst1_u8(eq1_bits_ptr + DCTSIZE, coefs_eq12);
 
@@ -444,14 +445,14 @@ int jsimd_encode_mcu_AC_refine_prepare_neon
     vst1_u8(coef_sign_bits_ptr, sign_coefs);
 
     /* Compute absolute value of coefficients and apply point transform Al. */
-    int16x8_t abs_coefs = vabsq_s16(coefs);
-    coefs = vshlq_s16(abs_coefs, vdupq_n_s16(-Al));
-    vst1q_s16(absvalues_ptr, coefs);
+    uint16x8_t abs_coefs = vreinterpretq_u16_s16(vabsq_s16(coefs));
+    abs_coefs = vshlq_u16(abs_coefs, vdupq_n_s16(-Al));
+    vst1q_u16(absvalues_ptr, abs_coefs);
 
     /* Test whether transformed coefficient values == 1 (used to find EOB
      * position.)
      */
-    uint8x8_t coefs_eq1 = vmovn_u16(vceqq_s16(coefs, vdupq_n_s16(1)));
+    uint8x8_t coefs_eq1 = vmovn_u16(vceqq_u16(abs_coefs, vdupq_n_u16(1)));
     vst1_u8(eq1_bits_ptr, coefs_eq1);
 
     absvalues_ptr += 8;
@@ -462,7 +463,7 @@ int jsimd_encode_mcu_AC_refine_prepare_neon
 
   /* Zero remaining memory in blocks. */
   for (i = 0; i < rows_to_zero; i++) {
-    vst1q_s16(absvalues_ptr, vdupq_n_s16(0));
+    vst1q_u16(absvalues_ptr, vdupq_n_u16(0));
     vst1_u8(coef_sign_bits_ptr, vdup_n_u8(0));
     vst1_u8(eq1_bits_ptr, vdup_n_u8(0));
     absvalues_ptr += 8;
@@ -471,23 +472,23 @@ int jsimd_encode_mcu_AC_refine_prepare_neon
   }
 
   /* Construct zerobits bitmap. */
-  int16x8_t abs_row0 = vld1q_s16(absvalues + 0 * DCTSIZE);
-  int16x8_t abs_row1 = vld1q_s16(absvalues + 1 * DCTSIZE);
-  int16x8_t abs_row2 = vld1q_s16(absvalues + 2 * DCTSIZE);
-  int16x8_t abs_row3 = vld1q_s16(absvalues + 3 * DCTSIZE);
-  int16x8_t abs_row4 = vld1q_s16(absvalues + 4 * DCTSIZE);
-  int16x8_t abs_row5 = vld1q_s16(absvalues + 5 * DCTSIZE);
-  int16x8_t abs_row6 = vld1q_s16(absvalues + 6 * DCTSIZE);
-  int16x8_t abs_row7 = vld1q_s16(absvalues + 7 * DCTSIZE);
-
-  uint8x8_t abs_row0_eq0 = vmovn_u16(vceqq_s16(abs_row0, vdupq_n_s16(0)));
-  uint8x8_t abs_row1_eq0 = vmovn_u16(vceqq_s16(abs_row1, vdupq_n_s16(0)));
-  uint8x8_t abs_row2_eq0 = vmovn_u16(vceqq_s16(abs_row2, vdupq_n_s16(0)));
-  uint8x8_t abs_row3_eq0 = vmovn_u16(vceqq_s16(abs_row3, vdupq_n_s16(0)));
-  uint8x8_t abs_row4_eq0 = vmovn_u16(vceqq_s16(abs_row4, vdupq_n_s16(0)));
-  uint8x8_t abs_row5_eq0 = vmovn_u16(vceqq_s16(abs_row5, vdupq_n_s16(0)));
-  uint8x8_t abs_row6_eq0 = vmovn_u16(vceqq_s16(abs_row6, vdupq_n_s16(0)));
-  uint8x8_t abs_row7_eq0 = vmovn_u16(vceqq_s16(abs_row7, vdupq_n_s16(0)));
+  uint16x8_t abs_row0 = vld1q_u16(absvalues + 0 * DCTSIZE);
+  uint16x8_t abs_row1 = vld1q_u16(absvalues + 1 * DCTSIZE);
+  uint16x8_t abs_row2 = vld1q_u16(absvalues + 2 * DCTSIZE);
+  uint16x8_t abs_row3 = vld1q_u16(absvalues + 3 * DCTSIZE);
+  uint16x8_t abs_row4 = vld1q_u16(absvalues + 4 * DCTSIZE);
+  uint16x8_t abs_row5 = vld1q_u16(absvalues + 5 * DCTSIZE);
+  uint16x8_t abs_row6 = vld1q_u16(absvalues + 6 * DCTSIZE);
+  uint16x8_t abs_row7 = vld1q_u16(absvalues + 7 * DCTSIZE);
+
+  uint8x8_t abs_row0_eq0 = vmovn_u16(vceqq_u16(abs_row0, vdupq_n_u16(0)));
+  uint8x8_t abs_row1_eq0 = vmovn_u16(vceqq_u16(abs_row1, vdupq_n_u16(0)));
+  uint8x8_t abs_row2_eq0 = vmovn_u16(vceqq_u16(abs_row2, vdupq_n_u16(0)));
+  uint8x8_t abs_row3_eq0 = vmovn_u16(vceqq_u16(abs_row3, vdupq_n_u16(0)));
+  uint8x8_t abs_row4_eq0 = vmovn_u16(vceqq_u16(abs_row4, vdupq_n_u16(0)));
+  uint8x8_t abs_row5_eq0 = vmovn_u16(vceqq_u16(abs_row5, vdupq_n_u16(0)));
+  uint8x8_t abs_row6_eq0 = vmovn_u16(vceqq_u16(abs_row6, vdupq_n_u16(0)));
+  uint8x8_t abs_row7_eq0 = vmovn_u16(vceqq_u16(abs_row7, vdupq_n_u16(0)));
 
   /* { 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80 } */
   const uint8x8_t bitmap_mask =
diff --git a/simd/arm/jdcolor-neon.c b/simd/arm/jdcolor-neon.c
index ea4668f..28dbc57 100644
--- a/simd/arm/jdcolor-neon.c
+++ b/simd/arm/jdcolor-neon.c
@@ -21,7 +21,6 @@
  */
 
 #define JPEG_INTERNALS
-#include "jconfigint.h"
 #include "../../jinclude.h"
 #include "../../jpeglib.h"
 #include "../../jsimd.h"
diff --git a/simd/arm/jdmerge-neon.c b/simd/arm/jdmerge-neon.c
index e4f91fd..18fb9d8 100644
--- a/simd/arm/jdmerge-neon.c
+++ b/simd/arm/jdmerge-neon.c
@@ -21,7 +21,6 @@
  */
 
 #define JPEG_INTERNALS
-#include "jconfigint.h"
 #include "../../jinclude.h"
 #include "../../jpeglib.h"
 #include "../../jsimd.h"
diff --git a/simd/arm/jidctint-neon.c b/simd/arm/jidctint-neon.c
index 043b652..d25112e 100644
--- a/simd/arm/jidctint-neon.c
+++ b/simd/arm/jidctint-neon.c
@@ -22,7 +22,6 @@
  */
 
 #define JPEG_INTERNALS
-#include "jconfigint.h"
 #include "../../jinclude.h"
 #include "../../jpeglib.h"
 #include "../../jsimd.h"
diff --git a/simd/i386/jsimd.c b/simd/i386/jsimd.c
index 80bc821..b429b0a 100644
--- a/simd/i386/jsimd.c
+++ b/simd/i386/jsimd.c
@@ -2,8 +2,8 @@
  * jsimd_i386.c
  *
  * Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
- * Copyright (C) 2009-2011, 2013-2014, 2016, 2018, 2022, D. R. Commander.
- * Copyright (C) 2015-2016, 2018, Matthieu Darbois.
+ * Copyright (C) 2009-2011, 2013-2014, 2016, 2018, 2022-2023, D. R. Commander.
+ * Copyright (C) 2015-2016, 2018, 2022, Matthieu Darbois.
  *
  * Based on the x86 SIMD extension for IJG JPEG library,
  * Copyright (C) 1999-2006, MIYASAKA Masaru.
@@ -21,7 +21,6 @@
 #include "../../jdct.h"
 #include "../../jsimddct.h"
 #include "../jsimd.h"
-#include "jconfigint.h"
 
 /*
  * In the PIC cases, we have no guarantee that constants will keep
@@ -32,13 +31,11 @@
 #define IS_ALIGNED_SSE(ptr)  (IS_ALIGNED(ptr, 4)) /* 16 byte alignment */
 #define IS_ALIGNED_AVX(ptr)  (IS_ALIGNED(ptr, 5)) /* 32 byte alignment */
 
-static unsigned int simd_support = (unsigned int)(~0);
-static unsigned int simd_huffman = 1;
+static THREAD_LOCAL unsigned int simd_support = (unsigned int)(~0);
+static THREAD_LOCAL unsigned int simd_huffman = 1;
 
 /*
  * Check what SIMD accelerations are supported.
- *
- * FIXME: This code is racy under a multi-threaded environment.
  */
 LOCAL(void)
 init_simd(void)
@@ -161,6 +158,9 @@ jsimd_rgb_ycc_convert(j_compress_ptr cinfo, JSAMPARRAY input_buf,
   void (*sse2fct) (JDIMENSION, JSAMPARRAY, JSAMPIMAGE, JDIMENSION, int);
   void (*mmxfct) (JDIMENSION, JSAMPARRAY, JSAMPIMAGE, JDIMENSION, int);
 
+  if (simd_support == ~0U)
+    init_simd();
+
   switch (cinfo->in_color_space) {
   case JCS_EXT_RGB:
     avx2fct = jsimd_extrgb_ycc_convert_avx2;
@@ -220,6 +220,9 @@ jsimd_rgb_gray_convert(j_compress_ptr cinfo, JSAMPARRAY input_buf,
   void (*sse2fct) (JDIMENSION, JSAMPARRAY, JSAMPIMAGE, JDIMENSION, int);
   void (*mmxfct) (JDIMENSION, JSAMPARRAY, JSAMPIMAGE, JDIMENSION, int);
 
+  if (simd_support == ~0U)
+    init_simd();
+
   switch (cinfo->in_color_space) {
   case JCS_EXT_RGB:
     avx2fct = jsimd_extrgb_gray_convert_avx2;
@@ -279,6 +282,9 @@ jsimd_ycc_rgb_convert(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,
   void (*sse2fct) (JDIMENSION, JSAMPIMAGE, JDIMENSION, JSAMPARRAY, int);
   void (*mmxfct) (JDIMENSION, JSAMPIMAGE, JDIMENSION, JSAMPARRAY, int);
 
+  if (simd_support == ~0U)
+    init_simd();
+
   switch (cinfo->out_color_space) {
   case JCS_EXT_RGB:
     avx2fct = jsimd_ycc_extrgb_convert_avx2;
@@ -382,6 +388,9 @@ GLOBAL(void)
 jsimd_h2v2_downsample(j_compress_ptr cinfo, jpeg_component_info *compptr,
                       JSAMPARRAY input_data, JSAMPARRAY output_data)
 {
+  if (simd_support == ~0U)
+    init_simd();
+
   if (simd_support & JSIMD_AVX2)
     jsimd_h2v2_downsample_avx2(cinfo->image_width, cinfo->max_v_samp_factor,
                                compptr->v_samp_factor,
@@ -402,6 +411,9 @@ GLOBAL(void)
 jsimd_h2v1_downsample(j_compress_ptr cinfo, jpeg_component_info *compptr,
                       JSAMPARRAY input_data, JSAMPARRAY output_data)
 {
+  if (simd_support == ~0U)
+    init_simd();
+
   if (simd_support & JSIMD_AVX2)
     jsimd_h2v1_downsample_avx2(cinfo->image_width, cinfo->max_v_samp_factor,
                                compptr->v_samp_factor,
@@ -464,6 +476,9 @@ GLOBAL(void)
 jsimd_h2v2_upsample(j_decompress_ptr cinfo, jpeg_component_info *compptr,
                     JSAMPARRAY input_data, JSAMPARRAY *output_data_ptr)
 {
+  if (simd_support == ~0U)
+    init_simd();
+
   if (simd_support & JSIMD_AVX2)
     jsimd_h2v2_upsample_avx2(cinfo->max_v_samp_factor, cinfo->output_width,
                              input_data, output_data_ptr);
@@ -479,6 +494,9 @@ GLOBAL(void)
 jsimd_h2v1_upsample(j_decompress_ptr cinfo, jpeg_component_info *compptr,
                     JSAMPARRAY input_data, JSAMPARRAY *output_data_ptr)
 {
+  if (simd_support == ~0U)
+    init_simd();
+
   if (simd_support & JSIMD_AVX2)
     jsimd_h2v1_upsample_avx2(cinfo->max_v_samp_factor, cinfo->output_width,
                              input_data, output_data_ptr);
@@ -540,6 +558,9 @@ GLOBAL(void)
 jsimd_h2v2_fancy_upsample(j_decompress_ptr cinfo, jpeg_component_info *compptr,
                           JSAMPARRAY input_data, JSAMPARRAY *output_data_ptr)
 {
+  if (simd_support == ~0U)
+    init_simd();
+
   if (simd_support & JSIMD_AVX2)
     jsimd_h2v2_fancy_upsample_avx2(cinfo->max_v_samp_factor,
                                    compptr->downsampled_width, input_data,
@@ -558,6 +579,9 @@ GLOBAL(void)
 jsimd_h2v1_fancy_upsample(j_decompress_ptr cinfo, jpeg_component_info *compptr,
                           JSAMPARRAY input_data, JSAMPARRAY *output_data_ptr)
 {
+  if (simd_support == ~0U)
+    init_simd();
+
   if (simd_support & JSIMD_AVX2)
     jsimd_h2v1_fancy_upsample_avx2(cinfo->max_v_samp_factor,
                                    compptr->downsampled_width, input_data,
@@ -626,6 +650,9 @@ jsimd_h2v2_merged_upsample(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,
   void (*sse2fct) (JDIMENSION, JSAMPIMAGE, JDIMENSION, JSAMPARRAY);
   void (*mmxfct) (JDIMENSION, JSAMPIMAGE, JDIMENSION, JSAMPARRAY);
 
+  if (simd_support == ~0U)
+    init_simd();
+
   switch (cinfo->out_color_space) {
   case JCS_EXT_RGB:
     avx2fct = jsimd_h2v2_extrgb_merged_upsample_avx2;
@@ -684,6 +711,9 @@ jsimd_h2v1_merged_upsample(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,
   void (*sse2fct) (JDIMENSION, JSAMPIMAGE, JDIMENSION, JSAMPARRAY);
   void (*mmxfct) (JDIMENSION, JSAMPIMAGE, JDIMENSION, JSAMPARRAY);
 
+  if (simd_support == ~0U)
+    init_simd();
+
   switch (cinfo->out_color_space) {
   case JCS_EXT_RGB:
     avx2fct = jsimd_h2v1_extrgb_merged_upsample_avx2;
@@ -788,6 +818,9 @@ GLOBAL(void)
 jsimd_convsamp(JSAMPARRAY sample_data, JDIMENSION start_col,
                DCTELEM *workspace)
 {
+  if (simd_support == ~0U)
+    init_simd();
+
   if (simd_support & JSIMD_AVX2)
     jsimd_convsamp_avx2(sample_data, start_col, workspace);
   else if (simd_support & JSIMD_SSE2)
@@ -800,6 +833,9 @@ GLOBAL(void)
 jsimd_convsamp_float(JSAMPARRAY sample_data, JDIMENSION start_col,
                      FAST_FLOAT *workspace)
 {
+  if (simd_support == ~0U)
+    init_simd();
+
   if (simd_support & JSIMD_SSE2)
     jsimd_convsamp_float_sse2(sample_data, start_col, workspace);
   else if (simd_support & JSIMD_SSE)
@@ -870,6 +906,9 @@ jsimd_can_fdct_float(void)
 GLOBAL(void)
 jsimd_fdct_islow(DCTELEM *data)
 {
+  if (simd_support == ~0U)
+    init_simd();
+
   if (simd_support & JSIMD_AVX2)
     jsimd_fdct_islow_avx2(data);
   else if (simd_support & JSIMD_SSE2)
@@ -881,6 +920,9 @@ jsimd_fdct_islow(DCTELEM *data)
 GLOBAL(void)
 jsimd_fdct_ifast(DCTELEM *data)
 {
+  if (simd_support == ~0U)
+    init_simd();
+
   if ((simd_support & JSIMD_SSE2) && IS_ALIGNED_SSE(jconst_fdct_islow_sse2))
     jsimd_fdct_ifast_sse2(data);
   else
@@ -890,6 +932,9 @@ jsimd_fdct_ifast(DCTELEM *data)
 GLOBAL(void)
 jsimd_fdct_float(FAST_FLOAT *data)
 {
+  if (simd_support == ~0U)
+    init_simd();
+
   if ((simd_support & JSIMD_SSE) && IS_ALIGNED_SSE(jconst_fdct_float_sse))
     jsimd_fdct_float_sse(data);
   else if (simd_support & JSIMD_3DNOW)
@@ -945,6 +990,9 @@ jsimd_can_quantize_float(void)
 GLOBAL(void)
 jsimd_quantize(JCOEFPTR coef_block, DCTELEM *divisors, DCTELEM *workspace)
 {
+  if (simd_support == ~0U)
+    init_simd();
+
   if (simd_support & JSIMD_AVX2)
     jsimd_quantize_avx2(coef_block, divisors, workspace);
   else if (simd_support & JSIMD_SSE2)
@@ -957,6 +1005,9 @@ GLOBAL(void)
 jsimd_quantize_float(JCOEFPTR coef_block, FAST_FLOAT *divisors,
                      FAST_FLOAT *workspace)
 {
+  if (simd_support == ~0U)
+    init_simd();
+
   if (simd_support & JSIMD_SSE2)
     jsimd_quantize_float_sse2(coef_block, divisors, workspace);
   else if (simd_support & JSIMD_SSE)
@@ -1020,6 +1071,9 @@ jsimd_idct_2x2(j_decompress_ptr cinfo, jpeg_component_info *compptr,
                JCOEFPTR coef_block, JSAMPARRAY output_buf,
                JDIMENSION output_col)
 {
+  if (simd_support == ~0U)
+    init_simd();
+
   if ((simd_support & JSIMD_SSE2) && IS_ALIGNED_SSE(jconst_idct_red_sse2))
     jsimd_idct_2x2_sse2(compptr->dct_table, coef_block, output_buf,
                         output_col);
@@ -1032,6 +1086,9 @@ jsimd_idct_4x4(j_decompress_ptr cinfo, jpeg_component_info *compptr,
                JCOEFPTR coef_block, JSAMPARRAY output_buf,
                JDIMENSION output_col)
 {
+  if (simd_support == ~0U)
+    init_simd();
+
   if ((simd_support & JSIMD_SSE2) && IS_ALIGNED_SSE(jconst_idct_red_sse2))
     jsimd_idct_4x4_sse2(compptr->dct_table, coef_block, output_buf,
                         output_col);
@@ -1126,6 +1183,9 @@ jsimd_idct_islow(j_decompress_ptr cinfo, jpeg_component_info *compptr,
                  JCOEFPTR coef_block, JSAMPARRAY output_buf,
                  JDIMENSION output_col)
 {
+  if (simd_support == ~0U)
+    init_simd();
+
   if (simd_support & JSIMD_AVX2)
     jsimd_idct_islow_avx2(compptr->dct_table, coef_block, output_buf,
                           output_col);
@@ -1142,6 +1202,9 @@ jsimd_idct_ifast(j_decompress_ptr cinfo, jpeg_component_info *compptr,
                  JCOEFPTR coef_block, JSAMPARRAY output_buf,
                  JDIMENSION output_col)
 {
+  if (simd_support == ~0U)
+    init_simd();
+
   if ((simd_support & JSIMD_SSE2) && IS_ALIGNED_SSE(jconst_idct_ifast_sse2))
     jsimd_idct_ifast_sse2(compptr->dct_table, coef_block, output_buf,
                           output_col);
@@ -1155,6 +1218,9 @@ jsimd_idct_float(j_decompress_ptr cinfo, jpeg_component_info *compptr,
                  JCOEFPTR coef_block, JSAMPARRAY output_buf,
                  JDIMENSION output_col)
 {
+  if (simd_support == ~0U)
+    init_simd();
+
   if ((simd_support & JSIMD_SSE2) && IS_ALIGNED_SSE(jconst_idct_float_sse2))
     jsimd_idct_float_sse2(compptr->dct_table, coef_block, output_buf,
                           output_col);
@@ -1212,7 +1278,7 @@ jsimd_can_encode_mcu_AC_first_prepare(void)
 GLOBAL(void)
 jsimd_encode_mcu_AC_first_prepare(const JCOEF *block,
                                   const int *jpeg_natural_order_start, int Sl,
-                                  int Al, JCOEF *values, size_t *zerobits)
+                                  int Al, UJCOEF *values, size_t *zerobits)
 {
   jsimd_encode_mcu_AC_first_prepare_sse2(block, jpeg_natural_order_start,
                                          Sl, Al, values, zerobits);
@@ -1238,7 +1304,7 @@ jsimd_can_encode_mcu_AC_refine_prepare(void)
 GLOBAL(int)
 jsimd_encode_mcu_AC_refine_prepare(const JCOEF *block,
                                    const int *jpeg_natural_order_start, int Sl,
-                                   int Al, JCOEF *absvalues, size_t *bits)
+                                   int Al, UJCOEF *absvalues, size_t *bits)
 {
   return jsimd_encode_mcu_AC_refine_prepare_sse2(block,
                                                  jpeg_natural_order_start,
diff --git a/simd/jsimd.h b/simd/jsimd.h
index 64747c6..8019d5d 100644
--- a/simd/jsimd.h
+++ b/simd/jsimd.h
@@ -2,10 +2,10 @@
  * simd/jsimd.h
  *
  * Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
- * Copyright (C) 2011, 2014-2016, 2018, 2020, D. R. Commander.
+ * Copyright (C) 2011, 2014-2016, 2018, 2020, 2022, D. R. Commander.
  * Copyright (C) 2013-2014, MIPS Technologies, Inc., California.
  * Copyright (C) 2014, Linaro Limited.
- * Copyright (C) 2015-2016, 2018, Matthieu Darbois.
+ * Copyright (C) 2015-2016, 2018, 2022, Matthieu Darbois.
  * Copyright (C) 2016-2018, Loongson Technology Corporation Limited, BeiJing.
  * Copyright (C) 2020, Arm Limited.
  *
@@ -27,6 +27,7 @@
 #define JSIMD_ALTIVEC  0x40
 #define JSIMD_AVX2     0x80
 #define JSIMD_MMI      0x100
+#define JSIMD_RVV      0x200
 
 /* SIMD Ext: retrieve SIMD/CPU information */
 EXTERN(unsigned int) jpeg_simd_cpu_support(void);
@@ -199,6 +200,29 @@ EXTERN(void) jsimd_extxrgb_ycc_convert_altivec
   (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
    JDIMENSION output_row, int num_rows);
 
+/* rvv */
+EXTERN(void) jsimd_rgb_ycc_convert_rvv
+  (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+   JDIMENSION output_row, int num_rows);
+EXTERN(void) jsimd_extrgb_ycc_convert_rvv
+  (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+   JDIMENSION output_row, int num_rows);
+EXTERN(void) jsimd_extrgbx_ycc_convert_rvv
+  (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+   JDIMENSION output_row, int num_rows);
+EXTERN(void) jsimd_extbgr_ycc_convert_rvv
+  (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+   JDIMENSION output_row, int num_rows);
+EXTERN(void) jsimd_extbgrx_ycc_convert_rvv
+  (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+   JDIMENSION output_row, int num_rows);
+EXTERN(void) jsimd_extxbgr_ycc_convert_rvv
+  (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+   JDIMENSION output_row, int num_rows);
+EXTERN(void) jsimd_extxrgb_ycc_convert_rvv
+  (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+   JDIMENSION output_row, int num_rows);
+
 /* RGB & extended RGB --> Grayscale Colorspace Conversion */
 EXTERN(void) jsimd_rgb_gray_convert_mmx
   (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
@@ -356,6 +380,29 @@ EXTERN(void) jsimd_extxrgb_gray_convert_altivec
   (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
    JDIMENSION output_row, int num_rows);
 
+/* rvv */
+EXTERN(void) jsimd_rgb_gray_convert_rvv
+  (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+   JDIMENSION output_row, int num_rows);
+EXTERN(void) jsimd_extrgb_gray_convert_rvv
+  (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+   JDIMENSION output_row, int num_rows);
+EXTERN(void) jsimd_extrgbx_gray_convert_rvv
+  (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+   JDIMENSION output_row, int num_rows);
+EXTERN(void) jsimd_extbgr_gray_convert_rvv
+  (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+   JDIMENSION output_row, int num_rows);
+EXTERN(void) jsimd_extbgrx_gray_convert_rvv
+  (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+   JDIMENSION output_row, int num_rows);
+EXTERN(void) jsimd_extxbgr_gray_convert_rvv
+  (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+   JDIMENSION output_row, int num_rows);
+EXTERN(void) jsimd_extxrgb_gray_convert_rvv
+  (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+   JDIMENSION output_row, int num_rows);
+
 /* YCC --> RGB & extended RGB Colorspace Conversion */
 EXTERN(void) jsimd_ycc_rgb_convert_mmx
   (JDIMENSION out_width, JSAMPIMAGE input_buf, JDIMENSION input_row,
@@ -527,6 +574,29 @@ EXTERN(void) jsimd_ycc_extxrgb_convert_altivec
   (JDIMENSION out_width, JSAMPIMAGE input_buf, JDIMENSION input_row,
    JSAMPARRAY output_buf, int num_rows);
 
+/* rvv */
+EXTERN(void) jsimd_ycc_rgb_convert_rvv
+  (JDIMENSION out_width, JSAMPIMAGE input_buf, JDIMENSION input_row,
+   JSAMPARRAY output_buf, int num_rows);
+EXTERN(void) jsimd_ycc_extrgb_convert_rvv
+  (JDIMENSION out_width, JSAMPIMAGE input_buf, JDIMENSION input_row,
+   JSAMPARRAY output_buf, int num_rows);
+EXTERN(void) jsimd_ycc_extrgbx_convert_rvv
+  (JDIMENSION out_width, JSAMPIMAGE input_buf, JDIMENSION input_row,
+   JSAMPARRAY output_buf, int num_rows);
+EXTERN(void) jsimd_ycc_extbgr_convert_rvv
+  (JDIMENSION out_width, JSAMPIMAGE input_buf, JDIMENSION input_row,
+   JSAMPARRAY output_buf, int num_rows);
+EXTERN(void) jsimd_ycc_extbgrx_convert_rvv
+  (JDIMENSION out_width, JSAMPIMAGE input_buf, JDIMENSION input_row,
+   JSAMPARRAY output_buf, int num_rows);
+EXTERN(void) jsimd_ycc_extxbgr_convert_rvv
+  (JDIMENSION out_width, JSAMPIMAGE input_buf, JDIMENSION input_row,
+   JSAMPARRAY output_buf, int num_rows);
+EXTERN(void) jsimd_ycc_extxrgb_convert_rvv
+  (JDIMENSION out_width, JSAMPIMAGE input_buf, JDIMENSION input_row,
+   JSAMPARRAY output_buf, int num_rows);
+
 /* NULL Colorspace Conversion */
 EXTERN(void) jsimd_c_null_convert_dspr2
   (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
@@ -557,6 +627,10 @@ EXTERN(void) jsimd_h2v1_downsample_altivec
   (JDIMENSION image_width, int max_v_samp_factor, JDIMENSION v_samp_factor,
    JDIMENSION width_in_blocks, JSAMPARRAY input_data, JSAMPARRAY output_data);
 
+EXTERN(void) jsimd_h2v1_downsample_rvv
+  (JDIMENSION image_width, int max_v_samp_factor, JDIMENSION v_samp_factor,
+   JDIMENSION width_in_blocks, JSAMPARRAY input_data, JSAMPARRAY output_data);
+
 /* h2v2 Downsampling */
 EXTERN(void) jsimd_h2v2_downsample_mmx
   (JDIMENSION image_width, int max_v_samp_factor, JDIMENSION v_samp_factor,
@@ -586,6 +660,10 @@ EXTERN(void) jsimd_h2v2_downsample_altivec
   (JDIMENSION image_width, int max_v_samp_factor, JDIMENSION v_samp_factor,
    JDIMENSION width_in_blocks, JSAMPARRAY input_data, JSAMPARRAY output_data);
 
+EXTERN(void) jsimd_h2v2_downsample_rvv
+  (JDIMENSION image_width, int max_v_samp_factor, JDIMENSION v_samp_factor,
+   JDIMENSION width_in_blocks, JSAMPARRAY input_data, JSAMPARRAY output_data);
+
 /* h2v2 Smooth Downsampling */
 EXTERN(void) jsimd_h2v2_smooth_downsample_dspr2
   (JSAMPARRAY input_data, JSAMPARRAY output_data, JDIMENSION v_samp_factor,
@@ -641,6 +719,13 @@ EXTERN(void) jsimd_h2v2_upsample_altivec
   (int max_v_samp_factor, JDIMENSION output_width, JSAMPARRAY input_data,
    JSAMPARRAY *output_data_ptr);
 
+EXTERN(void) jsimd_h2v1_upsample_rvv
+  (int max_v_samp_factor, JDIMENSION output_width, JSAMPARRAY input_data,
+   JSAMPARRAY *output_data_ptr);
+EXTERN(void) jsimd_h2v2_upsample_rvv
+  (int max_v_samp_factor, JDIMENSION output_width, JSAMPARRAY input_data,
+   JSAMPARRAY *output_data_ptr);
+
 /* Fancy Upsampling */
 EXTERN(void) jsimd_h2v1_fancy_upsample_mmx
   (int max_v_samp_factor, JDIMENSION downsampled_width, JSAMPARRAY input_data,
@@ -696,6 +781,16 @@ EXTERN(void) jsimd_h2v2_fancy_upsample_altivec
   (int max_v_samp_factor, JDIMENSION downsampled_width, JSAMPARRAY input_data,
    JSAMPARRAY *output_data_ptr);
 
+EXTERN(void) jsimd_h2v1_fancy_upsample_rvv
+  (int max_v_samp_factor, JDIMENSION downsampled_width, JSAMPARRAY input_data,
+   JSAMPARRAY *output_data_ptr);
+EXTERN(void) jsimd_h2v2_fancy_upsample_rvv
+  (int max_v_samp_factor, JDIMENSION downsampled_width, JSAMPARRAY input_data,
+   JSAMPARRAY *output_data_ptr);
+EXTERN(void) jsimd_h1v2_fancy_upsample_rvv
+  (int max_v_samp_factor, JDIMENSION downsampled_width, JSAMPARRAY input_data,
+   JSAMPARRAY *output_data_ptr);
+
 /* Merged Upsampling */
 EXTERN(void) jsimd_h2v1_merged_upsample_mmx
   (JDIMENSION output_width, JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
@@ -1007,6 +1102,51 @@ EXTERN(void) jsimd_h2v2_extxrgb_merged_upsample_altivec
   (JDIMENSION output_width, JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
    JSAMPARRAY output_buf);
 
+/* rvv */
+EXTERN(void) jsimd_h2v1_merged_upsample_rvv
+  (JDIMENSION output_width, JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
+   JSAMPARRAY output_buf);
+EXTERN(void) jsimd_h2v1_extrgb_merged_upsample_rvv
+  (JDIMENSION output_width, JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
+   JSAMPARRAY output_buf);
+EXTERN(void) jsimd_h2v1_extrgbx_merged_upsample_rvv
+  (JDIMENSION output_width, JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
+   JSAMPARRAY output_buf);
+EXTERN(void) jsimd_h2v1_extbgr_merged_upsample_rvv
+  (JDIMENSION output_width, JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
+   JSAMPARRAY output_buf);
+EXTERN(void) jsimd_h2v1_extbgrx_merged_upsample_rvv
+  (JDIMENSION output_width, JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
+   JSAMPARRAY output_buf);
+EXTERN(void) jsimd_h2v1_extxbgr_merged_upsample_rvv
+  (JDIMENSION output_width, JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
+   JSAMPARRAY output_buf);
+EXTERN(void) jsimd_h2v1_extxrgb_merged_upsample_rvv
+  (JDIMENSION output_width, JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
+   JSAMPARRAY output_buf);
+
+EXTERN(void) jsimd_h2v2_merged_upsample_rvv
+  (JDIMENSION output_width, JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
+   JSAMPARRAY output_buf);
+EXTERN(void) jsimd_h2v2_extrgb_merged_upsample_rvv
+  (JDIMENSION output_width, JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
+   JSAMPARRAY output_buf);
+EXTERN(void) jsimd_h2v2_extrgbx_merged_upsample_rvv
+  (JDIMENSION output_width, JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
+   JSAMPARRAY output_buf);
+EXTERN(void) jsimd_h2v2_extbgr_merged_upsample_rvv
+  (JDIMENSION output_width, JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
+   JSAMPARRAY output_buf);
+EXTERN(void) jsimd_h2v2_extbgrx_merged_upsample_rvv
+  (JDIMENSION output_width, JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
+   JSAMPARRAY output_buf);
+EXTERN(void) jsimd_h2v2_extxbgr_merged_upsample_rvv
+  (JDIMENSION output_width, JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
+   JSAMPARRAY output_buf);
+EXTERN(void) jsimd_h2v2_extxrgb_merged_upsample_rvv
+  (JDIMENSION output_width, JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
+   JSAMPARRAY output_buf);
+
 /* Sample Conversion */
 EXTERN(void) jsimd_convsamp_mmx
   (JSAMPARRAY sample_data, JDIMENSION start_col, DCTELEM *workspace);
@@ -1026,6 +1166,9 @@ EXTERN(void) jsimd_convsamp_dspr2
 EXTERN(void) jsimd_convsamp_altivec
   (JSAMPARRAY sample_data, JDIMENSION start_col, DCTELEM *workspace);
 
+EXTERN(void) jsimd_convsamp_rvv
+  (JSAMPARRAY sample_data, JDIMENSION start_col, DCTELEM *workspace);
+
 /* Floating Point Sample Conversion */
 EXTERN(void) jsimd_convsamp_float_3dnow
   (JSAMPARRAY sample_data, JDIMENSION start_col, FAST_FLOAT *workspace);
@@ -1056,6 +1199,8 @@ EXTERN(void) jsimd_fdct_islow_mmi(DCTELEM *data);
 
 EXTERN(void) jsimd_fdct_islow_altivec(DCTELEM *data);
 
+EXTERN(void) jsimd_fdct_islow_rvv(DCTELEM *data);
+
 /* Fast Integer Forward DCT */
 EXTERN(void) jsimd_fdct_ifast_mmx(DCTELEM *data);
 
@@ -1070,6 +1215,8 @@ EXTERN(void) jsimd_fdct_ifast_mmi(DCTELEM *data);
 
 EXTERN(void) jsimd_fdct_ifast_altivec(DCTELEM *data);
 
+EXTERN(void) jsimd_fdct_ifast_rvv(DCTELEM *data);
+
 /* Floating Point Forward DCT */
 EXTERN(void) jsimd_fdct_float_3dnow(FAST_FLOAT *data);
 
@@ -1098,6 +1245,9 @@ EXTERN(void) jsimd_quantize_mmi
 EXTERN(void) jsimd_quantize_altivec
   (JCOEFPTR coef_block, DCTELEM *divisors, DCTELEM *workspace);
 
+EXTERN(void) jsimd_quantize_rvv
+  (JCOEFPTR coef_block, DCTELEM *divisors, DCTELEM *workspace);
+
 /* Floating Point Quantization */
 EXTERN(void) jsimd_quantize_float_3dnow
   (JCOEFPTR coef_block, FAST_FLOAT *divisors, FAST_FLOAT *workspace);
@@ -1148,6 +1298,13 @@ EXTERN(void) jsimd_idct_12x12_pass1_dspr2
 EXTERN(void) jsimd_idct_12x12_pass2_dspr2
   (int *workspace, int *output);
 
+EXTERN(void) jsimd_idct_2x2_rvv
+  (void *dct_table, JCOEFPTR coef_block, JSAMPARRAY output_buf,
+   JDIMENSION output_col);
+EXTERN(void) jsimd_idct_4x4_rvv
+  (void *dct_table, JCOEFPTR coef_block, JSAMPARRAY output_buf,
+   JDIMENSION output_col);
+
 /* Accurate Integer Inverse DCT */
 EXTERN(void) jsimd_idct_islow_mmx
   (void *dct_table, JCOEFPTR coef_block, JSAMPARRAY output_buf,
@@ -1178,6 +1335,10 @@ EXTERN(void) jsimd_idct_islow_altivec
   (void *dct_table, JCOEFPTR coef_block, JSAMPARRAY output_buf,
    JDIMENSION output_col);
 
+EXTERN(void) jsimd_idct_islow_rvv
+  (void *dct_table, JCOEFPTR coef_block, JSAMPARRAY output_buf,
+   JDIMENSION output_col);
+
 /* Fast Integer Inverse DCT */
 EXTERN(void) jsimd_idct_ifast_mmx
   (void *dct_table, JCOEFPTR coef_block, JSAMPARRAY output_buf,
@@ -1207,6 +1368,10 @@ EXTERN(void) jsimd_idct_ifast_altivec
   (void *dct_table, JCOEFPTR coef_block, JSAMPARRAY output_buf,
    JDIMENSION output_col);
 
+EXTERN(void) jsimd_idct_ifast_rvv
+  (void *dct_table, JCOEFPTR coef_block, JSAMPARRAY output_buf,
+   JDIMENSION output_col);
+
 /* Floating Point Inverse DCT */
 EXTERN(void) jsimd_idct_float_3dnow
   (void *dct_table, JCOEFPTR coef_block, JSAMPARRAY output_buf,
@@ -1243,16 +1408,16 @@ EXTERN(JOCTET *) jsimd_huff_encode_one_block_neon_slowtbl
 /* Progressive Huffman encoding */
 EXTERN(void) jsimd_encode_mcu_AC_first_prepare_sse2
   (const JCOEF *block, const int *jpeg_natural_order_start, int Sl, int Al,
-   JCOEF *values, size_t *zerobits);
+   UJCOEF *values, size_t *zerobits);
 
 EXTERN(void) jsimd_encode_mcu_AC_first_prepare_neon
   (const JCOEF *block, const int *jpeg_natural_order_start, int Sl, int Al,
-   JCOEF *values, size_t *zerobits);
+   UJCOEF *values, size_t *zerobits);
 
 EXTERN(int) jsimd_encode_mcu_AC_refine_prepare_sse2
   (const JCOEF *block, const int *jpeg_natural_order_start, int Sl, int Al,
-   JCOEF *absvalues, size_t *bits);
+   UJCOEF *absvalues, size_t *bits);
 
 EXTERN(int) jsimd_encode_mcu_AC_refine_prepare_neon
   (const JCOEF *block, const int *jpeg_natural_order_start, int Sl, int Al,
-   JCOEF *absvalues, size_t *bits);
+   UJCOEF *absvalues, size_t *bits);
diff --git a/simd/mips/jsimd.c b/simd/mips/jsimd.c
index 36ea865..c6e789a 100644
--- a/simd/mips/jsimd.c
+++ b/simd/mips/jsimd.c
@@ -2,9 +2,9 @@
  * jsimd_mips.c
  *
  * Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
- * Copyright (C) 2009-2011, 2014, 2016, 2018, 2020, D. R. Commander.
+ * Copyright (C) 2009-2011, 2014, 2016, 2018, 2020, 2022, D. R. Commander.
  * Copyright (C) 2013-2014, MIPS Technologies, Inc., California.
- * Copyright (C) 2015-2016, 2018, Matthieu Darbois.
+ * Copyright (C) 2015-2016, 2018, 2022, Matthieu Darbois.
  *
  * Based on the x86 SIMD extension for IJG JPEG library,
  * Copyright (C) 1999-2006, MIYASAKA Masaru.
@@ -25,7 +25,7 @@
 
 #include <ctype.h>
 
-static unsigned int simd_support = ~0;
+static THREAD_LOCAL unsigned int simd_support = ~0;
 
 #if !(defined(__mips_dsp) && (__mips_dsp_rev >= 2)) && defined(__linux__)
 
@@ -55,8 +55,6 @@ parse_proc_cpuinfo(const char *search_string)
 
 /*
  * Check what SIMD accelerations are supported.
- *
- * FIXME: This code is racy under a multi-threaded environment.
  */
 LOCAL(void)
 init_simd(void)
@@ -1126,7 +1124,7 @@ jsimd_can_encode_mcu_AC_first_prepare(void)
 GLOBAL(void)
 jsimd_encode_mcu_AC_first_prepare(const JCOEF *block,
                                   const int *jpeg_natural_order_start, int Sl,
-                                  int Al, JCOEF *values, size_t *zerobits)
+                                  int Al, UJCOEF *values, size_t *zerobits)
 {
 }
 
@@ -1139,7 +1137,7 @@ jsimd_can_encode_mcu_AC_refine_prepare(void)
 GLOBAL(int)
 jsimd_encode_mcu_AC_refine_prepare(const JCOEF *block,
                                    const int *jpeg_natural_order_start, int Sl,
-                                   int Al, JCOEF *absvalues, size_t *bits)
+                                   int Al, UJCOEF *absvalues, size_t *bits)
 {
   return 0;
 }
diff --git a/simd/mips64/jsimd.c b/simd/mips64/jsimd.c
index 2e626b2..917440b 100644
--- a/simd/mips64/jsimd.c
+++ b/simd/mips64/jsimd.c
@@ -2,9 +2,9 @@
  * jsimd_mips64.c
  *
  * Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
- * Copyright (C) 2009-2011, 2014, 2016, 2018, D. R. Commander.
+ * Copyright (C) 2009-2011, 2014, 2016, 2018, 2022, D. R. Commander.
  * Copyright (C) 2013-2014, MIPS Technologies, Inc., California.
- * Copyright (C) 2015, 2018, Matthieu Darbois.
+ * Copyright (C) 2015, 2018, 2022, Matthieu Darbois.
  * Copyright (C) 2016-2018, Loongson Technology Corporation Limited, BeiJing.
  *
  * Based on the x86 SIMD extension for IJG JPEG library,
@@ -26,7 +26,7 @@
 
 #include <ctype.h>
 
-static unsigned int simd_support = ~0;
+static THREAD_LOCAL unsigned int simd_support = ~0;
 
 #if defined(__linux__)
 
@@ -94,8 +94,6 @@ parse_proc_cpuinfo(int bufsize)
 
 /*
  * Check what SIMD accelerations are supported.
- *
- * FIXME: This code is racy under a multi-threaded environment.
  */
 LOCAL(void)
 init_simd(void)
@@ -849,7 +847,7 @@ jsimd_can_encode_mcu_AC_first_prepare(void)
 GLOBAL(void)
 jsimd_encode_mcu_AC_first_prepare(const JCOEF *block,
                                   const int *jpeg_natural_order_start, int Sl,
-                                  int Al, JCOEF *values, size_t *zerobits)
+                                  int Al, UJCOEF *values, size_t *zerobits)
 {
 }
 
@@ -862,7 +860,7 @@ jsimd_can_encode_mcu_AC_refine_prepare(void)
 GLOBAL(int)
 jsimd_encode_mcu_AC_refine_prepare(const JCOEF *block,
                                    const int *jpeg_natural_order_start, int Sl,
-                                   int Al, JCOEF *absvalues, size_t *bits)
+                                   int Al, UJCOEF *absvalues, size_t *bits)
 {
   return 0;
 }
diff --git a/simd/powerpc/jsimd.c b/simd/powerpc/jsimd.c
index 9a452a3..461f603 100644
--- a/simd/powerpc/jsimd.c
+++ b/simd/powerpc/jsimd.c
@@ -2,8 +2,8 @@
  * jsimd_powerpc.c
  *
  * Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
- * Copyright (C) 2009-2011, 2014-2016, 2018, D. R. Commander.
- * Copyright (C) 2015-2016, 2018, Matthieu Darbois.
+ * Copyright (C) 2009-2011, 2014-2016, 2018, 2022, D. R. Commander.
+ * Copyright (C) 2015-2016, 2018, 2022, Matthieu Darbois.
  *
  * Based on the x86 SIMD extension for IJG JPEG library,
  * Copyright (C) 1999-2006, MIYASAKA Masaru.
@@ -41,7 +41,7 @@
 #include <sys/auxv.h>
 #endif
 
-static unsigned int simd_support = ~0;
+static THREAD_LOCAL unsigned int simd_support = ~0;
 
 #if !defined(__ALTIVEC__) && (defined(__linux__) || defined(ANDROID) || defined(__ANDROID__))
 
@@ -109,8 +109,6 @@ parse_proc_cpuinfo(int bufsize)
 
 /*
  * Check what SIMD accelerations are supported.
- *
- * FIXME: This code is racy under a multi-threaded environment.
  */
 LOCAL(void)
 init_simd(void)
@@ -867,7 +865,7 @@ jsimd_can_encode_mcu_AC_first_prepare(void)
 GLOBAL(void)
 jsimd_encode_mcu_AC_first_prepare(const JCOEF *block,
                                   const int *jpeg_natural_order_start, int Sl,
-                                  int Al, JCOEF *values, size_t *zerobits)
+                                  int Al, UJCOEF *values, size_t *zerobits)
 {
 }
 
@@ -880,7 +878,7 @@ jsimd_can_encode_mcu_AC_refine_prepare(void)
 GLOBAL(int)
 jsimd_encode_mcu_AC_refine_prepare(const JCOEF *block,
                                    const int *jpeg_natural_order_start, int Sl,
-                                   int Al, JCOEF *absvalues, size_t *bits)
+                                   int Al, UJCOEF *absvalues, size_t *bits)
 {
   return 0;
 }
diff --git a/simd/rvv/jccolext-rvv.c b/simd/rvv/jccolext-rvv.c
new file mode 100644
index 0000000..2489688
--- /dev/null
+++ b/simd/rvv/jccolext-rvv.c
@@ -0,0 +1,145 @@
+/*
+ * Risc-V vector extension optimizations for libjpeg-turbo
+ *
+ * Copyright (C) 2023, Spacemit, Inc.  All Rights Reserved.
+ * Contributed by Liang Junzhao <junzhao.liang@spacemit.com>
+ *
+ * This software is provided 'as-is', without any express or implied
+ * warranty.  In no event will the authors be held liable for any damages
+ * arising from the use of this software.
+ *
+ * Permission is granted to anyone to use this software for any purpose,
+ * including commercial applications, and to alter it and redistribute it
+ * freely, subject to the following restrictions:
+ *
+ * 1. The origin of this software must not be misrepresented; you must not
+ *    claim that you wrote the original software. If you use this software
+ *    in a product, an acknowledgment in the product documentation would be
+ *    appreciated but is not required.
+ * 2. Altered source versions must be plainly marked as such, and must not be
+ *    misrepresented as being the original software.
+ * 3. This notice may not be removed or altered from any source distribution.
+ */
+
+/* This file is included by jccolor-rvv.c */
+
+/* RGB -> YCbCr conversion is defined by the following equations:
+ *    Y  =  0.29900 * R + 0.58700 * G + 0.11400 * B
+ *    Cb = -0.16874 * R - 0.33126 * G + 0.50000 * B  + 128
+ *    Cr =  0.50000 * R - 0.41869 * G - 0.08131 * B  + 128
+ *
+ * Avoid floating point arithmetic by using shifted integer constants:
+ *    0.29899597 = 19595 * 2^-16
+ *    0.58700561 = 38470 * 2^-16
+ *    0.11399841 =  7471 * 2^-16
+ *    0.16874695 = 11059 * 2^-16
+ *    0.33125305 = 21709 * 2^-16
+ *    0.50000000 = 32768 * 2^-16
+ *    0.41868592 = 27439 * 2^-16
+ *    0.08131409 =  5329 * 2^-16
+ * These constants are defined in jccolor-rvv.c
+ */
+
+#define JPEG_INTERNALS
+
+void jsimd_rgb_ycc_convert_rvv(JDIMENSION img_width, JSAMPARRAY input_buf,
+                               JSAMPIMAGE output_buf, JDIMENSION output_row,
+                               int num_rows)
+{
+    int pixels_remaining;
+    size_t vl;
+    ptrdiff_t bstride;
+    JSAMPROW inptr, outptr0, outptr1, outptr2;
+
+    vuint16m4_t r, g, b;
+    vuint16m4_t y, cb, cr;
+    vuint32m8_t accum, tmp;
+#if BITS_IN_JSAMPLE == 8
+    vuint8m2_t dest, src;
+#endif
+
+    bstride = RGB_PIXELSIZE * sizeof(JSAMPLE);
+
+    for (; num_rows > 0; ++input_buf, ++output_row, --num_rows)
+    {
+        inptr = *input_buf;
+        outptr0 = output_buf[0][output_row];
+        outptr1 = output_buf[1][output_row];
+        outptr2 = output_buf[2][output_row];
+
+        for (pixels_remaining = img_width; pixels_remaining > 0; pixels_remaining -= vl)
+        {
+            /* Set vl for each iteration. */
+            vl = __riscv_vsetvl_e16m4(pixels_remaining);
+
+            /* Load R, G, B channels as vectors from inptr. */
+#if BITS_IN_JSAMPLE == 8
+            /* Extending to vuint16m4_t type for following multiply calculation. */
+            src = __riscv_vlse8_v_u8m2(inptr + RGB_RED, bstride, vl);
+            r = __riscv_vwcvtu_x_x_v_u16m4(src, vl);
+            src = __riscv_vlse8_v_u8m2(inptr + RGB_GREEN, bstride, vl);
+            g = __riscv_vwcvtu_x_x_v_u16m4(src, vl);
+            src = __riscv_vlse8_v_u8m2(inptr + RGB_BLUE, bstride, vl);
+            b = __riscv_vwcvtu_x_x_v_u16m4(src, vl);
+#else /* BITS_IN_JSAMPLE == 12 */
+            r = __riscv_vlse16_v_u16m4(inptr + RGB_RED, bstride, vl);
+            g = __riscv_vlse16_v_u16m4(inptr + RGB_GREEN, bstride, vl);
+            b = __riscv_vlse16_v_u16m4(inptr + RGB_BLUE, bstride, vl);
+#endif
+
+            /* Calculate Y values */
+            accum = __riscv_vwmulu_vx_u32m8(r, F_0_299, vl);
+            accum = __riscv_vwmaccu_vx_u32m8(accum, F_0_587, g, vl);
+            accum = __riscv_vwmaccu_vx_u32m8(accum, F_0_114, b, vl);
+
+            // accum = __riscv_vadd_vx_u32m8(accum, ONE_HALF, vl);
+            // y = __riscv_vnsrl_wx_u16m4(accum, SCALEBITS, vl);
+            y = __riscv_vnclipu_wx_u16m4(accum, SCALEBITS, vl);
+
+#if BITS_IN_JSAMPLE == 8
+            dest = __riscv_vncvt_x_x_w_u8m2(y, vl);
+            __riscv_vse8_v_u8m2(outptr0, dest, vl);
+#else /* BITS_IN_JSAMPLE == 12 */
+            __riscv_vse16_v_u16m4(outptr0, y, vl);
+#endif
+
+            /* Calculate Cb values */
+            accum = __riscv_vwmulu_vx_u32m8(b, F_0_500, vl);
+            accum = __riscv_vadd_vx_u32m8(accum, SCALED_CENTERJSAMPLE+ONE_HALF - 1, vl);
+            tmp = __riscv_vwmulu_vx_u32m8(g, F_0_331, vl);
+            accum = __riscv_vsub_vv_u32m8(accum, tmp, vl);
+            tmp = __riscv_vwmulu_vx_u32m8(r, F_0_168, vl);
+            accum = __riscv_vsub_vv_u32m8(accum, tmp, vl);
+
+            cb = __riscv_vnsrl_wx_u16m4(accum, SCALEBITS, vl);
+
+#if BITS_IN_JSAMPLE == 8
+            dest = __riscv_vncvt_x_x_w_u8m2(cb, vl);
+            __riscv_vse8_v_u8m2(outptr1, dest, vl);
+#else /* BITS_IN_JSAMPLE == 12 */
+            __riscv_vse16_v_u16m4(outptr1, cb, vl);
+#endif
+
+            /* Calculate Cr values */
+            accum = __riscv_vwmulu_vx_u32m8(r, F_0_500, vl);
+            accum = __riscv_vadd_vx_u32m8(accum, SCALED_CENTERJSAMPLE+ONE_HALF - 1, vl);
+            tmp = __riscv_vwmulu_vx_u32m8(g, F_0_418, vl);
+            accum = __riscv_vsub_vv_u32m8(accum, tmp, vl);
+            tmp = __riscv_vwmulu_vx_u32m8(b, F_0_081, vl);
+            accum = __riscv_vsub_vv_u32m8(accum, tmp, vl);
+
+            cr = __riscv_vnsrl_wx_u16m4(accum, SCALEBITS, vl);
+
+#if BITS_IN_JSAMPLE == 8
+            dest = __riscv_vncvt_x_x_w_u8m2(cr, vl);
+            __riscv_vse8_v_u8m2(outptr2, dest, vl);
+#else /* BITS_IN_JSAMPLE == 12 */
+            __riscv_vse16_v_u16m4(outptr2, cr, vl);
+#endif
+            inptr += vl * RGB_PIXELSIZE;
+            outptr0 += vl;
+            outptr1 += vl;
+            outptr2 += vl;
+        }
+    }
+}
\ No newline at end of file
diff --git a/simd/rvv/jccolor-rvv.c b/simd/rvv/jccolor-rvv.c
new file mode 100644
index 0000000..e28905e
--- /dev/null
+++ b/simd/rvv/jccolor-rvv.c
@@ -0,0 +1,118 @@
+/*
+ * Risc-V vector extension optimizations for libjpeg-turbo
+ *
+ * Copyright (C) 2023, Spacemit, Inc.  All Rights Reserved.
+ * Contributed by Liang Junzhao <junzhao.liang@spacemit.com>
+ *
+ * This software is provided 'as-is', without any express or implied
+ * warranty.  In no event will the authors be held liable for any damages
+ * arising from the use of this software.
+ *
+ * Permission is granted to anyone to use this software for any purpose,
+ * including commercial applications, and to alter it and redistribute it
+ * freely, subject to the following restrictions:
+ *
+ * 1. The origin of this software must not be misrepresented; you must not
+ *    claim that you wrote the original software. If you use this software
+ *    in a product, an acknowledgment in the product documentation would be
+ *    appreciated but is not required.
+ * 2. Altered source versions must be plainly marked as such, and must not be
+ *    misrepresented as being the original software.
+ * 3. This notice may not be removed or altered from any source distribution.
+ */
+
+/* RGB --> YCC CONVERSION */
+#define JPEG_INTERNALS
+#include "jsimd_rvv.h"
+
+/* RGB -> YCbCr conversion constants */
+#define F_0_299 19595 /* 0.29899597 = 19595 * 2^-16 */
+#define F_0_587 38470 /* 0.58700561 = 38470 * 2^-16 */
+#define F_0_114 7471  /* 0.11399841 =  7471 * 2^-16 */
+#define F_0_168 11059 /* 0.16874695 = 11059 * 2^-16 */
+#define F_0_331 21709 /* 0.33125305 = 21709 * 2^-16 */
+#define F_0_500 32768 /* 0.50000000 = 32768 * 2^-16 */
+#define F_0_418 27439 /* 0.41868592 = 27439 * 2^-16 */
+#define F_0_081 5329  /* 0.08131409 =  5329 * 2^-16 */
+
+#define SCALEBITS 16
+#define ONE_HALF (1 << (SCALEBITS - 1))
+#define SCALED_CENTERJSAMPLE (CENTERJSAMPLE << SCALEBITS)
+
+#include "jccolext-rvv.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_PIXELSIZE
+
+#define RGB_RED EXT_RGB_RED
+#define RGB_GREEN EXT_RGB_GREEN
+#define RGB_BLUE EXT_RGB_BLUE
+#define RGB_PIXELSIZE EXT_RGB_PIXELSIZE
+#define jsimd_rgb_ycc_convert_rvv jsimd_extrgb_ycc_convert_rvv
+#include "jccolext-rvv.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_PIXELSIZE
+#undef jsimd_rgb_ycc_convert_rvv
+
+#define RGB_RED EXT_RGBX_RED
+#define RGB_GREEN EXT_RGBX_GREEN
+#define RGB_BLUE EXT_RGBX_BLUE
+#define RGB_PIXELSIZE EXT_RGBX_PIXELSIZE
+#define jsimd_rgb_ycc_convert_rvv jsimd_extrgbx_ycc_convert_rvv
+#include "jccolext-rvv.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_PIXELSIZE
+#undef jsimd_rgb_ycc_convert_rvv
+
+#define RGB_RED EXT_BGR_RED
+#define RGB_GREEN EXT_BGR_GREEN
+#define RGB_BLUE EXT_BGR_BLUE
+#define RGB_PIXELSIZE EXT_BGR_PIXELSIZE
+#define jsimd_rgb_ycc_convert_rvv jsimd_extbgr_ycc_convert_rvv
+#include "jccolext-rvv.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_PIXELSIZE
+#undef jsimd_rgb_ycc_convert_rvv
+
+#define RGB_RED EXT_BGRX_RED
+#define RGB_GREEN EXT_BGRX_GREEN
+#define RGB_BLUE EXT_BGRX_BLUE
+#define RGB_PIXELSIZE EXT_BGRX_PIXELSIZE
+#define jsimd_rgb_ycc_convert_rvv jsimd_extbgrx_ycc_convert_rvv
+#include "jccolext-rvv.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_PIXELSIZE
+#undef jsimd_rgb_ycc_convert_rvv
+
+#define RGB_RED EXT_XBGR_RED
+#define RGB_GREEN EXT_XBGR_GREEN
+#define RGB_BLUE EXT_XBGR_BLUE
+#define RGB_PIXELSIZE EXT_XBGR_PIXELSIZE
+#define jsimd_rgb_ycc_convert_rvv jsimd_extxbgr_ycc_convert_rvv
+#include "jccolext-rvv.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_PIXELSIZE
+#undef jsimd_rgb_ycc_convert_rvv
+
+#define RGB_RED EXT_XRGB_RED
+#define RGB_GREEN EXT_XRGB_GREEN
+#define RGB_BLUE EXT_XRGB_BLUE
+#define RGB_PIXELSIZE EXT_XRGB_PIXELSIZE
+#define jsimd_rgb_ycc_convert_rvv jsimd_extxrgb_ycc_convert_rvv
+#include "jccolext-rvv.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_PIXELSIZE
+#undef jsimd_rgb_ycc_convert_rvv
diff --git a/simd/rvv/jcgray-rvv.c b/simd/rvv/jcgray-rvv.c
new file mode 100644
index 0000000..8e389cb
--- /dev/null
+++ b/simd/rvv/jcgray-rvv.c
@@ -0,0 +1,112 @@
+/*
+ * Risc-V vector extension optimizations for libjpeg-turbo
+ *
+ * Copyright (C) 2023, Spacemit, Inc.  All Rights Reserved.
+ * Contributed by Liang Junzhao <junzhao.liang@spacemit.com>
+ *
+ * This software is provided 'as-is', without any express or implied
+ * warranty.  In no event will the authors be held liable for any damages
+ * arising from the use of this software.
+ *
+ * Permission is granted to anyone to use this software for any purpose,
+ * including commercial applications, and to alter it and redistribute it
+ * freely, subject to the following restrictions:
+ *
+ * 1. The origin of this software must not be misrepresented; you must not
+ *    claim that you wrote the original software. If you use this software
+ *    in a product, an acknowledgment in the product documentation would be
+ *    appreciated but is not required.
+ * 2. Altered source versions must be plainly marked as such, and must not be
+ *    misrepresented as being the original software.
+ * 3. This notice may not be removed or altered from any source distribution.
+ */
+
+/* RGB --> GRAYSCALE CONVERSION */
+#define JPEG_INTERNALS
+#include "jsimd_rvv.h"
+
+/* RGB -> GRAYSCALE CONVERSION constants */
+#define F_0_299 19595 /* 0.29899597 = 19595 * 2^-16 */
+#define F_0_587 38470 /* 0.58700561 = 38470 * 2^-16 */
+#define F_0_114 7471  /* 0.11399841 =  7471 * 2^-16 */
+
+#define SCALEBITS 16
+#define ONE_HALF (1 << (SCALEBITS - 1))
+
+#include "jcgryext-rvv.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_PIXELSIZE
+
+#define RGB_RED EXT_RGB_RED
+#define RGB_GREEN EXT_RGB_GREEN
+#define RGB_BLUE EXT_RGB_BLUE
+#define RGB_PIXELSIZE EXT_RGB_PIXELSIZE
+#define jsimd_rgb_gray_convert_rvv jsimd_extrgb_gray_convert_rvv
+#include "jcgryext-rvv.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_PIXELSIZE
+#undef jsimd_rgb_gray_convert_rvv
+
+#define RGB_RED EXT_RGBX_RED
+#define RGB_GREEN EXT_RGBX_GREEN
+#define RGB_BLUE EXT_RGBX_BLUE
+#define RGB_PIXELSIZE EXT_RGBX_PIXELSIZE
+#define jsimd_rgb_gray_convert_rvv jsimd_extrgbx_gray_convert_rvv
+#include "jcgryext-rvv.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_PIXELSIZE
+#undef jsimd_rgb_gray_convert_rvv
+
+#define RGB_RED EXT_BGR_RED
+#define RGB_GREEN EXT_BGR_GREEN
+#define RGB_BLUE EXT_BGR_BLUE
+#define RGB_PIXELSIZE EXT_BGR_PIXELSIZE
+#define jsimd_rgb_gray_convert_rvv jsimd_extbgr_gray_convert_rvv
+#include "jcgryext-rvv.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_PIXELSIZE
+#undef jsimd_rgb_gray_convert_rvv
+
+#define RGB_RED EXT_BGRX_RED
+#define RGB_GREEN EXT_BGRX_GREEN
+#define RGB_BLUE EXT_BGRX_BLUE
+#define RGB_PIXELSIZE EXT_BGRX_PIXELSIZE
+#define jsimd_rgb_gray_convert_rvv jsimd_extbgrx_gray_convert_rvv
+#include "jcgryext-rvv.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_PIXELSIZE
+#undef jsimd_rgb_gray_convert_rvv
+
+#define RGB_RED EXT_XBGR_RED
+#define RGB_GREEN EXT_XBGR_GREEN
+#define RGB_BLUE EXT_XBGR_BLUE
+#define RGB_PIXELSIZE EXT_XBGR_PIXELSIZE
+#define jsimd_rgb_gray_convert_rvv jsimd_extxbgr_gray_convert_rvv
+#include "jcgryext-rvv.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_PIXELSIZE
+#undef jsimd_rgb_gray_convert_rvv
+
+#define RGB_RED EXT_XRGB_RED
+#define RGB_GREEN EXT_XRGB_GREEN
+#define RGB_BLUE EXT_XRGB_BLUE
+#define RGB_PIXELSIZE EXT_XRGB_PIXELSIZE
+#define jsimd_rgb_gray_convert_rvv jsimd_extxrgb_gray_convert_rvv
+#include "jcgryext-rvv.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_PIXELSIZE
+#undef jsimd_rgb_gray_convert_rvv
diff --git a/simd/rvv/jcgryext-rvv.c b/simd/rvv/jcgryext-rvv.c
new file mode 100644
index 0000000..a84fb74
--- /dev/null
+++ b/simd/rvv/jcgryext-rvv.c
@@ -0,0 +1,104 @@
+/*
+ * Risc-V vector extension optimizations for libjpeg-turbo
+ *
+ * Copyright (C) 2023, Spacemit, Inc.  All Rights Reserved.
+ * Contributed by Liang Junzhao <junzhao.liang@spacemit.com>
+ *
+ * This software is provided 'as-is', without any express or implied
+ * warranty.  In no event will the authors be held liable for any damages
+ * arising from the use of this software.
+ *
+ * Permission is granted to anyone to use this software for any purpose,
+ * including commercial applications, and to alter it and redistribute it
+ * freely, subject to the following restrictions:
+ *
+ * 1. The origin of this software must not be misrepresented; you must not
+ *    claim that you wrote the original software. If you use this software
+ *    in a product, an acknowledgment in the product documentation would be
+ *    appreciated but is not required.
+ * 2. Altered source versions must be plainly marked as such, and must not be
+ *    misrepresented as being the original software.
+ * 3. This notice may not be removed or altered from any source distribution.
+ */
+
+/* This file is included by jcgray-rvv.c */
+
+/* RGB -> Grayscale conversion is defined by the following equation:
+ *    Y  =  0.29900 * R + 0.58700 * G + 0.11400 * B
+ *
+ * Avoid floating point arithmetic by using shifted integer constants:
+ *    0.29899597 = 19595 * 2^-16
+ *    0.58700561 = 38470 * 2^-16
+ *    0.11399841 =  7471 * 2^-16
+ * These constants are defined in jcgray-rvv.c
+ *
+ * This is the same computation as the RGB -> Y portion of RGB -> YCbCr.
+ */
+
+#define JPEG_INTERNALS
+
+void jsimd_rgb_gray_convert_rvv(JDIMENSION img_width, JSAMPARRAY input_buf,
+                                JSAMPIMAGE output_buf, JDIMENSION output_row,
+                                int num_rows)
+{
+    int pixels_remaining;
+    size_t vl;
+    ptrdiff_t bstride;
+    JSAMPROW inptr, outptr;
+
+    vuint16m4_t r, g, b, y;
+    vuint32m8_t accum;
+#if BITS_IN_JSAMPLE == 8
+    vuint8m2_t dest, src;
+#endif
+
+    bstride = RGB_PIXELSIZE * sizeof(JSAMPLE);
+
+    while (--num_rows >= 0)
+    {
+        inptr = *input_buf++;
+        outptr = output_buf[0][output_row++];
+
+        for (pixels_remaining = img_width; pixels_remaining > 0; pixels_remaining -= vl)
+        {
+            /* Set vl for each iteration. */
+            vl = __riscv_vsetvl_e16m4(pixels_remaining);
+
+            /* Load R, G, B channels as vectors from inptr. */
+#if BITS_IN_JSAMPLE == 8
+            /* Extending to vuint16m4_t type for following multiply calculation. */
+            src = __riscv_vlse8_v_u8m2(inptr + RGB_RED, bstride, vl);
+            r = __riscv_vwcvtu_x_x_v_u16m4(src, vl);
+            src = __riscv_vlse8_v_u8m2(inptr + RGB_GREEN, bstride, vl);
+            g = __riscv_vwcvtu_x_x_v_u16m4(src, vl);
+            src = __riscv_vlse8_v_u8m2(inptr + RGB_BLUE, bstride, vl);
+            b = __riscv_vwcvtu_x_x_v_u16m4(src, vl);
+#else /* BITS_IN_JSAMPLE == 12 */
+            r = __riscv_vlse16_v_u16m4(inptr + RGB_RED, bstride, vl);
+            g = __riscv_vlse16_v_u16m4(inptr + RGB_GREEN, bstride, vl);
+            b = __riscv_vlse16_v_u16m4(inptr + RGB_BLUE, bstride, vl);
+#endif
+
+            /* Calculate Y values */
+            accum = __riscv_vwmulu_vx_u32m8(r, F_0_299, vl);
+            accum = __riscv_vwmaccu_vx_u32m8(accum, F_0_587, g, vl);
+            accum = __riscv_vwmaccu_vx_u32m8(accum, F_0_114, b, vl);
+
+            // accum = __riscv_vssrl_vx_u32m8(accum, SCALEBITS, vl);
+            // y = __riscv_vncvt_x_x_w_u16m4(accum, vl);
+            // accum = __riscv_vadd_vx_u32m8(accum, ONE_HALF, vl);
+            // y = __riscv_vnsrl_wx_u16m4(accum, SCALEBITS, vl);
+            y = __riscv_vnclipu_wx_u16m4(accum, SCALEBITS, vl);
+
+#if BITS_IN_JSAMPLE == 8
+            dest = __riscv_vncvt_x_x_w_u8m2(y, vl);
+            // dest = __riscv_vnsrl_wx_u8m2(y, 0, vl);
+            __riscv_vse8_v_u8m2(outptr, dest, vl);
+#else /* BITS_IN_JSAMPLE == 12 */
+            __riscv_vse16_v_u16m4(outptr, y, vl);
+#endif
+            inptr += vl * RGB_PIXELSIZE;
+            outptr += vl;
+        }
+    }
+}
\ No newline at end of file
diff --git a/simd/rvv/jcsample-rvv.c b/simd/rvv/jcsample-rvv.c
new file mode 100644
index 0000000..2f8d087
--- /dev/null
+++ b/simd/rvv/jcsample-rvv.c
@@ -0,0 +1,149 @@
+/*
+ * Risc-V vector extension optimizations for libjpeg-turbo
+ *
+ * Copyright (C) 2023, Spacemit, Inc.  All Rights Reserved.
+ * Contributed by Liang Junzhao <junzhao.liang@spacemit.com>
+ *
+ * This software is provided 'as-is', without any express or implied
+ * warranty.  In no event will the authors be held liable for any damages
+ * arising from the use of this software.
+ *
+ * Permission is granted to anyone to use this software for any purpose,
+ * including commercial applications, and to alter it and redistribute it
+ * freely, subject to the following restrictions:
+ *
+ * 1. The origin of this software must not be misrepresented; you must not
+ *    claim that you wrote the original software. If you use this software
+ *    in a product, an acknowledgment in the product documentation would be
+ *    appreciated but is not required.
+ * 2. Altered source versions must be plainly marked as such, and must not be
+ *    misrepresented as being the original software.
+ * 3. This notice may not be removed or altered from any source distribution.
+ */
+
+/*
+ * Downsample pixel values of a single component.
+ * This version handles the common case of 2:1 horizontal and 1:1 vertical,
+ * without smoothing.
+ *
+ * A note about the "bias" calculations: when rounding fractional values to
+ * integer, we do not want to always round 0.5 up to the next integer.
+ * If we did that, we'd introduce a noticeable bias towards larger values.
+ * Instead, this code is arranged so that 0.5 will be rounded up or down at
+ * alternate pixel locations (a simple ordered dither pattern).
+ */
+
+#define JPEG_INTERNALS
+#include "jsimd_rvv.h"
+#include "jcsample.h"
+
+void jsimd_h2v1_downsample_rvv(JDIMENSION image_width,
+                               int max_v_samp_factor,
+                               JDIMENSION v_samp_factor,
+                               JDIMENSION width_in_blocks,
+                               JSAMPARRAY input_data,
+                               JSAMPARRAY output_data)
+{
+    int outrow, cols_remaining;
+    size_t vl;
+    JDIMENSION output_cols = width_in_blocks * DCTSIZE;
+    JSAMPROW inptr, outptr;
+
+    vuint8m2_t this_u8, next_u8, out;
+    vuint16m4_t this_u16, next_u16, bias;
+
+    /* in_width = out_width * 2 */
+    vl = __riscv_vsetvl_e16m4(output_cols * 2);
+    /* bias = 0, 1, 0, 1, 0, 1 ... */
+    bias = __riscv_vid_v_u16m4(vl);
+    // bias = __riscv_vremu_vx_u16m4(bias, 2, vl);//余可以用and做0xFC
+    bias = __riscv_vand_vx_u16m4(bias, 0x01, vl);
+
+    expand_right_edge_rvv(input_data, max_v_samp_factor, image_width, output_cols * 2);
+
+    for (outrow = 0; outrow < v_samp_factor; outrow++)
+    {
+        outptr = output_data[outrow];
+        inptr = input_data[outrow];
+
+        for (cols_remaining = output_cols; cols_remaining > 0; cols_remaining -= vl)
+        {
+            /* Set vl for each iteration. */
+            vl = __riscv_vsetvl_e16m4(cols_remaining * 2);
+
+            /* Load samples and the adjacent ones. */
+            this_u8 = __riscv_vlse8_v_u8m2(inptr, 2 * sizeof(JSAMPLE), vl);
+            next_u8 = __riscv_vlse8_v_u8m2(inptr + 1, 2 * sizeof(JSAMPLE), vl);
+
+            /* Widen to vuint16m4_t type. */
+            this_u16 = __riscv_vwcvtu_x_x_v_u16m4(this_u8, vl);
+            next_u16 = __riscv_vwcvtu_x_x_v_u16m4(next_u8, vl);
+
+            /* Add adjacent pixel values and add bias. */
+            this_u16 = __riscv_vadd_vv_u16m4(this_u16, next_u16, vl);
+            this_u16 = __riscv_vadd_vv_u16m4(this_u16, bias, vl);
+
+            /* Divide total by 2, narrow to 8-bit, and store. */
+            out = __riscv_vnsrl_wx_u8m2(this_u16, 1, vl);
+            __riscv_vse8_v_u8m2(outptr, out, vl);
+
+            inptr += vl * 2;
+            outptr += vl;
+        }
+    }
+}
+
+void jsimd_h2v2_downsample_rvv(JDIMENSION image_width, int max_v_samp_factor,
+                               JDIMENSION v_samp_factor,
+                               JDIMENSION width_in_blocks,
+                               JSAMPARRAY input_data, JSAMPARRAY output_data)
+{
+    int inrow, outrow, cols_remaining;
+    size_t vl;
+    JDIMENSION output_cols = width_in_blocks * DCTSIZE;
+    JSAMPROW inptr0, inptr1, outptr;
+
+    vuint8m2_t this0_u8m2, next0_u8m2, this1_u8m2, next1_u8m2, out_u8m2;
+    vuint16m4_t bias, out_u16m4, tmp_u16m4;
+
+    vl = __riscv_vsetvl_e16m4(output_cols * 2);
+    /* bias = 1, 2, 1, 2, 1, 2 ... */
+    bias = __riscv_vid_v_u16m4(vl);
+    bias = __riscv_vremu_vx_u16m4(bias, 2, vl);
+    bias = __riscv_vadd_vx_u16m4(bias, 1, vl);
+
+    expand_right_edge_rvv(input_data, max_v_samp_factor, image_width, output_cols * 2);
+
+    for (inrow = 0, outrow = 0; outrow < v_samp_factor; inrow += 2, outrow++)
+    {
+        inptr0 = input_data[inrow];
+        inptr1 = input_data[inrow + 1];
+        outptr = output_data[outrow];
+
+        for (cols_remaining = output_cols; cols_remaining > 0; cols_remaining -= vl)
+        {
+            /* Set vl for each iteration. */
+            vl = __riscv_vsetvl_e16m4(cols_remaining * 2);
+
+            /* Load samples and the adjacent ones of two rows. */
+            this0_u8m2 = __riscv_vlse8_v_u8m2(inptr0, 2 * sizeof(JSAMPLE), vl);
+            next0_u8m2 = __riscv_vlse8_v_u8m2(inptr0 + 1, 2 * sizeof(JSAMPLE), vl);
+            this1_u8m2 = __riscv_vlse8_v_u8m2(inptr1, 2 * sizeof(JSAMPLE), vl);
+            next1_u8m2 = __riscv_vlse8_v_u8m2(inptr1 + 1, 2 * sizeof(JSAMPLE), vl);
+
+            /* Add adjacent pixel values and add bias. */
+            out_u16m4 = __riscv_vwaddu_vv_u16m4(this0_u8m2, next0_u8m2, vl);
+            tmp_u16m4 = __riscv_vwaddu_vv_u16m4(this1_u8m2, next1_u8m2, vl);
+            out_u16m4 = __riscv_vadd_vv_u16m4(out_u16m4, tmp_u16m4, vl);
+            out_u16m4 = __riscv_vadd_vv_u16m4(out_u16m4, bias, vl);
+
+            /* Divide total by 4, narrow to 8-bit, and store. */
+            out_u8m2 = __riscv_vnsrl_wx_u8m2(out_u16m4, 2, vl);
+            __riscv_vse8_v_u8m2(outptr, out_u8m2, vl);
+
+            inptr0 += vl * 2;
+            inptr1 += vl * 2;
+            outptr += vl;
+        }
+    }
+}
diff --git a/simd/rvv/jcsample.h b/simd/rvv/jcsample.h
new file mode 100644
index 0000000..fb74915
--- /dev/null
+++ b/simd/rvv/jcsample.h
@@ -0,0 +1,59 @@
+/*
+ * Risc-V vector extension optimizations for libjpeg-turbo
+ *
+ * Copyright (C) 2023, Spacemit, Inc.  All Rights Reserved.
+ * Contributed by Liang Junzhao <junzhao.liang@spacemit.com>
+ *
+ * This software is provided 'as-is', without any express or implied
+ * warranty.  In no event will the authors be held liable for any damages
+ * arising from the use of this software.
+ *
+ * Permission is granted to anyone to use this software for any purpose,
+ * including commercial applications, and to alter it and redistribute it
+ * freely, subject to the following restrictions:
+ *
+ * 1. The origin of this software must not be misrepresented; you must not
+ *    claim that you wrote the original software. If you use this software
+ *    in a product, an acknowledgment in the product documentation would be
+ *    appreciated but is not required.
+ * 2. Altered source versions must be plainly marked as such, and must not be
+ *    misrepresented as being the original software.
+ * 3. This notice may not be removed or altered from any source distribution.
+ */
+
+/*
+ * Expand a component horizontally from width input_cols to width output_cols,
+ * by duplicating the rightmost samples.
+ */
+
+LOCAL(void)
+expand_right_edge_rvv(JSAMPARRAY image_data, int num_rows, JDIMENSION input_cols,
+                      JDIMENSION output_cols)
+{
+    register JSAMPROW ptr;
+    register JSAMPLE pixval;
+    register int count;
+    int row;
+    int numcols = (int)(output_cols - input_cols);
+    size_t vl;
+
+    vuint8m1_t pad;
+
+    if (numcols > 0)
+    {
+        for (row = 0; row < num_rows; row++)
+        {
+            ptr = image_data[row] + input_cols;
+            pixval = ptr[-1];
+            for (count = numcols; count > 0; count -= vl, ptr += vl)
+            {
+                /* Set vl for each iteration. */
+                vl = __riscv_vsetvl_e8m1(count);
+
+                /* Copy last value to padding */
+                pad = __riscv_vmv_v_x_u8m1(ptr[-1], vl);
+                __riscv_vse8_v_u8m1(ptr, pad, vl);
+            }
+        }
+    }
+}
diff --git a/simd/rvv/jdcolext-rvv.c b/simd/rvv/jdcolext-rvv.c
new file mode 100644
index 0000000..119d572
--- /dev/null
+++ b/simd/rvv/jdcolext-rvv.c
@@ -0,0 +1,170 @@
+/*
+ * Risc-V vector extension optimizations for libjpeg-turbo
+ *
+ * Copyright (C) 2023, Spacemit, Inc.  All Rights Reserved.
+ * Contributed by Liang Junzhao <junzhao.liang@spacemit.com>
+ *
+ * This software is provided 'as-is', without any express or implied
+ * warranty.  In no event will the authors be held liable for any damages
+ * arising from the use of this software.
+ *
+ * Permission is granted to anyone to use this software for any purpose,
+ * including commercial applications, and to alter it and redistribute it
+ * freely, subject to the following restrictions:
+ *
+ * 1. The origin of this software must not be misrepresented; you must not
+ *    claim that you wrote the original software. If you use this software
+ *    in a product, an acknowledgment in the product documentation would be
+ *    appreciated but is not required.
+ * 2. Altered source versions must be plainly marked as such, and must not be
+ *    misrepresented as being the original software.
+ * 3. This notice may not be removed or altered from any source distribution.
+ */
+
+/* This file is included by jccolor-rvv.c */
+
+/* YCbCr -> RGB conversion is defined by the following equations:
+ *    R = Y                        + 1.40200 * (Cr - 128)
+ *    G = Y - 0.34414 * (Cb - 128) - 0.71414 * (Cr - 128)
+ *    B = Y + 1.77200 * (Cb - 128)
+ *
+ * Scaled integer constants are used to avoid floating-point arithmetic:
+ *    0.3441467 = 11277 * 2^-15
+ *    0.7141418 = 23401 * 2^-15
+ *    1.4020386 = 22971 * 2^-14
+ *    1.7720337 = 29033 * 2^-14
+ * These constants are defined in jdcolor-neon.c.
+ *
+ * To ensure correct results, rounding is used when descaling.
+ */
+
+#define JPEG_INTERNALS
+
+
+void jsimd_ycc_rgb_convert_rvv(JDIMENSION output_width, JSAMPIMAGE input_buf,
+                               JDIMENSION input_row, JSAMPARRAY output_buf,
+                               int num_rows)
+{
+    int pixels_remaining;
+    size_t vl;
+    ptrdiff_t bstride;
+    JSAMPROW outptr, inptr0, inptr1, inptr2;
+
+    vbool4_t mask;
+    vuint16m4_t r_u16, g_u16, b_u16, y_u16, cb_u16, cr_u16;
+    vint16m4_t r_i16, g_i16, b_i16, y_i16, cb_i16, cr_i16, tmp_i16;
+    vint32m8_t tmp_i32;
+
+#if BITS_IN_JSAMPLE == 8
+    vuint8m2_t src;
+    vint8m2_t dest;
+#endif
+    /* Constant alpha value. */
+#if RGB_PIXELSIZE == 4
+    pixels_remaining = output_width;
+    vl = __riscv_vsetvl_e16m4(pixels_remaining);
+#if BITS_IN_JSAMPLE == 8
+    vuint8m2_t alpha_v = __riscv_vmv_v_x_u8m2(0xFF, vl);
+#else /* BITS_IN_JSAMPLE == 12 */
+    vuint16m4_t alpha_v = __riscv_vmv_v_x_u16m4(0xFF, vl);
+#endif
+#endif
+
+    for (; num_rows > 0; --num_rows)
+    {
+        inptr0 = input_buf[0][input_row];
+        inptr1 = input_buf[1][input_row];
+        inptr2 = input_buf[2][input_row++];
+        outptr = *output_buf++;
+
+        for (pixels_remaining = output_width; pixels_remaining > 0; pixels_remaining -= vl)
+        {
+            /* Set vl for each iteration. */
+            vl = __riscv_vsetvl_e16m4(pixels_remaining);
+            bstride = RGB_PIXELSIZE * sizeof(JSAMPLE);
+
+            /* Load R, G, B channels as vectors from inptr. */
+#if BITS_IN_JSAMPLE == 8
+            /* Extending to vuint16m4_t type for following multiply calculation. */
+            /* Can not load as signed which extends the highest bit during vwcvt
+               11111111 becomes 11111111 11111111 rather than 00000000 11111111  */
+            src = __riscv_vle8_v_u8m2(inptr0, vl);
+            y_u16 = __riscv_vwcvtu_x_x_v_u16m4(src, vl);
+            src = __riscv_vle8_v_u8m2(inptr1, vl);
+            cb_u16 = __riscv_vwcvtu_x_x_v_u16m4(src, vl);
+            src = __riscv_vle8_v_u8m2(inptr2, vl);
+            cr_u16 = __riscv_vwcvtu_x_x_v_u16m4(src, vl);
+#else /* BITS_IN_JSAMPLE == 12 */
+            y_u16 = __riscv_vle16_v_u16m4(inptr0, vl);
+            cb_u16 = __riscv_vle16_v_u16m4(inptr1, vl);
+            cr_u16 = __riscv_vle16_v_u16m4(inptr2, vl);
+#endif
+
+            y_i16 = __riscv_vreinterpret_v_u16m4_i16m4(y_u16);
+            cb_i16 = __riscv_vreinterpret_v_u16m4_i16m4(cb_u16);
+            cr_i16 = __riscv_vreinterpret_v_u16m4_i16m4(cr_u16);
+
+            cb_i16 = __riscv_vsub_vx_i16m4(cb_i16, CENTERJSAMPLE, vl);
+            cr_i16 = __riscv_vsub_vx_i16m4(cr_i16, CENTERJSAMPLE, vl);
+
+            /* Calculate R values */
+            tmp_i32 = __riscv_vwmul_vx_i32m8(cr_i16, F_1_402, vl);
+            tmp_i32 = __riscv_vadd_vx_i32m8(tmp_i32, ONE_SL_13, vl);
+            tmp_i16 = __riscv_vnsra_wx_i16m4(tmp_i32, 14, vl);
+            r_i16 = __riscv_vadd_vv_i16m4(y_i16, tmp_i16, vl);
+
+            CLIP(r_i16, i16m4);
+
+#if BITS_IN_JSAMPLE == 8
+            dest = __riscv_vncvt_x_x_w_i8m2(r_i16, vl);
+            __riscv_vsse8_v_i8m2(outptr + RGB_RED, bstride, dest, vl);
+#else /* BITS_IN_JSAMPLE == 12 */
+            __riscv_vsse16_v_i16m4(outptr + RGB_RED, bstride, r_i16, vl);
+#endif
+
+            /* Calculate G values */
+            tmp_i32 = __riscv_vwmul_vx_i32m8(cb_i16, -F_0_344, vl);
+            tmp_i32 = __riscv_vwmacc_vx_i32m8(tmp_i32, -F_0_714, cr_i16, vl);
+            tmp_i32 = __riscv_vadd_vx_i32m8(tmp_i32, ONE_SL_14, vl);
+            tmp_i16 = __riscv_vnsra_wx_i16m4(tmp_i32, 15, vl);
+            g_i16 = __riscv_vadd_vv_i16m4(y_i16, tmp_i16, vl);
+
+            CLIP(g_i16, i16m4);
+
+#if BITS_IN_JSAMPLE == 8
+            dest = __riscv_vncvt_x_x_w_i8m2(g_i16, vl);
+            __riscv_vsse8_v_i8m2(outptr + RGB_GREEN, bstride, dest, vl);
+#else /* BITS_IN_JSAMPLE == 12 */
+            __riscv_vsse16_v_i16m4(outptr + RGB_GREEN, bstride, g_i16, vl);
+#endif
+
+            /* Calculate B values */
+            tmp_i32 = __riscv_vwmul_vx_i32m8(cb_i16, F_1_772, vl);
+            tmp_i32 = __riscv_vadd_vx_i32m8(tmp_i32, ONE_SL_13, vl);
+            tmp_i16 = __riscv_vnsra_wx_i16m4(tmp_i32, 14, vl);
+            b_i16 = __riscv_vadd_vv_i16m4(y_i16, tmp_i16, vl);
+
+            CLIP(b_i16, i16m4);
+
+#if BITS_IN_JSAMPLE == 8
+            dest = __riscv_vncvt_x_x_w_i8m2(b_i16, vl);
+            __riscv_vsse8_v_i8m2(outptr + RGB_BLUE, bstride, dest, vl);
+#else /* BITS_IN_JSAMPLE == 12 */
+            __riscv_vsse16_v_i16m4(outptr + RGB_BLUE, bstride, b_i16, vl);
+#endif
+
+            /* Store alpha channel values. */
+#if RGB_PIXELSIZE == 4
+#if BITS_IN_JSAMPLE == 8
+            __riscv_vsse8_v_u8m2(outptr + RGB_ALPHA, bstride, alpha_v, vl);
+#else /* BITS_IN_JSAMPLE == 12 */
+            __riscv_vsse16_v_u16m4(outptr + RGB_ALPHA, bstride, alpha_v, vl);
+#endif
+#endif
+            outptr += vl * RGB_PIXELSIZE;
+            inptr0 += vl;
+            inptr1 += vl;
+            inptr2 += vl;
+        }
+    }
+}
\ No newline at end of file
diff --git a/simd/rvv/jdcolor-rvv.c b/simd/rvv/jdcolor-rvv.c
new file mode 100644
index 0000000..b3496bb
--- /dev/null
+++ b/simd/rvv/jdcolor-rvv.c
@@ -0,0 +1,122 @@
+/*
+ * Risc-V vector extension optimizations for libjpeg-turbo
+ *
+ * Copyright (C) 2023, Spacemit, Inc.  All Rights Reserved.
+ * Contributed by Liang Junzhao <junzhao.liang@spacemit.com>
+ *
+ * This software is provided 'as-is', without any express or implied
+ * warranty.  In no event will the authors be held liable for any damages
+ * arising from the use of this software.
+ *
+ * Permission is granted to anyone to use this software for any purpose,
+ * including commercial applications, and to alter it and redistribute it
+ * freely, subject to the following restrictions:
+ *
+ * 1. The origin of this software must not be misrepresented; you must not
+ *    claim that you wrote the original software. If you use this software
+ *    in a product, an acknowledgment in the product documentation would be
+ *    appreciated but is not required.
+ * 2. Altered source versions must be plainly marked as such, and must not be
+ *    misrepresented as being the original software.
+ * 3. This notice may not be removed or altered from any source distribution.
+ */
+
+/* YCbCr --> RGB CONVERSION */
+
+#define JPEG_INTERNALS
+#include "jsimd_rvv.h"
+
+/* YCbCr --> RGB conversion constants */
+#define F_0_344 11277 /* 0.3441467 = 11277 * 2^-15 */
+#define F_0_714 23401 /* 0.7141418 = 23401 * 2^-15 */
+#define F_1_402 22971 /* 1.4020386 = 22971 * 2^-14 */
+#define F_1_772 29033 /* 1.7720337 = 29033 * 2^-14 */
+
+#define ONE_SL_13 1 << 13
+#define ONE_SL_14 1 << 14
+
+#include "jdcolext-rvv.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_PIXELSIZE
+
+#define RGB_RED EXT_RGB_RED
+#define RGB_GREEN EXT_RGB_GREEN
+#define RGB_BLUE EXT_RGB_BLUE
+#define RGB_PIXELSIZE EXT_RGB_PIXELSIZE
+#define jsimd_ycc_rgb_convert_rvv jsimd_ycc_extrgb_convert_rvv
+#include "jdcolext-rvv.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_PIXELSIZE
+#undef jsimd_ycc_rgb_convert_rvv
+
+#define RGB_RED EXT_RGBX_RED
+#define RGB_GREEN EXT_RGBX_GREEN
+#define RGB_BLUE EXT_RGBX_BLUE
+#define RGB_ALPHA 3
+#define RGB_PIXELSIZE EXT_RGBX_PIXELSIZE
+#define jsimd_ycc_rgb_convert_rvv jsimd_ycc_extrgbx_convert_rvv
+#include "jdcolext-rvv.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_ALPHA
+#undef RGB_PIXELSIZE
+#undef jsimd_ycc_rgb_convert_rvv
+
+#define RGB_RED EXT_BGR_RED
+#define RGB_GREEN EXT_BGR_GREEN
+#define RGB_BLUE EXT_BGR_BLUE
+#define RGB_PIXELSIZE EXT_BGR_PIXELSIZE
+#define jsimd_ycc_rgb_convert_rvv jsimd_ycc_extbgr_convert_rvv
+#include "jdcolext-rvv.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_PIXELSIZE
+#undef jsimd_ycc_rgb_convert_rvv
+
+#define RGB_RED EXT_BGRX_RED
+#define RGB_GREEN EXT_BGRX_GREEN
+#define RGB_BLUE EXT_BGRX_BLUE
+#define RGB_ALPHA 3
+#define RGB_PIXELSIZE EXT_BGRX_PIXELSIZE
+#define jsimd_ycc_rgb_convert_rvv jsimd_ycc_extbgrx_convert_rvv
+#include "jdcolext-rvv.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_ALPHA
+#undef RGB_PIXELSIZE
+#undef jsimd_ycc_rgb_convert_rvv
+
+#define RGB_RED EXT_XBGR_RED
+#define RGB_GREEN EXT_XBGR_GREEN
+#define RGB_BLUE EXT_XBGR_BLUE
+#define RGB_ALPHA 0
+#define RGB_PIXELSIZE EXT_XBGR_PIXELSIZE
+#define jsimd_ycc_rgb_convert_rvv jsimd_ycc_extxbgr_convert_rvv
+#include "jdcolext-rvv.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_ALPHA
+#undef RGB_PIXELSIZE
+#undef jsimd_ycc_rgb_convert_rvv
+
+#define RGB_RED EXT_XRGB_RED
+#define RGB_GREEN EXT_XRGB_GREEN
+#define RGB_BLUE EXT_XRGB_BLUE
+#define RGB_ALPHA 0
+#define RGB_PIXELSIZE EXT_XRGB_PIXELSIZE
+#define jsimd_ycc_rgb_convert_rvv jsimd_ycc_extxrgb_convert_rvv
+#include "jdcolext-rvv.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_ALPHA
+#undef RGB_PIXELSIZE
+#undef jsimd_ycc_rgb_convert_rvv
diff --git a/simd/rvv/jdmerge-rvv.c b/simd/rvv/jdmerge-rvv.c
new file mode 100644
index 0000000..250bad4
--- /dev/null
+++ b/simd/rvv/jdmerge-rvv.c
@@ -0,0 +1,136 @@
+/*
+ * Risc-V vector extension optimizations for libjpeg-turbo
+ *
+ * Copyright (C) 2023, Spacemit, Inc.  All Rights Reserved.
+ * Contributed by Liang Junzhao <junzhao.liang@spacemit.com>
+ *
+ * This software is provided 'as-is', without any express or implied
+ * warranty.  In no event will the authors be held liable for any damages
+ * arising from the use of this software.
+ *
+ * Permission is granted to anyone to use this software for any purpose,
+ * including commercial applications, and to alter it and redistribute it
+ * freely, subject to the following restrictions:
+ *
+ * 1. The origin of this software must not be misrepresented; you must not
+ *    claim that you wrote the original software. If you use this software
+ *    in a product, an acknowledgment in the product documentation would be
+ *    appreciated but is not required.
+ * 2. Altered source versions must be plainly marked as such, and must not be
+ *    misrepresented as being the original software.
+ * 3. This notice may not be removed or altered from any source distribution.
+ */
+
+/* These routines combine simple (non-fancy, i.e. non-smooth) h2v1 or h2v2
+ * chroma upsampling and YCbCr -> RGB color conversion into a single function.
+ */
+
+#define JPEG_INTERNALS
+#include "jsimd_rvv.h"
+
+/* YCbCr --> RGB conversion constants */
+#define F_0_344 11277 /* 0.3441467 = 11277 * 2^-15 */
+#define F_0_714 23401 /* 0.7141418 = 23401 * 2^-15 */
+#define F_1_402 22971 /* 1.4020386 = 22971 * 2^-14 */
+#define F_1_772 29033 /* 1.7720337 = 29033 * 2^-14 */
+
+#define ONE_SL_13 1 << 13
+#define ONE_SL_14 1 << 14
+
+#include "jdmrgext-rvv.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_PIXELSIZE
+
+#define RGB_RED EXT_RGB_RED
+#define RGB_GREEN EXT_RGB_GREEN
+#define RGB_BLUE EXT_RGB_BLUE
+#define RGB_PIXELSIZE EXT_RGB_PIXELSIZE
+#define jsimd_h2v1_merged_upsample_rvv jsimd_h2v1_extrgb_merged_upsample_rvv
+#define jsimd_h2v2_merged_upsample_rvv jsimd_h2v2_extrgb_merged_upsample_rvv
+#include "jdmrgext-rvv.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_PIXELSIZE
+#undef jsimd_h2v1_merged_upsample_rvv
+#undef jsimd_h2v2_merged_upsample_rvv
+
+#define RGB_RED EXT_RGBX_RED
+#define RGB_GREEN EXT_RGBX_GREEN
+#define RGB_BLUE EXT_RGBX_BLUE
+#define RGB_ALPHA 3
+#define RGB_PIXELSIZE EXT_RGBX_PIXELSIZE
+#define jsimd_h2v1_merged_upsample_rvv jsimd_h2v1_extrgbx_merged_upsample_rvv
+#define jsimd_h2v2_merged_upsample_rvv jsimd_h2v2_extrgbx_merged_upsample_rvv
+#include "jdmrgext-rvv.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_ALPHA
+#undef RGB_PIXELSIZE
+#undef jsimd_h2v1_merged_upsample_rvv
+#undef jsimd_h2v2_merged_upsample_rvv
+
+#define RGB_RED EXT_BGR_RED
+#define RGB_GREEN EXT_BGR_GREEN
+#define RGB_BLUE EXT_BGR_BLUE
+#define RGB_PIXELSIZE EXT_BGR_PIXELSIZE
+#define jsimd_h2v1_merged_upsample_rvv jsimd_h2v1_extbgr_merged_upsample_rvv
+#define jsimd_h2v2_merged_upsample_rvv jsimd_h2v2_extbgr_merged_upsample_rvv
+#include "jdmrgext-rvv.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_PIXELSIZE
+#undef jsimd_h2v1_merged_upsample_rvv
+#undef jsimd_h2v2_merged_upsample_rvv
+
+#define RGB_RED EXT_BGRX_RED
+#define RGB_GREEN EXT_BGRX_GREEN
+#define RGB_BLUE EXT_BGRX_BLUE
+#define RGB_ALPHA 3
+#define RGB_PIXELSIZE EXT_BGRX_PIXELSIZE
+#define jsimd_h2v1_merged_upsample_rvv jsimd_h2v1_extbgrx_merged_upsample_rvv
+#define jsimd_h2v2_merged_upsample_rvv jsimd_h2v2_extbgrx_merged_upsample_rvv
+#include "jdmrgext-rvv.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_ALPHA
+#undef RGB_PIXELSIZE
+#undef jsimd_h2v1_merged_upsample_rvv
+#undef jsimd_h2v2_merged_upsample_rvv
+
+#define RGB_RED EXT_XBGR_RED
+#define RGB_GREEN EXT_XBGR_GREEN
+#define RGB_BLUE EXT_XBGR_BLUE
+#define RGB_ALPHA 0
+#define RGB_PIXELSIZE EXT_XBGR_PIXELSIZE
+#define jsimd_h2v1_merged_upsample_rvv jsimd_h2v1_extxbgr_merged_upsample_rvv
+#define jsimd_h2v2_merged_upsample_rvv jsimd_h2v2_extxbgr_merged_upsample_rvv
+#include "jdmrgext-rvv.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_ALPHA
+#undef RGB_PIXELSIZE
+#undef jsimd_h2v1_merged_upsample_rvv
+#undef jsimd_h2v2_merged_upsample_rvv
+
+#define RGB_RED EXT_XRGB_RED
+#define RGB_GREEN EXT_XRGB_GREEN
+#define RGB_BLUE EXT_XRGB_BLUE
+#define RGB_ALPHA 0
+#define RGB_PIXELSIZE EXT_XRGB_PIXELSIZE
+#define jsimd_h2v1_merged_upsample_rvv jsimd_h2v1_extxrgb_merged_upsample_rvv
+#define jsimd_h2v2_merged_upsample_rvv jsimd_h2v2_extxrgb_merged_upsample_rvv
+#include "jdmrgext-rvv.c"
+#undef RGB_RED
+#undef RGB_GREEN
+#undef RGB_BLUE
+#undef RGB_ALPHA
+#undef RGB_PIXELSIZE
+#undef jsimd_h2v1_merged_upsample_rvv
+#undef jsimd_h2v2_merged_upsample_rvv
diff --git a/simd/rvv/jdmrgext-rvv.c b/simd/rvv/jdmrgext-rvv.c
new file mode 100644
index 0000000..2eab756
--- /dev/null
+++ b/simd/rvv/jdmrgext-rvv.c
@@ -0,0 +1,235 @@
+/*
+ * Risc-V vector extension optimizations for libjpeg-turbo.
+ *
+ * Copyright (C) 2023, Spacemit, Inc.  All Rights Reserved.
+ * Contributed by Liang Junzhao <junzhao.liang@spacemit.com>
+ *
+ * This software is provided 'as-is', without any express or implied
+ * warranty.  In no event will the authors be held liable for any damages
+ * arising from the use of this software.
+ *
+ * Permission is granted to anyone to use this software for any purpose,
+ * including commercial applications, and to alter it and redistribute it
+ * freely, subject to the following restrictions:
+ *
+ * 1. The origin of this software must not be misrepresented; you must not
+ *    claim that you wrote the original software. If you use this software
+ *    in a product, an acknowledgment in the product documentation would be
+ *    appreciated but is not required.
+ * 2. Altered source versions must be plainly marked as such, and must not be
+ *    misrepresented as being the original software.
+ * 3. This notice may not be removed or altered from any source distribution.
+ */
+
+/* This file is included by jdmerge-rvv.c. */
+
+/* These routines combine simple (non-fancy, i.e. non-smooth) h2v1 or h2v2
+ * chroma upsampling and YCbCr -> RGB color conversion into a single function.
+ *
+ * As with the standalone functions, YCbCr -> RGB conversion is defined by the
+ * following equations:
+ *    R = Y                        + 1.40200 * (Cr - 128)
+ *    G = Y - 0.34414 * (Cb - 128) - 0.71414 * (Cr - 128)
+ *    B = Y + 1.77200 * (Cb - 128)
+ *
+ * Scaled integer constants are used to avoid floating-point arithmetic:
+ *    0.3441467 = 11277 * 2^-15
+ *    0.7141418 = 23401 * 2^-15
+ *    1.4020386 = 22971 * 2^-14
+ *    1.7720337 = 29033 * 2^-14
+ * These constants are defined in jdmerge-neon.c.
+ *
+ * To ensure correct results, rounding is used when descaling.
+ */
+
+/* Upsample and color convert for the case of 2:1 horizontal and 1:1 vertical.
+   Y0Y1CC -> RGB0 RGB1
+ */
+
+#define JPEG_INTERNALS
+
+
+void jsimd_h2v1_merged_upsample_rvv(JDIMENSION output_width,
+                                    JSAMPIMAGE input_buf,
+                                    JDIMENSION in_row_group_ctr,
+                                    JSAMPARRAY output_buf)
+{
+    int crcb_remaining;
+    int is_odd = output_width & 1;
+    size_t vl, vl_odd;
+    ptrdiff_t bstride;
+    JSAMPROW outptr;
+    JSAMPROW inptr0, inptr1, inptr2;
+
+    vbool8_t mask;
+    vuint16m2_t y0_u16, y1_u16, cb_u16, cr_u16;
+    vint16m2_t y0_i16, y1_i16, cb_i16, cr_i16;
+    vint16m2_t r_sub_y, g_sub_y, b_sub_y;
+    vint16m2_t r, g, b;
+    vint32m4_t tmp_i32;
+
+#if BITS_IN_JSAMPLE == 8
+    vuint8m1_t src;
+    vint8m1_t dest;
+#endif
+
+    /* Constant alpha value. */
+#if RGB_PIXELSIZE == 4
+    vl = __riscv_vsetvl_e16m2((output_width + 1) >> 1);
+#if BITS_IN_JSAMPLE == 8
+    vuint8m1_t alpha_v = __riscv_vmv_v_x_u8m1(0xFF, vl);
+#else /* BITS_IN_JSAMPLE == 12 */
+    vuint16m2_t alpha_v = __riscv_vmv_v_x_u16m2(0xFF, vl);
+#endif
+#endif
+
+    inptr0 = input_buf[0][in_row_group_ctr];
+    inptr1 = input_buf[1][in_row_group_ctr];
+    inptr2 = input_buf[2][in_row_group_ctr];
+    outptr = output_buf[0];
+
+    for (crcb_remaining = (output_width + 1) >> 1; crcb_remaining > 0; crcb_remaining -= vl)
+    {
+        /* Set vl for each iteration. */
+        vl = __riscv_vsetvl_e16m2(crcb_remaining);
+        vl_odd = (is_odd && (vl == crcb_remaining)) ? (vl - 1) : vl;
+        bstride = RGB_PIXELSIZE * sizeof(JSAMPLE);
+
+        /* Load R, G, B channels as vectors from inptr. */
+#if BITS_IN_JSAMPLE == 8
+        /* Extending to vuint16m4_t type for following multiply calculation. */
+        /* Y component values with even-numbered indices. */
+        src = __riscv_vlse8_v_u8m1(inptr0, 2 * sizeof(JSAMPLE), vl);
+        y0_u16 = __riscv_vwcvtu_x_x_v_u16m2(src, vl);
+        /* Y component values with odd-numbered indices. */
+        src = __riscv_vlse8_v_u8m1(inptr0 + 1, 2 * sizeof(JSAMPLE), vl_odd);
+        y1_u16 = __riscv_vwcvtu_x_x_v_u16m2(src, vl_odd);
+
+        src = __riscv_vle8_v_u8m1(inptr1, vl);
+        cb_u16 = __riscv_vwcvtu_x_x_v_u16m2(src, vl);
+        src = __riscv_vle8_v_u8m1(inptr2, vl);
+        cr_u16 = __riscv_vwcvtu_x_x_v_u16m2(src, vl);
+#else /* BITS_IN_JSAMPLE == 12 */
+        y0_u16 = __riscv_vlse16_v_u16m2(inptr0, 2 * sizeof(JSAMPLE), vl);
+        y1_u16 = __riscv_vlse16_v_u16m2(inptr0 + 1, 2 * sizeof(JSAMPLE), vl_odd);
+        cb_u16 = __riscv_vle16_v_u16m2(inptr1, vl);
+        cr_u16 = __riscv_vle16_v_u16m2(inptr2, vl);
+#endif
+
+        y0_i16 = __riscv_vreinterpret_v_u16m2_i16m2(y0_u16);
+        y1_i16 = __riscv_vreinterpret_v_u16m2_i16m2(y1_u16);
+        cb_i16 = __riscv_vreinterpret_v_u16m2_i16m2(cb_u16);
+        cr_i16 = __riscv_vreinterpret_v_u16m2_i16m2(cr_u16);
+
+        cb_i16 = __riscv_vsub_vx_i16m2(cb_i16, CENTERJSAMPLE, vl);
+        cr_i16 = __riscv_vsub_vx_i16m2(cr_i16, CENTERJSAMPLE, vl);
+
+        /* Calculate R-Y values */
+        tmp_i32 = __riscv_vwmul_vx_i32m4(cr_i16, F_1_402, vl);
+        tmp_i32 = __riscv_vadd_vx_i32m4(tmp_i32, ONE_SL_13, vl);
+        r_sub_y = __riscv_vnsra_wx_i16m2(tmp_i32, 14, vl);
+
+        /* Calculate G-Y values */
+        tmp_i32 = __riscv_vwmul_vx_i32m4(cb_i16, -F_0_344, vl);
+        tmp_i32 = __riscv_vwmacc_vx_i32m4(tmp_i32, -F_0_714, cr_i16, vl);
+        tmp_i32 = __riscv_vadd_vx_i32m4(tmp_i32, ONE_SL_14, vl);
+        g_sub_y = __riscv_vnsra_wx_i16m2(tmp_i32, 15, vl);
+
+        /* Calculate B-Y values */
+        tmp_i32 = __riscv_vwmul_vx_i32m4(cb_i16, F_1_772, vl);
+        tmp_i32 = __riscv_vadd_vx_i32m4(tmp_i32, ONE_SL_13, vl);
+        b_sub_y = __riscv_vnsra_wx_i16m2(tmp_i32, 14, vl);
+
+        /* Compute R, G, B values with even-numbered indices. */
+        r = __riscv_vadd_vv_i16m2(r_sub_y, y0_i16, vl);
+        CLIP(r, i16m2);
+
+        g = __riscv_vadd_vv_i16m2(g_sub_y, y0_i16, vl);
+        CLIP(g, i16m2);
+
+        b = __riscv_vadd_vv_i16m2(b_sub_y, y0_i16, vl);
+        CLIP(b, i16m2);
+
+        /* Narrow to 8-bit and store to memory. */
+#if BITS_IN_JSAMPLE == 8
+        dest = __riscv_vncvt_x_x_w_i8m1(r, vl);
+        __riscv_vsse8_v_i8m1(outptr + RGB_RED, 2 * bstride, dest, vl);
+        dest = __riscv_vncvt_x_x_w_i8m1(g, vl);
+        __riscv_vsse8_v_i8m1(outptr + RGB_GREEN, 2 * bstride, dest, vl);
+        dest = __riscv_vncvt_x_x_w_i8m1(b, vl);
+        __riscv_vsse8_v_i8m1(outptr + RGB_BLUE, 2 * bstride, dest, vl);
+#else /* BITS_IN_JSAMPLE == 12 */
+        __riscv_vsse16_v_u16m2(outptr + RGB_RED, 2 * bstride, r, vl);
+        __riscv_vsse16_v_u16m2(outptr + RGB_GREEN, 2 * bstride, g, vl);
+        __riscv_vsse16_v_u16m2(outptr + RGB_BLUE, 2 * bstride, b, vl);
+#endif
+
+        /* Deal with alpha channel. */
+#if RGB_PIXELSIZE == 4
+#if BITS_IN_JSAMPLE == 8
+        __riscv_vsse8_v_u8m1(outptr + RGB_ALPHA, 2 * bstride, alpha_v, vl);
+#else /* BITS_IN_JSAMPLE == 12 */
+        __riscv_vsse16_v_u16m2(outptr + RGB_ALPHA, 2 * bstride, alpha_v, vl);
+#endif
+#endif
+
+        /* Compute R, G, B values with odd-numbered indices. */
+        r = __riscv_vadd_vv_i16m2(r_sub_y, y1_i16, vl_odd);
+        CLIP(r, i16m2);
+
+        g = __riscv_vadd_vv_i16m2(g_sub_y, y1_i16, vl_odd);
+        CLIP(g, i16m2);
+
+        b = __riscv_vadd_vv_i16m2(b_sub_y, y1_i16, vl_odd);
+        CLIP(b, i16m2);
+
+        /* Narrow to 8-bit and store to memory. */
+#if BITS_IN_JSAMPLE == 8
+        dest = __riscv_vncvt_x_x_w_i8m1(r, vl_odd);
+        __riscv_vsse8_v_i8m1(outptr + RGB_PIXELSIZE + RGB_RED, 2 * bstride, dest, vl_odd);
+        dest = __riscv_vncvt_x_x_w_i8m1(g, vl_odd);
+        __riscv_vsse8_v_i8m1(outptr + RGB_PIXELSIZE + RGB_GREEN, 2 * bstride, dest, vl_odd);
+        dest = __riscv_vncvt_x_x_w_i8m1(b, vl_odd);
+        __riscv_vsse8_v_i8m1(outptr + RGB_PIXELSIZE + RGB_BLUE, 2 * bstride, dest, vl_odd);
+#else /* BITS_IN_JSAMPLE == 12 */
+        __riscv_vsse16_v_i16m2(outptr + RGB_PIXELSIZE + RGB_RED, 2 * bstride, r, vl_odd);
+        __riscv_vsse16_v_i16m2(outptr + RGB_PIXELSIZE + RGB_GREEN, 2 * bstride, g, vl_odd);
+        __riscv_vsse16_v_i16m2(outptr + RGB_PIXELSIZE + RGB_BLUE, 2 * bstride, b, vl_odd);
+#endif
+        /* Deal with alpha channel. */
+#if RGB_PIXELSIZE == 4
+#if BITS_IN_JSAMPLE == 8
+        __riscv_vsse8_v_u8m1(outptr + RGB_PIXELSIZE + RGB_ALPHA, 2 * bstride, alpha_v, vl_odd);
+#else /* BITS_IN_JSAMPLE == 12 */
+        __riscv_vsse16_v_u16m2(outptr + RGB_PIXELSIZE + RGB_ALPHA, 2 * bstride, alpha_v, vl_odd);
+#endif
+#endif
+        inptr0 += 2 * vl;
+        inptr1 += vl;
+        inptr2 += vl;
+        outptr += 2 * vl * RGB_PIXELSIZE;
+    }
+}
+
+void jsimd_h2v2_merged_upsample_rvv(JDIMENSION output_width,
+                                    JSAMPIMAGE input_buf,
+                                    JDIMENSION in_row_group_ctr,
+                                    JSAMPARRAY output_buf)
+{
+    JSAMPROW inptr, outptr;
+
+    inptr = input_buf[0][in_row_group_ctr];
+    outptr = output_buf[0];
+
+    input_buf[0][in_row_group_ctr] = input_buf[0][in_row_group_ctr * 2];
+    jsimd_h2v1_merged_upsample_rvv(output_width, input_buf, in_row_group_ctr,
+                                   output_buf);
+
+    input_buf[0][in_row_group_ctr] = input_buf[0][in_row_group_ctr * 2 + 1];
+    output_buf[0] = output_buf[1];
+    jsimd_h2v1_merged_upsample_rvv(output_width, input_buf, in_row_group_ctr,
+                                   output_buf);
+
+    input_buf[0][in_row_group_ctr] = inptr;
+    output_buf[0] = outptr;
+}
\ No newline at end of file
diff --git a/simd/rvv/jdsample-rvv.c b/simd/rvv/jdsample-rvv.c
new file mode 100644
index 0000000..6cbc6d5
--- /dev/null
+++ b/simd/rvv/jdsample-rvv.c
@@ -0,0 +1,460 @@
+/*
+ * Risc-V vector extension optimizations for libjpeg-turbo
+ *
+ * Copyright (C) 2023, Spacemit, Inc.  All Rights Reserved.
+ * Contributed by Liang Junzhao <junzhao.liang@spacemit.com>
+ *
+ * This software is provided 'as-is', without any express or implied
+ * warranty.  In no event will the authors be held liable for any damages
+ * arising from the use of this software.
+ *
+ * Permission is granted to anyone to use this software for any purpose,
+ * including commercial applications, and to alter it and redistribute it
+ * freely, subject to the following restrictions:
+ *
+ * 1. The origin of this software must not be misrepresented; you must not
+ *    claim that you wrote the original software. If you use this software
+ *    in a product, an acknowledgment in the product documentation would be
+ *    appreciated but is not required.
+ * 2. Altered source versions must be plainly vl_accued as such, and must not be
+ *    misrepresented as being the original software.
+ * 3. This notice may not be removed or altered from any source distribution.
+ */
+
+/* CHROMA UPSAMPLING */
+
+#define JPEG_INTERNALS
+#include "jsimd_rvv.h"
+
+/* The diagram below shows a row of samples produced by h2v1 downsampling.
+ *
+ *                s0        s1        s2
+ *            +---------+---------+---------+
+ *            |         |         |         |
+ *            | p0   p1 | p2   p3 | p4   p5 |
+ *            |         |         |         |
+ *            +---------+---------+---------+
+ *
+ * Samples s0-s2 were created by averaging the original pixel component values
+ * centered at positions p0-p5 above.  To approximate those original pixel
+ * component values, we proportionally blend the adjacent samples in each row.
+ *
+ * An upsampled pixel component value is computed by blending the sample
+ * containing the pixel center with the nearest neighboring sample, in the
+ * ratio 3:1.  For example:
+ *     p1(upsampled) = 3/4 * s0 + 1/4 * s1
+ *     p2(upsampled) = 3/4 * s1 + 1/4 * s0
+ * When computing the first and last pixel component values in the row, there
+ * is no adjacent sample to blend, so:
+ *     p0(upsampled) = s0
+ *     p5(upsampled) = s2
+ */
+
+void jsimd_h2v1_fancy_upsample_rvv(int max_v_samp_factor,
+                                   JDIMENSION downsampled_width,
+                                   JSAMPARRAY input_data,
+                                   JSAMPARRAY *output_data_ptr)
+{
+    int s_row, s_remaining;
+    size_t vl;
+    JSAMPARRAY output_data = *output_data_ptr;
+    JSAMPROW inptr, outptr;
+
+    vuint8m4_t s0, s1, p1_u8, p2_u8;
+    vuint16m8_t p1_u16, p2_u16;
+
+    for (s_row = 0; s_row < max_v_samp_factor;)
+    {
+        inptr = input_data[s_row];
+        outptr = output_data[s_row++];
+
+        /* First pixel component value in this row of the original image */
+        *outptr++ = (JSAMPLE)GETJSAMPLE(*inptr);
+
+        for (s_remaining = downsampled_width - 1; s_remaining > 0; s_remaining -= vl)
+        {
+            /* Set vl for each iteration. */
+            vl = __riscv_vsetvl_e16m8(s_remaining);
+
+            /* Load smaples and samples with offset 1. */
+            s0 = __riscv_vle8_v_u8m4(inptr, vl);
+            s1 = __riscv_vle8_v_u8m4(inptr + 1, vl);
+
+            /* p1(upsampled) = (3 * s0 + s1 + 2) / 4 */
+            p1_u16 = __riscv_vwaddu_vx_u16m8(s1, 2, vl); /* Add bias */
+            p1_u16 = __riscv_vwmaccu_vx_u16m8(p1_u16, 3, s0, vl);
+
+            /* p2(upsampled) = (3 * s1 + s0 + 1) / 4 */
+            p2_u16 = __riscv_vwaddu_vx_u16m8(s0, 1, vl); /* Add bias */
+            p2_u16 = __riscv_vwmaccu_vx_u16m8(p2_u16, 3, s1, vl);
+
+            /* Right-shift by 2 (divide by 4) and narrow to 8-bit. */
+            p1_u8 = __riscv_vnsrl_wx_u8m4(p1_u16, 2, vl);
+            p2_u8 = __riscv_vnsrl_wx_u8m4(p2_u16, 2, vl);
+
+            /* Strided store to memory. */
+            __riscv_vsse8_v_u8m4(outptr, 2 * sizeof(JSAMPLE), p1_u8, vl);
+            __riscv_vsse8_v_u8m4(outptr + 1, 2 * sizeof(JSAMPLE), p2_u8, vl);
+
+            inptr += vl;
+            outptr += 2 * vl;
+        }
+
+        /* Last pixel component value in this row of the original image */
+        *outptr = (JSAMPLE)GETJSAMPLE(*inptr);
+    }
+}
+
+/* The diagram below shows an array of samples produced by h2v2 downsampling.
+ *
+ *                     s0        s1        s2                   
+ *                 +---------+---------+---------+              
+ *                 | p0   p1 | p2   p3 | p4   p5 |              
+ *      top        |         |         |         |              
+ *                 | p6   p7 | p8   p9 | p10  p11|               s0        s1
+ *                 +---------+---------+---------+          +---------+---------+
+ *                 | p12  p13| p14  p15| p16  p17|          |    | pa | pb |    |
+ *      mid        |         |         |         |          | - - - - | - - - - |
+ *                 | p18  p19| p20  p21| p22  p23|          |    | px | py |    |
+ *                 +---------+---------+---------+          +---------+---------+
+ *                 | p24  p25| p26  p27| p28  p29|
+ *      bot        |         |         |         |
+ *                 | p30  p31| p32  p33| p34  p35|
+ *                 +---------+---------+---------+
+ *
+ * Samples s0A-s2C were created by averaging the original pixel component
+ * values centered at positions p0-p35 above.  To approximate one of those
+ * original pixel component values, we proportionally blend the sample
+ * containing the pixel center with the nearest neighboring samples in each
+ * row, column, and diagonal.
+ *
+ * An upsampled pixel component value is computed by first blending the sample
+ * containing the pixel center with the nearest neighboring samples in the
+ * same column, in the ratio 3:1, and then blending each column sum with the
+ * nearest neighboring column sum, in the ratio 3:1.  For example:
+ *     p14(upsampled) = 3/4 * (3/4 * s1B + 1/4 * s0B) +
+ *                      1/4 * (3/4 * s1A + 1/4 * s0A)
+ *                    = 9/16 * s1B + 3/16 * s1A + 3/16 * s0B + 1/16 * s0A
+ * When computing the first and last pixel component values in the row, there
+ * is no horizontally adjacent sample to blend, so:
+ *     p12(upsampled) = 3/4 * s0B + 1/4 * s0A
+ *     p23(upsampled) = 3/4 * s2B + 1/4 * s2C
+ * When computing the first and last pixel component values in the column,
+ * there is no vertically adjacent sample to blend, so:
+ *     p2(upsampled) = 3/4 * s1A + 1/4 * s0A
+ *     p33(upsampled) = 3/4 * s1C + 1/4 * s2C
+ * When computing the corner pixel component values, there is no adjacent
+ * sample to blend, so:
+ *     p0(upsampled) = s0A
+ *     p35(upsampled) = s2C
+ *
+ */
+
+void jsimd_h2v2_fancy_upsample_rvv(int max_v_samp_factor,
+                                   JDIMENSION downsampled_width,
+                                   JSAMPARRAY input_data,
+                                   JSAMPARRAY *output_data_ptr)
+{   
+    int inrow, outrow, s_remaining;
+    int mid, p[2];
+    size_t vl;
+    JSAMPARRAY output_data = *output_data_ptr;
+    JSAMPROW inptr_top, inptr_mid, inptr_bot, outptr0, outptr1;
+
+    vuint8m4_t s0_top_u8, s0_mid_u8, s0_bot_u8, s1_top_u8, s1_mid_u8, s1_bot_u8;
+    vuint8m4_t pa_u8, pb_u8, px_u8, py_u8;
+    vuint16m8_t s0_3s1_mid_x3, s1_3s0_mid_x3, s0_3s1_top, s1_3s0_top, s0_3s1_bot, s1_3s0_bot;
+    vuint16m8_t pa_u16, pb_u16, px_u16, py_u16;
+
+    for (inrow = 0, outrow = 0; outrow < max_v_samp_factor; inrow++)
+    {
+        inptr_top = input_data[inrow - 1];
+        inptr_mid = input_data[inrow];
+        inptr_bot = input_data[inrow + 1];
+        outptr0 = output_data[outrow++];
+        outptr1 = output_data[outrow++];
+
+        /* First pixel component value in this row of the original image */
+        mid = GETJSAMPLE(*inptr_mid) * 3;
+        p[0] = mid + GETJSAMPLE(*inptr_top);
+        p[1] = mid + GETJSAMPLE(*inptr_bot);
+        *outptr0++ = (JSAMPLE)((p[0] + 2) >> 2);
+        *outptr1++ = (JSAMPLE)((p[1] + 2) >> 2);
+
+        for (s_remaining = downsampled_width - 1; s_remaining > 0; s_remaining -= vl)
+        {
+            vl = __riscv_vsetvl_e16m8(s_remaining);
+
+            /* Load smaples and samples with offset 1. */
+            s0_top_u8 = __riscv_vle8_v_u8m4(inptr_top, vl);
+            s1_top_u8 = __riscv_vle8_v_u8m4(inptr_top + 1, vl);
+            s0_mid_u8 = __riscv_vle8_v_u8m4(inptr_mid, vl);
+            s1_mid_u8 = __riscv_vle8_v_u8m4(inptr_mid + 1, vl);
+            s0_bot_u8 = __riscv_vle8_v_u8m4(inptr_bot, vl);
+            s1_bot_u8 = __riscv_vle8_v_u8m4(inptr_bot + 1, vl);
+
+            /* Compute pixels for output in row 0. */
+            /* Step 1: Blend samples vertically in columns s0 and s1. */
+            /* 3 * s0A + s1A (row -1) */
+            s1_3s0_top = __riscv_vwmulu_vx_u16m8(s0_top_u8, 3, vl);
+            s1_3s0_top = __riscv_vwaddu_wv_u16m8(s1_3s0_top, s1_top_u8, vl);
+            /* 3 * s1A + s0A (row -1) */
+            s0_3s1_top = __riscv_vwmulu_vx_u16m8(s1_top_u8, 3, vl);
+            s0_3s1_top = __riscv_vwaddu_wv_u16m8(s0_3s1_top, s0_top_u8, vl);
+            /* 3 * (3 * s0B + s1B) (row 0) */
+            s1_3s0_mid_x3 = __riscv_vwmulu_vx_u16m8(s0_mid_u8, 9, vl);
+            s1_3s0_mid_x3 = __riscv_vwmaccu_vx_u16m8(s1_3s0_mid_x3, 3, s1_mid_u8, vl);
+            s1_3s0_mid_x3 = __riscv_vadd_vx_u16m8(s1_3s0_mid_x3, 7, vl);          /* Add bias to pa px */
+
+            /* 3 * (3 * s1B + s0B) (row 0) */
+            s0_3s1_mid_x3 = __riscv_vwmulu_vx_u16m8(s1_mid_u8, 9, vl);
+            s0_3s1_mid_x3 = __riscv_vwmaccu_vx_u16m8(s0_3s1_mid_x3, 3, s0_mid_u8, vl);
+            s0_3s1_mid_x3 = __riscv_vadd_vx_u16m8(s0_3s1_mid_x3, 8, vl);          /* Add bias to pb py */
+
+            /* Step 2: Blend the already-blended columns. */
+            /* p13: (3 * (3 * s0B + s1B) + (3 * s0A + s1A) + 7) / 16 */
+            pa_u16 = __riscv_vadd_vv_u16m8(s1_3s0_mid_x3, s1_3s0_top, vl);
+            /* p14: (3 * (3 * s1B + s0B) + (3 * s1A + s0A) + 8) / 16 */
+            pb_u16 = __riscv_vadd_vv_u16m8(s0_3s1_mid_x3, s0_3s1_top, vl);
+
+            /* Right-shift by 4 (divide by 16), narrow to 8-bit, and combine. */
+            pa_u8 = __riscv_vnsrl_wx_u8m4(pa_u16, 4, vl);
+            pb_u8 = __riscv_vnsrl_wx_u8m4(pb_u16, 4, vl);
+
+            /* Strided store to memory. */
+            __riscv_vsse8_v_u8m4(outptr0, 2 * sizeof(JSAMPLE), pa_u8, vl);
+            __riscv_vsse8_v_u8m4(outptr0 + 1, 2 * sizeof(JSAMPLE), pb_u8, vl);
+
+            /* Compute pixels for output in row 1. */
+            /* Step 1: Blend samples vertically in columns s0 and s1. */
+            /* 3 * s0C + s1C (row 1) */
+            s1_3s0_bot = __riscv_vwmulu_vx_u16m8(s0_bot_u8, 3, vl);
+            s1_3s0_bot = __riscv_vwaddu_wv_u16m8(s1_3s0_bot, s1_bot_u8, vl);
+            /* 3 * s1C + s0C (row 1) */
+            s0_3s1_bot = __riscv_vwmulu_vx_u16m8(s1_bot_u8, 3, vl);
+            s0_3s1_bot = __riscv_vwaddu_wv_u16m8(s0_3s1_bot, s0_bot_u8, vl);
+
+            /* Step 2: Blend the already-blended columns. */
+            /* p19: (3 * (3 * s0B + s1B) + (3 * s0C + s1C) + 7) / 16 */
+            px_u16 = __riscv_vadd_vv_u16m8(s1_3s0_mid_x3, s1_3s0_bot, vl);
+            /* p20: (3 * (3 * s1B + s0B) + (3 * s1C + s0C) + 8) / 16 */
+            py_u16 = __riscv_vadd_vv_u16m8(s0_3s1_mid_x3, s0_3s1_bot, vl);
+
+            /* Right-shift by 4 (divide by 16), narrow to 8-bit, and combine. */
+            px_u8 = __riscv_vnsrl_wx_u8m4(px_u16, 4, vl);
+            py_u8 = __riscv_vnsrl_wx_u8m4(py_u16, 4, vl);
+
+            /* Strided store to memory. */
+            __riscv_vsse8_v_u8m4(outptr1, 2 * sizeof(JSAMPLE), px_u8, vl);
+            __riscv_vsse8_v_u8m4(outptr1 + 1, 2 * sizeof(JSAMPLE), py_u8, vl);
+
+            inptr_top += vl;
+            inptr_mid += vl;
+            inptr_bot += vl;
+            outptr0 += 2 * vl;
+            outptr1 += 2 * vl;
+        }
+
+        mid = GETJSAMPLE(*inptr_mid) * 3;
+        p[0] = mid + GETJSAMPLE(*inptr_top);
+        p[1] = mid + GETJSAMPLE(*inptr_bot);
+        *outptr0++ = (JSAMPLE)((p[0] + 1) >> 2);
+        *outptr1++ = (JSAMPLE)((p[1] + 1) >> 2);
+    }
+}
+
+/* The diagram below shows a column of samples produced by h1v2 downsampling
+ * (or by losslessly rotating or transposing an h2v1-downsampled image.)
+ *
+ *            +---------+
+ *            |   p0    |
+ *     sA     |         |
+ *            |   p1    |
+ *            +---------+
+ *            |   p2    |
+ *     sB     |         |
+ *            |   p3    |
+ *            +---------+
+ *            |   p4    |
+ *     sC     |         |
+ *            |   p5    |
+ *            +---------+
+ *
+ * Samples sA-sC were created by averaging the original pixel component values
+ * centered at positions p0-p5 above.  To approximate those original pixel
+ * component values, we proportionally blend the adjacent samples in each
+ * column.
+ *
+ * An upsampled pixel component value is computed by blending the sample
+ * containing the pixel center with the nearest neighboring sample, in the
+ * ratio 3:1.  For example:
+ *     p1(upsampled) = 3/4 * sA + 1/4 * sB
+ *     p2(upsampled) = 3/4 * sB + 1/4 * sA
+ * When computing the first and last pixel component values in the column,
+ * there is no adjacent sample to blend, so:
+ *     p0(upsampled) = sA
+ *     p5(upsampled) = sC
+ */
+
+void jsimd_h1v2_fancy_upsample_rvv(int max_v_samp_factor,
+                                   JDIMENSION downsampled_width,
+                                   JSAMPARRAY input_data,
+                                   JSAMPARRAY *output_data_ptr)
+{
+    int s_row, p_row, s_remaining;
+    size_t vl;
+    JSAMPARRAY output_data = *output_data_ptr;
+    JSAMPROW inptr_top, inptr_mid, inptr_bot, outptr_top, outptr_bot;
+
+    vuint8m4_t sA_u8, sB_u8, sC_u8, p2_u8, p3_u8;
+    vuint16m8_t p2_u16, p3_u16;
+
+    for (s_row = 0, p_row = 0; p_row < max_v_samp_factor; ++s_row)
+    {
+        inptr_top = input_data[s_row - 1];
+        inptr_mid = input_data[s_row];
+        inptr_bot = input_data[s_row + 1];
+
+        outptr_top = output_data[p_row++];
+        outptr_bot = output_data[p_row++];
+
+        for (s_remaining = downsampled_width; s_remaining > 0; s_remaining -= vl)
+        {
+            /* Set vl for each iteration. */
+            vl = __riscv_vsetvl_e16m8(s_remaining);
+
+            sA_u8 = __riscv_vle8_v_u8m4(inptr_top, vl);
+            sB_u8 = __riscv_vle8_v_u8m4(inptr_mid, vl);
+            sC_u8 = __riscv_vle8_v_u8m4(inptr_bot, vl);
+
+            /* p2(upsampled) = (3 * sB + sA + 1) / 4 */
+            p2_u16 = __riscv_vwaddu_vx_u16m8(sA_u8, 1, vl); /* Add bias */
+            p2_u16 = __riscv_vwmaccu_vx_u16m8(p2_u16, 3, sB_u8, vl);
+
+            p2_u8 = __riscv_vnsrl_wx_u8m4(p2_u16, 2, vl);
+
+            /* p3(upsampled) = (3 * sB + sC + 2) / 4 */
+            p3_u16 = __riscv_vwaddu_vx_u16m8(sC_u8, 2, vl); /* Add bias */
+            p3_u16 = __riscv_vwmaccu_vx_u16m8(p3_u16, 3, sB_u8, vl);
+        
+            p3_u8 = __riscv_vnsrl_wx_u8m4(p3_u16, 2, vl);
+
+            /* Strided store to memory. */
+            __riscv_vse8_v_u8m4(outptr_top, p2_u8, vl);
+            __riscv_vse8_v_u8m4(outptr_bot, p3_u8, vl);
+
+            inptr_top += vl;
+            inptr_mid += vl;
+            inptr_bot += vl;
+            outptr_top += vl;
+            outptr_bot += vl;
+        }
+    }
+}
+
+/* The diagram below shows a row of samples produced by h2v1 downsampling.
+ *
+ *                s0        s1
+ *            +---------+---------+
+ *            |         |         |
+ *            | p0   p1 | p2   p3 |
+ *            |         |         |
+ *            +---------+---------+
+ *
+ * Samples s0 and s1 were created by averaging the original pixel component
+ * values centered at positions p0-p3 above.  To approximate those original
+ * pixel component values, we duplicate the samples horizontally:
+ *     p0(upsampled) = p1(upsampled) = s0
+ *     p2(upsampled) = p3(upsampled) = s1
+ */
+
+void jsimd_h2v1_upsample_rvv(int max_v_samp_factor,
+                             JDIMENSION output_width,
+                             JSAMPARRAY input_data,
+                             JSAMPARRAY *output_data_ptr)
+{
+    int s_row, cols_remaining;
+    size_t vl;
+    JSAMPARRAY output_data = *output_data_ptr;
+    JSAMPROW inptr, outptr;
+
+    vuint8m8_t samples;
+
+    for (s_row = 0; s_row < max_v_samp_factor;)
+    {
+        inptr = input_data[s_row];
+        outptr = output_data[s_row++];
+
+        for (cols_remaining = output_width; cols_remaining > 0; cols_remaining -= 2 * vl)
+        {
+            vl = __riscv_vsetvl_e8m8((cols_remaining + 1) / 2);
+
+            samples = __riscv_vle8_v_u8m8(inptr, vl);
+
+            __riscv_vsse8_v_u8m8(outptr, 2 * sizeof(JSAMPLE), samples, vl);
+            __riscv_vsse8_v_u8m8(outptr + 1, 2 * sizeof(JSAMPLE), samples, vl);
+
+            inptr += vl;
+            outptr += 2 * vl;
+        }
+    }
+}
+
+/* The diagram below shows an array of samples produced by h2v2 downsampling.
+ *
+ *                s0        s1
+ *            +---------+---------+
+ *            | p0   p1 | p2   p3 |
+ *       sA   |         |         |
+ *            | p4   p5 | p6   p7 |
+ *            +---------+---------+
+ *            | p8   p9 | p10  p11|
+ *       sB   |         |         |
+ *            | p12  p13| p14  p15|
+ *            +---------+---------+
+ *
+ * Samples s0A-s1B were created by averaging the original pixel component
+ * values centered at positions p0-p15 above.  To approximate those original
+ * pixel component values, we duplicate the samples both horizontally and
+ * vertically:
+ *     p0(upsampled) = p1(upsampled) = p4(upsampled) = p5(upsampled) = s0A
+ *     p2(upsampled) = p3(upsampled) = p6(upsampled) = p7(upsampled) = s1A
+ *     p8(upsampled) = p9(upsampled) = p12(upsampled) = p13(upsampled) = s0B
+ *     p10(upsampled) = p11(upsampled) = p14(upsampled) = p15(upsampled) = s1B
+ */
+
+void jsimd_h2v2_upsample_rvv(int max_v_samp_factor,
+                             JDIMENSION output_width,
+                             JSAMPARRAY input_data,
+                             JSAMPARRAY *output_data_ptr)
+{
+    int s_row, p_row, cols_remaining;
+    size_t vl;
+    JSAMPARRAY output_data = *output_data_ptr;
+    JSAMPROW inptr, outptr_top, outptr_bot;
+
+    vuint8m8_t samples;
+
+    for (s_row = 0, p_row = 0; p_row < max_v_samp_factor;)
+    {
+        inptr = input_data[s_row++];
+        outptr_top = output_data[p_row++];
+        outptr_bot = output_data[p_row++];
+
+        for (cols_remaining = output_width; cols_remaining > 0; cols_remaining -= 2 * vl)
+        {
+            vl = __riscv_vsetvl_e8m8((cols_remaining + 1) / 2);
+
+            samples = __riscv_vle8_v_u8m8(inptr, vl);
+
+            __riscv_vsse8_v_u8m8(outptr_top, 2 * sizeof(JSAMPLE), samples, vl);
+            __riscv_vsse8_v_u8m8(outptr_top + 1, 2 * sizeof(JSAMPLE), samples, vl);
+            __riscv_vsse8_v_u8m8(outptr_bot, 2 * sizeof(JSAMPLE), samples, vl);
+            __riscv_vsse8_v_u8m8(outptr_bot + 1, 2 * sizeof(JSAMPLE), samples, vl);
+
+            inptr += vl;
+            outptr_top += 2 * vl;
+            outptr_bot += 2 * vl;
+        }
+    }
+}
diff --git a/simd/rvv/jfdctfst-rvv.c b/simd/rvv/jfdctfst-rvv.c
new file mode 100644
index 0000000..88fd5bd
--- /dev/null
+++ b/simd/rvv/jfdctfst-rvv.c
@@ -0,0 +1,155 @@
+/*
+ * jfdctfst-rvv.c - fast integer FDCT
+ *
+ * Copyright (C) 2023, Spacemit, Inc.  All Rights Reserved.
+ * Contributed by Liang Junzhao <junzhao.liang@spacemit.com>
+ *
+ * This software is provided 'as-is', without any express or implied
+ * warranty.  In no event will the authors be held liable for any damages
+ * arising from the use of this software.
+ *
+ * Permission is granted to anyone to use this software for any purpose,
+ * including commercial applications, and to alter it and redistribute it
+ * freely, subject to the following restrictions:
+ *
+ * 1. The origin of this software must not be misrepresented; you must not
+ *    claim that you wrote the original software. If you use this software
+ *    in a product, an acknowledgment in the product documentation would be
+ *    appreciated but is not required.
+ * 2. Altered source versions must be plainly marked as such, and must not be
+ *    misrepresented as being the original software.
+ * 3. This notice may not be removed or altered from any source distribution.
+ */
+
+#define JPEG_INTERNALS
+#include "jsimd_rvv.h"
+
+#define F_0_382 98  /* 0.382683433 =  98 * 2^-8 */
+#define F_0_541 139 /* 0.541196100 = 139 * 2^-8 */
+#define F_0_707 181 /* 0.707106781 = 181 * 2^-8 */
+#define F_1_306 334 /* 0.306562965 = 334 * 2^-8 */
+
+#define CONST_BITS 8
+
+#define DO_DCT()                                          \
+    {                                                     \
+        /* Even part */                                   \
+        tmp10 = __riscv_vadd_vv_i16mf2(tmp0, tmp3, vl);    \
+        tmp13 = __riscv_vsub_vv_i16mf2(tmp0, tmp3, vl);    \
+        tmp11 = __riscv_vadd_vv_i16mf2(tmp1, tmp2, vl);    \
+        tmp12 = __riscv_vsub_vv_i16mf2(tmp1, tmp2, vl);    \
+                                                          \
+        out0 = __riscv_vadd_vv_i16mf2(tmp10, tmp11, vl);   \
+        out4 = __riscv_vsub_vv_i16mf2(tmp10, tmp11, vl);   \
+                                                          \
+        z1 = __riscv_vadd_vv_i16mf2(tmp12, tmp13, vl);     \
+        pdt = __riscv_vwmul_vx_i32m1(z1, F_0_707, vl);    \
+        z1 = __riscv_vnsra_wx_i16mf2(pdt, CONST_BITS, vl); \
+        out2 = __riscv_vadd_vv_i16mf2(tmp13, z1, vl);      \
+        out6 = __riscv_vsub_vv_i16mf2(tmp13, z1, vl);      \
+                                                          \
+        /* Odd part */                                    \
+        tmp10 = __riscv_vadd_vv_i16mf2(tmp4, tmp5, vl);    \
+        tmp11 = __riscv_vadd_vv_i16mf2(tmp5, tmp6, vl);    \
+        tmp12 = __riscv_vadd_vv_i16mf2(tmp6, tmp7, vl);    \
+                                                          \
+        z5 = __riscv_vsub_vv_i16mf2(tmp10, tmp12, vl);     \
+        pdt = __riscv_vwmul_vx_i32m1(z5, F_0_382, vl);    \
+        z5 = __riscv_vnsra_wx_i16mf2(pdt, CONST_BITS, vl); \
+        pdt = __riscv_vwmul_vx_i32m1(tmp10, F_0_541, vl); \
+        z2 = __riscv_vnsra_wx_i16mf2(pdt, CONST_BITS, vl); \
+        z2 = __riscv_vadd_vv_i16mf2(z2, z5, vl);           \
+        pdt = __riscv_vwmul_vx_i32m1(tmp12, F_1_306, vl); \
+        z4 = __riscv_vnsra_wx_i16mf2(pdt, CONST_BITS, vl); \
+        z4 = __riscv_vadd_vv_i16mf2(z4, z5, vl);           \
+        pdt = __riscv_vwmul_vx_i32m1(tmp11, F_0_707, vl); \
+        z3 = __riscv_vnsra_wx_i16mf2(pdt, CONST_BITS, vl); \
+                                                          \
+        z11 = __riscv_vadd_vv_i16mf2(tmp7, z3, vl);        \
+        z13 = __riscv_vsub_vv_i16mf2(tmp7, z3, vl);        \
+                                                          \
+        out5 = __riscv_vadd_vv_i16mf2(z13, z2, vl);        \
+        out3 = __riscv_vsub_vv_i16mf2(z13, z2, vl);        \
+        out1 = __riscv_vadd_vv_i16mf2(z11, z4, vl);        \
+        out7 = __riscv_vsub_vv_i16mf2(z11, z4, vl);        \
+    }
+
+/* DCTSIZE=8, VLEN must >= 64 while using i16mf2 */
+void jsimd_fdct_ifast_rvv(DCTELEM *data)
+{
+    //printf("fdct_ifast | ");
+    int col_stride = DCTSIZE * sizeof(DCTELEM);
+    size_t vl = __riscv_vsetvl_e16mf2(DCTSIZE);
+
+    vint16mf2_t row0, row1, row2, row3, row4, row5, row6, row7,
+        col0, col1, col2, col3, col4, col5, col6, col7,
+        tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7,
+        tmp10, tmp11, tmp12, tmp13,
+        z1, z2, z3, z4, z5, z11, z13,
+        out0, out1, out2, out3, out4, out5, out6, out7;
+    vint32m1_t pdt;
+
+    /* Pass 1: process rows */
+    /* Load columns */
+    col0 = __riscv_vlse16_v_i16mf2(data + 0, col_stride, vl);
+    col1 = __riscv_vlse16_v_i16mf2(data + 1, col_stride, vl);
+    col2 = __riscv_vlse16_v_i16mf2(data + 2, col_stride, vl);
+    col3 = __riscv_vlse16_v_i16mf2(data + 3, col_stride, vl);
+    col4 = __riscv_vlse16_v_i16mf2(data + 4, col_stride, vl);
+    col5 = __riscv_vlse16_v_i16mf2(data + 5, col_stride, vl);
+    col6 = __riscv_vlse16_v_i16mf2(data + 6, col_stride, vl);
+    col7 = __riscv_vlse16_v_i16mf2(data + 7, col_stride, vl);
+
+    tmp0 = __riscv_vadd_vv_i16mf2(col0, col7, vl);
+    tmp7 = __riscv_vsub_vv_i16mf2(col0, col7, vl);
+    tmp1 = __riscv_vadd_vv_i16mf2(col1, col6, vl);
+    tmp6 = __riscv_vsub_vv_i16mf2(col1, col6, vl);
+    tmp2 = __riscv_vadd_vv_i16mf2(col2, col5, vl);
+    tmp5 = __riscv_vsub_vv_i16mf2(col2, col5, vl);
+    tmp3 = __riscv_vadd_vv_i16mf2(col3, col4, vl);
+    tmp4 = __riscv_vsub_vv_i16mf2(col3, col4, vl);
+
+    DO_DCT();
+
+    /* Store columns */
+    __riscv_vsse16_v_i16mf2(data + 0, col_stride, out0, vl);
+    __riscv_vsse16_v_i16mf2(data + 1, col_stride, out1, vl);
+    __riscv_vsse16_v_i16mf2(data + 2, col_stride, out2, vl);
+    __riscv_vsse16_v_i16mf2(data + 3, col_stride, out3, vl);
+    __riscv_vsse16_v_i16mf2(data + 4, col_stride, out4, vl);
+    __riscv_vsse16_v_i16mf2(data + 5, col_stride, out5, vl);
+    __riscv_vsse16_v_i16mf2(data + 6, col_stride, out6, vl);
+    __riscv_vsse16_v_i16mf2(data + 7, col_stride, out7, vl);
+
+    /* Pass 2: process columns */
+    /* Load rows */
+    row0 = __riscv_vle16_v_i16mf2(data + DCTSIZE * 0, vl);
+    row1 = __riscv_vle16_v_i16mf2(data + DCTSIZE * 1, vl);
+    row2 = __riscv_vle16_v_i16mf2(data + DCTSIZE * 2, vl);
+    row3 = __riscv_vle16_v_i16mf2(data + DCTSIZE * 3, vl);
+    row4 = __riscv_vle16_v_i16mf2(data + DCTSIZE * 4, vl);
+    row5 = __riscv_vle16_v_i16mf2(data + DCTSIZE * 5, vl);
+    row6 = __riscv_vle16_v_i16mf2(data + DCTSIZE * 6, vl);
+    row7 = __riscv_vle16_v_i16mf2(data + DCTSIZE * 7, vl);
+
+    tmp0 = __riscv_vadd_vv_i16mf2(row0, row7, vl);
+    tmp7 = __riscv_vsub_vv_i16mf2(row0, row7, vl);
+    tmp1 = __riscv_vadd_vv_i16mf2(row1, row6, vl);
+    tmp6 = __riscv_vsub_vv_i16mf2(row1, row6, vl);
+    tmp2 = __riscv_vadd_vv_i16mf2(row2, row5, vl);
+    tmp5 = __riscv_vsub_vv_i16mf2(row2, row5, vl);
+    tmp3 = __riscv_vadd_vv_i16mf2(row3, row4, vl);
+    tmp4 = __riscv_vsub_vv_i16mf2(row3, row4, vl);
+
+    DO_DCT();
+
+    /* Store rows */
+    __riscv_vse16_v_i16mf2(data + DCTSIZE * 0, out0, vl);
+    __riscv_vse16_v_i16mf2(data + DCTSIZE * 1, out1, vl);
+    __riscv_vse16_v_i16mf2(data + DCTSIZE * 2, out2, vl);
+    __riscv_vse16_v_i16mf2(data + DCTSIZE * 3, out3, vl);
+    __riscv_vse16_v_i16mf2(data + DCTSIZE * 4, out4, vl);
+    __riscv_vse16_v_i16mf2(data + DCTSIZE * 5, out5, vl);
+    __riscv_vse16_v_i16mf2(data + DCTSIZE * 6, out6, vl);
+    __riscv_vse16_v_i16mf2(data + DCTSIZE * 7, out7, vl);
+}
diff --git a/simd/rvv/jfdctint-rvv.c b/simd/rvv/jfdctint-rvv.c
new file mode 100644
index 0000000..c1dee50
--- /dev/null
+++ b/simd/rvv/jfdctint-rvv.c
@@ -0,0 +1,250 @@
+/*
+ * jfdctint-rvv.c - accurate integer FDCT
+ *
+ * Copyright (C) 2023, Spacemit, Inc.  All Rights Reserved.
+ * Contributed by Liang Junzhao <junzhao.liang@spacemit.com>
+ *
+ * This software is provided 'as-is', without any express or implied
+ * warranty.  In no event will the authors be held liable for any damages
+ * arising from the use of this software.
+ *
+ * Permission is granted to anyone to use this software for any purpose,
+ * including commercial applications, and to alter it and redistribute it
+ * freely, subject to the following restrictions:
+ *
+ * 1. The origin of this software must not be misrepresented; you must not
+ *    claim that you wrote the original software. If you use this software
+ *    in a product, an acknowledgment in the product documentation would be
+ *    appreciated but is not required.
+ * 2. Altered source versions must be plainly marked as such, and must not be
+ *    misrepresented as being the original software.
+ * 3. This notice may not be removed or altered from any source distribution.
+ */
+
+#define JPEG_INTERNALS
+#include "jsimd_rvv.h"
+
+#define CONST_BITS 13
+#define PASS1_BITS 2
+
+#define F_0_298 2446  /* 0.298631336 =  2446 * 2^-13 */
+#define F_0_390 3196  /* 0.390180644 =  3196 * 2^-13 */
+#define F_0_541 4433  /* 0.541196100 =  4433 * 2^-13 */
+#define F_0_765 6270  /* 0.765366865 =  6270 * 2^-13 */
+#define F_0_899 7373  /* 0.899976223 =  7373 * 2^-13 */
+#define F_1_175 9633  /* 1.175875602 =  9633 * 2^-13 */
+#define F_1_501 12299 /* 1.501321110 = 12299 * 2^-13 */
+#define F_1_847 15137 /* 1.847759065 = 15137 * 2^-13 */
+#define F_1_961 16069 /* 1.961570560 = 16069 * 2^-13 */
+#define F_2_053 16819 /* 2.053119869 = 16819 * 2^-13 */
+#define F_2_562 20995 /* 2.562915447 = 20995 * 2^-13 */
+#define F_3_072 25172 /* 3.072711026 = 25172 * 2^-13 */
+
+#define ROUND_ADD(n) (int32_t)1 << ((n)-1)
+
+/* DCTSIZE=8, VLEN must >= 64 while using i16mf2 */
+void jsimd_fdct_islow_rvv(DCTELEM *data)
+{
+    int col_stride = DCTSIZE * sizeof(DCTELEM);
+    size_t vl = __riscv_vsetvl_e16mf2(DCTSIZE);
+
+    vint16mf2_t row0, row1, row2, row3, row4, row5, row6, row7;
+    vint16mf2_t col0, col1, col2, col3, col4, col5, col6, col7;
+    vint16mf2_t tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
+    vint16mf2_t tmp10, tmp11, tmp12, tmp13;
+    vint16mf2_t z1, z2, z3, z4, z5, z11, z13;
+    vint16mf2_t out0, out1, out2, out3, out4, out5, out6, out7;
+    vint32m1_t p1, p2, p3, p4, p5, t4, t5, t6, t7, temp;
+
+    /* Pass 1: process rows */
+    /* Load columns */
+    col0 = __riscv_vlse16_v_i16mf2(data + 0, col_stride, vl);
+    col1 = __riscv_vlse16_v_i16mf2(data + 1, col_stride, vl);
+    col2 = __riscv_vlse16_v_i16mf2(data + 2, col_stride, vl);
+    col3 = __riscv_vlse16_v_i16mf2(data + 3, col_stride, vl);
+    col4 = __riscv_vlse16_v_i16mf2(data + 4, col_stride, vl);
+    col5 = __riscv_vlse16_v_i16mf2(data + 5, col_stride, vl);
+    col6 = __riscv_vlse16_v_i16mf2(data + 6, col_stride, vl);
+    col7 = __riscv_vlse16_v_i16mf2(data + 7, col_stride, vl);
+
+    tmp0 = __riscv_vadd_vv_i16mf2(col0, col7, vl);
+    tmp7 = __riscv_vsub_vv_i16mf2(col0, col7, vl);
+    tmp1 = __riscv_vadd_vv_i16mf2(col1, col6, vl);
+    tmp6 = __riscv_vsub_vv_i16mf2(col1, col6, vl);
+    tmp2 = __riscv_vadd_vv_i16mf2(col2, col5, vl);
+    tmp5 = __riscv_vsub_vv_i16mf2(col2, col5, vl);
+    tmp3 = __riscv_vadd_vv_i16mf2(col3, col4, vl);
+    tmp4 = __riscv_vsub_vv_i16mf2(col3, col4, vl);
+
+    /* Even part */
+    tmp10 = __riscv_vadd_vv_i16mf2(tmp0, tmp3, vl);
+    tmp13 = __riscv_vsub_vv_i16mf2(tmp0, tmp3, vl);
+    tmp11 = __riscv_vadd_vv_i16mf2(tmp1, tmp2, vl);
+    tmp12 = __riscv_vsub_vv_i16mf2(tmp1, tmp2, vl);
+
+    out0 = __riscv_vadd_vv_i16mf2(tmp10, tmp11, vl);
+    out0 = __riscv_vsll_vx_i16mf2(out0, PASS1_BITS, vl);
+    out4 = __riscv_vsub_vv_i16mf2(tmp10, tmp11, vl);
+    out4 = __riscv_vsll_vx_i16mf2(out4, PASS1_BITS, vl);
+
+    z1 = __riscv_vadd_vv_i16mf2(tmp12, tmp13, vl);
+    p1 = __riscv_vwmul_vx_i32m1(z1, F_0_541, vl);
+
+    temp = __riscv_vwmul_vx_i32m1(tmp13, F_0_765, vl);
+    temp = __riscv_vadd_vv_i32m1(p1, temp, vl);
+    temp = __riscv_vadd_vx_i32m1(temp, ROUND_ADD(CONST_BITS - PASS1_BITS), vl);
+    out2 = __riscv_vnsra_wx_i16mf2(temp, CONST_BITS - PASS1_BITS, vl);
+
+    temp = __riscv_vwmul_vx_i32m1(tmp12, F_1_847, vl);
+    temp = __riscv_vsub_vv_i32m1(p1, temp, vl);
+    temp = __riscv_vadd_vx_i32m1(temp, ROUND_ADD(CONST_BITS - PASS1_BITS), vl);
+    out6 = __riscv_vnsra_wx_i16mf2(temp, CONST_BITS - PASS1_BITS, vl);
+
+    /* Odd part */
+    z1 = __riscv_vadd_vv_i16mf2(tmp4, tmp7, vl);
+    z2 = __riscv_vadd_vv_i16mf2(tmp5, tmp6, vl);
+    z3 = __riscv_vadd_vv_i16mf2(tmp4, tmp6, vl);
+    z4 = __riscv_vadd_vv_i16mf2(tmp5, tmp7, vl);
+    z5 = __riscv_vadd_vv_i16mf2(z3, z4, vl);
+    p5 = __riscv_vwmul_vx_i32m1(z5, F_1_175, vl);
+
+    t4 = __riscv_vwmul_vx_i32m1(tmp4, F_0_298, vl);
+    t5 = __riscv_vwmul_vx_i32m1(tmp5, F_2_053, vl);
+    t6 = __riscv_vwmul_vx_i32m1(tmp6, F_3_072, vl);
+    t7 = __riscv_vwmul_vx_i32m1(tmp7, F_1_501, vl);
+
+    p1 = __riscv_vwmul_vx_i32m1(z1, -F_0_899, vl);
+    p2 = __riscv_vwmul_vx_i32m1(z2, -F_2_562, vl);
+    p3 = __riscv_vwmul_vx_i32m1(z3, -F_1_961, vl);
+    p4 = __riscv_vwmul_vx_i32m1(z4, -F_0_390, vl);
+
+    p3 = __riscv_vadd_vv_i32m1(p3, p5, vl);
+    p4 = __riscv_vadd_vv_i32m1(p4, p5, vl);
+
+    temp = __riscv_vadd_vv_i32m1(t4, p1, vl);
+    temp = __riscv_vadd_vv_i32m1(temp, p3, vl);
+    temp = __riscv_vadd_vx_i32m1(temp, ROUND_ADD(CONST_BITS - PASS1_BITS), vl);
+    out7 = __riscv_vnsra_wx_i16mf2(temp, CONST_BITS - PASS1_BITS, vl);
+
+    temp = __riscv_vadd_vv_i32m1(t5, p2, vl);
+    temp = __riscv_vadd_vv_i32m1(temp, p4, vl);
+    temp = __riscv_vadd_vx_i32m1(temp, ROUND_ADD(CONST_BITS - PASS1_BITS), vl);
+    out5 = __riscv_vnsra_wx_i16mf2(temp, CONST_BITS - PASS1_BITS, vl);
+
+    temp = __riscv_vadd_vv_i32m1(t6, p2, vl);
+    temp = __riscv_vadd_vv_i32m1(temp, p3, vl);
+    temp = __riscv_vadd_vx_i32m1(temp, ROUND_ADD(CONST_BITS - PASS1_BITS), vl);
+    out3 = __riscv_vnsra_wx_i16mf2(temp, CONST_BITS - PASS1_BITS, vl);
+
+    temp = __riscv_vadd_vv_i32m1(t7, p1, vl);
+    temp = __riscv_vadd_vv_i32m1(temp, p4, vl);
+    temp = __riscv_vadd_vx_i32m1(temp, ROUND_ADD(CONST_BITS - PASS1_BITS), vl);
+    out1 = __riscv_vnsra_wx_i16mf2(temp, CONST_BITS - PASS1_BITS, vl);
+
+    /* Store columns */
+    __riscv_vsse16_v_i16mf2(data + 0, col_stride, out0, vl);
+    __riscv_vsse16_v_i16mf2(data + 1, col_stride, out1, vl);
+    __riscv_vsse16_v_i16mf2(data + 2, col_stride, out2, vl);
+    __riscv_vsse16_v_i16mf2(data + 3, col_stride, out3, vl);
+    __riscv_vsse16_v_i16mf2(data + 4, col_stride, out4, vl);
+    __riscv_vsse16_v_i16mf2(data + 5, col_stride, out5, vl);
+    __riscv_vsse16_v_i16mf2(data + 6, col_stride, out6, vl);
+    __riscv_vsse16_v_i16mf2(data + 7, col_stride, out7, vl);
+
+    /* Pass 2: process columns */
+    /* Load rows */
+    row0 = __riscv_vle16_v_i16mf2(data + DCTSIZE * 0, vl);
+    row1 = __riscv_vle16_v_i16mf2(data + DCTSIZE * 1, vl);
+    row2 = __riscv_vle16_v_i16mf2(data + DCTSIZE * 2, vl);
+    row3 = __riscv_vle16_v_i16mf2(data + DCTSIZE * 3, vl);
+    row4 = __riscv_vle16_v_i16mf2(data + DCTSIZE * 4, vl);
+    row5 = __riscv_vle16_v_i16mf2(data + DCTSIZE * 5, vl);
+    row6 = __riscv_vle16_v_i16mf2(data + DCTSIZE * 6, vl);
+    row7 = __riscv_vle16_v_i16mf2(data + DCTSIZE * 7, vl);
+
+    tmp0 = __riscv_vadd_vv_i16mf2(row0, row7, vl);
+    tmp7 = __riscv_vsub_vv_i16mf2(row0, row7, vl);
+    tmp1 = __riscv_vadd_vv_i16mf2(row1, row6, vl);
+    tmp6 = __riscv_vsub_vv_i16mf2(row1, row6, vl);
+    tmp2 = __riscv_vadd_vv_i16mf2(row2, row5, vl);
+    tmp5 = __riscv_vsub_vv_i16mf2(row2, row5, vl);
+    tmp3 = __riscv_vadd_vv_i16mf2(row3, row4, vl);
+    tmp4 = __riscv_vsub_vv_i16mf2(row3, row4, vl);
+
+    /* Even part */
+    tmp10 = __riscv_vadd_vv_i16mf2(tmp0, tmp3, vl);
+    tmp13 = __riscv_vsub_vv_i16mf2(tmp0, tmp3, vl);
+    tmp11 = __riscv_vadd_vv_i16mf2(tmp1, tmp2, vl);
+    tmp12 = __riscv_vsub_vv_i16mf2(tmp1, tmp2, vl);
+
+    out0 = __riscv_vadd_vv_i16mf2(tmp10, tmp11, vl);
+    out0 = __riscv_vadd_vx_i16mf2(out0, ROUND_ADD(PASS1_BITS), vl);
+    out0 = __riscv_vsra_vx_i16mf2(out0, PASS1_BITS, vl);
+    out4 = __riscv_vsub_vv_i16mf2(tmp10, tmp11, vl);
+    out4 = __riscv_vadd_vx_i16mf2(out4, ROUND_ADD(PASS1_BITS), vl);
+    out4 = __riscv_vsra_vx_i16mf2(out4, PASS1_BITS, vl);
+
+    z1 = __riscv_vadd_vv_i16mf2(tmp12, tmp13, vl);
+    p1 = __riscv_vwmul_vx_i32m1(z1, F_0_541, vl);
+
+    temp = __riscv_vwmul_vx_i32m1(tmp13, F_0_765, vl);
+    temp = __riscv_vadd_vv_i32m1(p1, temp, vl);
+    temp = __riscv_vadd_vx_i32m1(temp, ROUND_ADD(CONST_BITS + PASS1_BITS), vl);
+    out2 = __riscv_vnsra_wx_i16mf2(temp, CONST_BITS + PASS1_BITS, vl);
+
+    temp = __riscv_vwmul_vx_i32m1(tmp12, F_1_847, vl);
+    temp = __riscv_vsub_vv_i32m1(p1, temp, vl);
+    temp = __riscv_vadd_vx_i32m1(temp, ROUND_ADD(CONST_BITS + PASS1_BITS), vl);
+    out6 = __riscv_vnsra_wx_i16mf2(temp, CONST_BITS + PASS1_BITS, vl);
+
+    /* Odd part */
+    z1 = __riscv_vadd_vv_i16mf2(tmp4, tmp7, vl);
+    z2 = __riscv_vadd_vv_i16mf2(tmp5, tmp6, vl);
+    z3 = __riscv_vadd_vv_i16mf2(tmp4, tmp6, vl);
+    z4 = __riscv_vadd_vv_i16mf2(tmp5, tmp7, vl);
+    z5 = __riscv_vadd_vv_i16mf2(z3, z4, vl);
+    p5 = __riscv_vwmul_vx_i32m1(z5, F_1_175, vl);
+
+    t4 = __riscv_vwmul_vx_i32m1(tmp4, F_0_298, vl);
+    t5 = __riscv_vwmul_vx_i32m1(tmp5, F_2_053, vl);
+    t6 = __riscv_vwmul_vx_i32m1(tmp6, F_3_072, vl);
+    t7 = __riscv_vwmul_vx_i32m1(tmp7, F_1_501, vl);
+
+    p1 = __riscv_vwmul_vx_i32m1(z1, -F_0_899, vl);
+    p2 = __riscv_vwmul_vx_i32m1(z2, -F_2_562, vl);
+    p3 = __riscv_vwmul_vx_i32m1(z3, -F_1_961, vl);
+    p4 = __riscv_vwmul_vx_i32m1(z4, -F_0_390, vl);
+
+    p3 = __riscv_vadd_vv_i32m1(p3, p5, vl);
+    p4 = __riscv_vadd_vv_i32m1(p4, p5, vl);
+
+    temp = __riscv_vadd_vv_i32m1(t4, p1, vl);
+    temp = __riscv_vadd_vv_i32m1(temp, p3, vl);
+    temp = __riscv_vadd_vx_i32m1(temp, ROUND_ADD(CONST_BITS + PASS1_BITS), vl);
+    out7 = __riscv_vnsra_wx_i16mf2(temp, CONST_BITS + PASS1_BITS, vl);
+
+    temp = __riscv_vadd_vv_i32m1(t5, p2, vl);
+    temp = __riscv_vadd_vv_i32m1(temp, p4, vl);
+    temp = __riscv_vadd_vx_i32m1(temp, ROUND_ADD(CONST_BITS + PASS1_BITS), vl);
+    out5 = __riscv_vnsra_wx_i16mf2(temp, CONST_BITS + PASS1_BITS, vl);
+
+    temp = __riscv_vadd_vv_i32m1(t6, p2, vl);
+    temp = __riscv_vadd_vv_i32m1(temp, p3, vl);
+    temp = __riscv_vadd_vx_i32m1(temp, ROUND_ADD(CONST_BITS + PASS1_BITS), vl);
+    out3 = __riscv_vnsra_wx_i16mf2(temp, CONST_BITS + PASS1_BITS, vl);
+
+    temp = __riscv_vadd_vv_i32m1(t7, p1, vl);
+    temp = __riscv_vadd_vv_i32m1(temp, p4, vl);
+    temp = __riscv_vadd_vx_i32m1(temp, ROUND_ADD(CONST_BITS + PASS1_BITS), vl);
+    out1 = __riscv_vnsra_wx_i16mf2(temp, CONST_BITS + PASS1_BITS, vl);
+
+    /* Store rows */
+    __riscv_vse16_v_i16mf2(data + DCTSIZE * 0, out0, vl);
+    __riscv_vse16_v_i16mf2(data + DCTSIZE * 1, out1, vl);
+    __riscv_vse16_v_i16mf2(data + DCTSIZE * 2, out2, vl);
+    __riscv_vse16_v_i16mf2(data + DCTSIZE * 3, out3, vl);
+    __riscv_vse16_v_i16mf2(data + DCTSIZE * 4, out4, vl);
+    __riscv_vse16_v_i16mf2(data + DCTSIZE * 5, out5, vl);
+    __riscv_vse16_v_i16mf2(data + DCTSIZE * 6, out6, vl);
+    __riscv_vse16_v_i16mf2(data + DCTSIZE * 7, out7, vl);
+}
diff --git a/simd/rvv/jidctfst-rvv.c b/simd/rvv/jidctfst-rvv.c
new file mode 100644
index 0000000..4f81c5f
--- /dev/null
+++ b/simd/rvv/jidctfst-rvv.c
@@ -0,0 +1,315 @@
+
+/*
+ * jidctfst-rvv.c - fast integer IDCT
+ *
+ * Copyright (C) 2020, Arm Limited.  All Rights Reserved.
+ *
+ * This software is provided 'as-is', without any express or implied
+ * warranty.  In no event will the authors be held liable for any damages
+ * arising from the use of this software.
+ *
+ * Permission is granted to anyone to use this software for any purpose,
+ * including commercial applications, and to alter it and redistribute it
+ * freely, subject to the following restrictions:
+ *
+ * 1. The origin of this software must not be misrepresented; you must not
+ *    claim that you wrote the original software. If you use this software
+ *    in a product, an acknowledgment in the product documentation would be
+ *    appreciated but is not required.
+ * 2. Altered source versions must be plainly marked as such, and must not be
+ *    misrepresented as being the original software.
+ * 3. This notice may not be removed or altered from any source distribution.
+ */
+
+#define JPEG_INTERNALS
+#include "jsimd_rvv.h"
+
+#define FIX_1_082 277 /* 1.082392200 = 277 * 2^-8 */
+#define FIX_1_414 362 /* 1.414213562 = 362 * 2^-8 */
+#define FIX_1_847 473 /* 1.847759065 = 473 * 2^-8 */
+#define FIX_2_613 669 /* 2.613125930 = 669 * 2^-8 */
+
+#if BITS_IN_JSAMPLE == 8
+#define CONST_BITS 8
+#define PASS1_BITS 2
+#else
+#define CONST_BITS 8
+#define PASS1_BITS 1 /* lose a little precision to avoid overflow */
+#endif
+
+#define DO_IDCT_0(in)                                         \
+    {                                                         \
+        /* Even part */                                       \
+        tmp10 = __riscv_vadd_vv_i16mf2(in##0, in##4, vl);     \
+        tmp11 = __riscv_vsub_vv_i16mf2(in##0, in##4, vl);     \
+        tmp13 = __riscv_vadd_vv_i16mf2(in##2, in##6, vl);     \
+                                                              \
+        tmp12 = __riscv_vsub_vv_i16mf2(in##2, in##6, vl);     \
+        pdt = __riscv_vwmul_vx_i32m1(tmp12, FIX_1_414, vl);   \
+        tmp12 = __riscv_vnsra_wx_i16mf2(pdt, CONST_BITS, vl); \
+        tmp12 = __riscv_vsub_vv_i16mf2(tmp12, tmp13, vl);     \
+    }
+#define DO_IDCT_1(in)                                         \
+    {                                                         \
+        tmp0 = __riscv_vadd_vv_i16mf2(tmp10, tmp13, vl);      \
+        tmp3 = __riscv_vsub_vv_i16mf2(tmp10, tmp13, vl);      \
+        tmp1 = __riscv_vadd_vv_i16mf2(tmp11, tmp12, vl);      \
+        tmp2 = __riscv_vsub_vv_i16mf2(tmp11, tmp12, vl);      \
+                                                              \
+        /* Odd part */                                        \
+        z13 = __riscv_vadd_vv_i16mf2(in##5, in##3, vl);       \
+        z10 = __riscv_vsub_vv_i16mf2(in##5, in##3, vl);       \
+        z11 = __riscv_vadd_vv_i16mf2(in##1, in##7, vl);       \
+        z12 = __riscv_vsub_vv_i16mf2(in##1, in##7, vl);       \
+                                                              \
+        tmp7 = __riscv_vadd_vv_i16mf2(z11, z13, vl);          \
+        tmp11 = __riscv_vsub_vv_i16mf2(z11, z13, vl);         \
+        pdt = __riscv_vwmul_vx_i32m1(tmp11, FIX_1_414, vl);   \
+        tmp11 = __riscv_vnsra_wx_i16mf2(pdt, CONST_BITS, vl); \
+                                                              \
+        z5 = __riscv_vadd_vv_i16mf2(z10, z12, vl);            \
+        pdt = __riscv_vwmul_vx_i32m1(z5, FIX_1_847, vl);      \
+        z5 = __riscv_vnsra_wx_i16mf2(pdt, CONST_BITS, vl);    \
+                                                              \
+        pdt = __riscv_vwmul_vx_i32m1(z12, FIX_1_082, vl);     \
+        tmp10 = __riscv_vnsra_wx_i16mf2(pdt, CONST_BITS, vl); \
+        tmp10 = __riscv_vsub_vv_i16mf2(tmp10, z5, vl);        \
+        pdt = __riscv_vwmul_vx_i32m1(z10, -FIX_2_613, vl);    \
+        tmp12 = __riscv_vnsra_wx_i16mf2(pdt, CONST_BITS, vl); \
+        tmp12 = __riscv_vadd_vv_i16mf2(z5, tmp12, vl);        \
+                                                              \
+        tmp6 = __riscv_vsub_vv_i16mf2(tmp12, tmp7, vl);       \
+        tmp5 = __riscv_vsub_vv_i16mf2(tmp11, tmp6, vl);       \
+        tmp4 = __riscv_vadd_vv_i16mf2(tmp10, tmp5, vl);       \
+    }
+
+#define DO_SPARSE_IDCT_0(in)                                  \
+    {                                                         \
+        /* Even part */                                       \
+        pdt = __riscv_vwmul_vx_i32m1(in##2, FIX_1_414, vl);   \
+        tmp12 = __riscv_vnsra_wx_i16mf2(pdt, CONST_BITS, vl); \
+        tmp12 = __riscv_vsub_vv_i16mf2(tmp12, in##2, vl);     \
+    }
+#define DO_SPARSE_IDCT_1(in)                                  \
+    {                                                         \
+        tmp0 = __riscv_vadd_vv_i16mf2(in##0, in##2, vl);      \
+        tmp3 = __riscv_vsub_vv_i16mf2(in##0, in##2, vl);      \
+        tmp1 = __riscv_vadd_vv_i16mf2(in##0, tmp12, vl);      \
+        tmp2 = __riscv_vsub_vv_i16mf2(in##0, tmp12, vl);      \
+                                                              \
+        /* Odd part */                                        \
+        tmp7 = __riscv_vadd_vv_i16mf2(in##1, in##3, vl);      \
+        tmp11 = __riscv_vsub_vv_i16mf2(in##1, in##3, vl);     \
+        pdt = __riscv_vwmul_vx_i32m1(tmp11, FIX_1_414, vl);   \
+        tmp11 = __riscv_vnsra_wx_i16mf2(pdt, CONST_BITS, vl); \
+                                                              \
+        /* z5 = __riscv_vadd_vv_i16mf2(z10, z12, vl);*/       \
+        z5 = __riscv_vsub_vv_i16mf2(in##1, in##3, vl);        \
+        pdt = __riscv_vwmul_vx_i32m1(z5, FIX_1_847, vl);      \
+        z5 = __riscv_vnsra_wx_i16mf2(pdt, CONST_BITS, vl);    \
+                                                              \
+        pdt = __riscv_vwmul_vx_i32m1(in##1, FIX_1_082, vl);   \
+        tmp10 = __riscv_vnsra_wx_i16mf2(pdt, CONST_BITS, vl); \
+        tmp10 = __riscv_vsub_vv_i16mf2(tmp10, z5, vl);        \
+        pdt = __riscv_vwmul_vx_i32m1(in##3, FIX_2_613, vl);   \
+        tmp12 = __riscv_vnsra_wx_i16mf2(pdt, CONST_BITS, vl); \
+        tmp12 = __riscv_vadd_vv_i16mf2(z5, tmp12, vl);        \
+                                                              \
+        tmp6 = __riscv_vsub_vv_i16mf2(tmp12, tmp7, vl);       \
+        tmp5 = __riscv_vsub_vv_i16mf2(tmp11, tmp6, vl);       \
+        tmp4 = __riscv_vadd_vv_i16mf2(tmp10, tmp5, vl);       \
+    }
+
+#define OUTPUT()                                       \
+    {                                                  \
+        out0 = __riscv_vadd_vv_i16mf2(tmp0, tmp7, vl); \
+        out7 = __riscv_vsub_vv_i16mf2(tmp0, tmp7, vl); \
+        out1 = __riscv_vadd_vv_i16mf2(tmp1, tmp6, vl); \
+        out6 = __riscv_vsub_vv_i16mf2(tmp1, tmp6, vl); \
+        out2 = __riscv_vadd_vv_i16mf2(tmp2, tmp5, vl); \
+        out5 = __riscv_vsub_vv_i16mf2(tmp2, tmp5, vl); \
+        out4 = __riscv_vadd_vv_i16mf2(tmp3, tmp4, vl); \
+        out3 = __riscv_vsub_vv_i16mf2(tmp3, tmp4, vl); \
+    }
+
+void jsimd_idct_ifast_rvv(void *dct_table, JCOEFPTR coef_block,
+                          JSAMPARRAY output_buf, JDIMENSION output_col)
+{
+    int col_stride = DCTSIZE * sizeof(DCTELEM);
+    size_t stride[8];
+    size_t vl = __riscv_vsetvl_e16mf2(DCTSIZE);
+    IFAST_MULT_TYPE *quantptr = dct_table;
+    DCTELEM workspace[DCTSIZE2];
+    JSAMPROW output_row = output_buf[0] + output_col;
+
+    stride[0] = 0;
+    for (int i = 1; i < 8; ++i)
+    {
+        stride[i] = output_buf[i] - output_buf[0];
+    }
+
+    vbool32_t beq0;
+    vint16mf2_t bit;
+    vint8mf4_t dst0, dst1, dst2, dst3, dst4, dst5, dst6, dst7;
+    vint16mf2_t row0, row1, row2, row3, row4, row5, row6, row7;
+    vint16mf2_t col0, col1, col2, col3, col4, col5, col6, col7;
+    vint16mf2_t tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
+    vint16mf2_t tmp10, tmp11, tmp12, tmp13;
+    vint16mf2_t z1, z2, z3, z4, z5, z10, z11, z12, z13;
+    vint16mf2_t out0, out1, out2, out3, out4, out5, out6, out7;
+    vint16mf2_t quant0, quant1, quant2, quant3, quant4, quant5, quant6, quant7;
+    vint16mf2_t bitmap;
+    vint32m1_t pdt;
+
+    /* Pass 1: process columns from input, store into work array. */
+    /* Load DCT coefficients. */
+    row0 = __riscv_vle16_v_i16mf2(coef_block + DCTSIZE * 0, vl);
+    row1 = __riscv_vle16_v_i16mf2(coef_block + DCTSIZE * 1, vl);
+    row2 = __riscv_vle16_v_i16mf2(coef_block + DCTSIZE * 2, vl);
+    row3 = __riscv_vle16_v_i16mf2(coef_block + DCTSIZE * 3, vl);
+    row4 = __riscv_vle16_v_i16mf2(coef_block + DCTSIZE * 4, vl);
+    row5 = __riscv_vle16_v_i16mf2(coef_block + DCTSIZE * 5, vl);
+    row6 = __riscv_vle16_v_i16mf2(coef_block + DCTSIZE * 6, vl);
+    row7 = __riscv_vle16_v_i16mf2(coef_block + DCTSIZE * 7, vl);
+
+    bit = __riscv_vor_vv_i16mf2(row4, row5, vl);
+    bit = __riscv_vor_vv_i16mf2(bit, row6, vl);
+    bit = __riscv_vor_vv_i16mf2(bit, row7, vl);
+    beq0 = __riscv_vmseq_vx_i16mf2_b32(bit, 0, vl);
+    unsigned long row4567_cpop0 = __riscv_vcpop_m_b32(beq0, vl);
+
+    bit = __riscv_vor_vv_i16mf2(row1, row2, vl);
+    bit = __riscv_vor_vv_i16mf2(bit, row3, vl);
+    beq0 = __riscv_vmseq_vx_i16mf2_b32(bit, 0, vl);
+    unsigned long row123_cpop0 = __riscv_vcpop_m_b32(beq0, vl);
+
+    // 当打印helloworld时，简化算法正常执行；注释helloworld后，仅执行复杂算法，不打印:)
+    if (8 == row123_cpop0 && 8 == row4567_cpop0)
+    {
+        // 全零，执行简化算法，此时将打印:)
+        /* Load quantization table values for DC coefficients. */
+        quant0 = __riscv_vle16_v_i16mf2(quantptr + 0 * DCTSIZE, vl);
+        row0 = __riscv_vmul_vv_i16mf2(row0, quant0, vl);
+
+        /* Store rows */
+        __riscv_vse16_v_i16mf2(workspace + DCTSIZE * 0, row0, vl);
+
+        // All zero时，用mv第一个参数代替load性能更佳
+        col0 = __riscv_vmv_v_x_i16mf2(workspace[0], vl);
+        col1 = __riscv_vmv_v_x_i16mf2(workspace[1], vl);
+        col2 = __riscv_vmv_v_x_i16mf2(workspace[2], vl);
+        col3 = __riscv_vmv_v_x_i16mf2(workspace[3], vl);
+        col4 = __riscv_vmv_v_x_i16mf2(workspace[4], vl);
+        col5 = __riscv_vmv_v_x_i16mf2(workspace[5], vl);
+        col6 = __riscv_vmv_v_x_i16mf2(workspace[6], vl);
+        col7 = __riscv_vmv_v_x_i16mf2(workspace[7], vl);
+    }
+    else
+    {
+        if (8 == row4567_cpop0)
+        {
+            quant0 = __riscv_vle16_v_i16mf2(quantptr + 0 * DCTSIZE, vl);
+            quant1 = __riscv_vle16_v_i16mf2(quantptr + 1 * DCTSIZE, vl);
+            quant2 = __riscv_vle16_v_i16mf2(quantptr + 2 * DCTSIZE, vl);
+            quant3 = __riscv_vle16_v_i16mf2(quantptr + 3 * DCTSIZE, vl);
+            row0 = __riscv_vmul_vv_i16mf2(row0, quant0, vl);
+            row1 = __riscv_vmul_vv_i16mf2(row1, quant1, vl);
+            row2 = __riscv_vmul_vv_i16mf2(row2, quant2, vl);
+            row3 = __riscv_vmul_vv_i16mf2(row3, quant3, vl);
+
+            DO_SPARSE_IDCT_0(row);
+            DO_SPARSE_IDCT_1(row);
+        }
+        else
+        {
+            /* Load quantization table. */
+            quant0 = __riscv_vle16_v_i16mf2(quantptr + 0 * DCTSIZE, vl);
+            quant1 = __riscv_vle16_v_i16mf2(quantptr + 1 * DCTSIZE, vl);
+            quant2 = __riscv_vle16_v_i16mf2(quantptr + 2 * DCTSIZE, vl);
+            quant3 = __riscv_vle16_v_i16mf2(quantptr + 3 * DCTSIZE, vl);
+            quant4 = __riscv_vle16_v_i16mf2(quantptr + 4 * DCTSIZE, vl);
+            quant5 = __riscv_vle16_v_i16mf2(quantptr + 5 * DCTSIZE, vl);
+            quant6 = __riscv_vle16_v_i16mf2(quantptr + 6 * DCTSIZE, vl);
+            quant7 = __riscv_vle16_v_i16mf2(quantptr + 7 * DCTSIZE, vl);
+
+            row0 = __riscv_vmul_vv_i16mf2(row0, quant0, vl);
+            row1 = __riscv_vmul_vv_i16mf2(row1, quant1, vl);
+            row2 = __riscv_vmul_vv_i16mf2(row2, quant2, vl);
+            row3 = __riscv_vmul_vv_i16mf2(row3, quant3, vl);
+            row4 = __riscv_vmul_vv_i16mf2(row4, quant4, vl);
+            row5 = __riscv_vmul_vv_i16mf2(row5, quant5, vl);
+            row6 = __riscv_vmul_vv_i16mf2(row6, quant6, vl);
+            row7 = __riscv_vmul_vv_i16mf2(row7, quant7, vl);
+
+            DO_IDCT_0(row);
+            DO_IDCT_1(row);
+        }
+
+        OUTPUT();
+
+        /* Store rows */
+        __riscv_vse16_v_i16mf2(workspace + DCTSIZE * 0, out0, vl);
+        __riscv_vse16_v_i16mf2(workspace + DCTSIZE * 1, out1, vl);
+        __riscv_vse16_v_i16mf2(workspace + DCTSIZE * 2, out2, vl);
+        __riscv_vse16_v_i16mf2(workspace + DCTSIZE * 3, out3, vl);
+        __riscv_vse16_v_i16mf2(workspace + DCTSIZE * 4, out4, vl);
+        __riscv_vse16_v_i16mf2(workspace + DCTSIZE * 5, out5, vl);
+        __riscv_vse16_v_i16mf2(workspace + DCTSIZE * 6, out6, vl);
+        __riscv_vse16_v_i16mf2(workspace + DCTSIZE * 7, out7, vl);
+
+        /* Pass 2: process rows from work array, store into output array. */
+        /* Load columns */
+        col0 = __riscv_vlse16_v_i16mf2(workspace + 0, col_stride, vl);
+        col1 = __riscv_vlse16_v_i16mf2(workspace + 1, col_stride, vl);
+        col2 = __riscv_vlse16_v_i16mf2(workspace + 2, col_stride, vl);
+        col3 = __riscv_vlse16_v_i16mf2(workspace + 3, col_stride, vl);
+        col4 = __riscv_vlse16_v_i16mf2(workspace + 4, col_stride, vl);
+        col5 = __riscv_vlse16_v_i16mf2(workspace + 5, col_stride, vl);
+        col6 = __riscv_vlse16_v_i16mf2(workspace + 6, col_stride, vl);
+        col7 = __riscv_vlse16_v_i16mf2(workspace + 7, col_stride, vl);
+    }
+
+    DO_IDCT_0(col);
+    tmp10 = __riscv_vadd_vx_i16mf2(tmp10, CENTERJSAMPLE << PASS1_BITS + 3, vl);
+    tmp11 = __riscv_vadd_vx_i16mf2(tmp11, CENTERJSAMPLE << PASS1_BITS + 3, vl);
+    DO_IDCT_1(col);
+    OUTPUT();
+
+    out0 = __riscv_vsra_vx_i16mf2(out0, PASS1_BITS + 3, vl);
+    out1 = __riscv_vsra_vx_i16mf2(out1, PASS1_BITS + 3, vl);
+    out2 = __riscv_vsra_vx_i16mf2(out2, PASS1_BITS + 3, vl);
+    out3 = __riscv_vsra_vx_i16mf2(out3, PASS1_BITS + 3, vl);
+    out4 = __riscv_vsra_vx_i16mf2(out4, PASS1_BITS + 3, vl);
+    out5 = __riscv_vsra_vx_i16mf2(out5, PASS1_BITS + 3, vl);
+    out6 = __riscv_vsra_vx_i16mf2(out6, PASS1_BITS + 3, vl);
+    out7 = __riscv_vsra_vx_i16mf2(out7, PASS1_BITS + 3, vl);
+
+    CLIP(out0, i16mf2);
+    CLIP(out1, i16mf2);
+    CLIP(out2, i16mf2);
+    CLIP(out3, i16mf2);
+    CLIP(out4, i16mf2);
+    CLIP(out5, i16mf2);
+    CLIP(out6, i16mf2);
+    CLIP(out7, i16mf2);
+
+    dst0 = __riscv_vncvt_x_x_w_i8mf4(out0, vl);
+    dst1 = __riscv_vncvt_x_x_w_i8mf4(out1, vl);
+    dst2 = __riscv_vncvt_x_x_w_i8mf4(out2, vl);
+    dst3 = __riscv_vncvt_x_x_w_i8mf4(out3, vl);
+    dst4 = __riscv_vncvt_x_x_w_i8mf4(out4, vl);
+    dst5 = __riscv_vncvt_x_x_w_i8mf4(out5, vl);
+    dst6 = __riscv_vncvt_x_x_w_i8mf4(out6, vl);
+    dst7 = __riscv_vncvt_x_x_w_i8mf4(out7, vl);
+
+    /* store columns */
+    vuint64m2_t vstride = __riscv_vle64_v_u64m2(stride, vl);
+    __riscv_vsoxei64_v_i8mf4(output_row + 0, vstride, dst0, vl);
+    __riscv_vsoxei64_v_i8mf4(output_row + 1, vstride, dst1, vl);
+    __riscv_vsoxei64_v_i8mf4(output_row + 2, vstride, dst2, vl);
+    __riscv_vsoxei64_v_i8mf4(output_row + 3, vstride, dst3, vl);
+    __riscv_vsoxei64_v_i8mf4(output_row + 4, vstride, dst4, vl);
+    __riscv_vsoxei64_v_i8mf4(output_row + 5, vstride, dst5, vl);
+    __riscv_vsoxei64_v_i8mf4(output_row + 6, vstride, dst6, vl);
+    __riscv_vsoxei64_v_i8mf4(output_row + 7, vstride, dst7, vl);
+}
\ No newline at end of file
diff --git a/simd/rvv/jidctint-rvv.c b/simd/rvv/jidctint-rvv.c
new file mode 100644
index 0000000..4ef39db
--- /dev/null
+++ b/simd/rvv/jidctint-rvv.c
@@ -0,0 +1,360 @@
+/*
+ * jidctint-rvv.c - accurate integer IDCT
+ *
+ * Copyright (C) 2023, Spacemit, Inc.  All Rights Reserved.
+ * Contributed by Liang Junzhao <junzhao.liang@spacemit.com>
+ *
+ * This software is provided 'as-is', without any express or implied
+ * warranty.  In no event will the authors be held liable for any damages
+ * arising from the use of this software.
+ *
+ * Permission is granted to anyone to use this software for any purpose,
+ * including commercial applications, and to alter it and redistribute it
+ * freely, subject to the following restrictions:
+ *
+ * 1. The origin of this software must not be misrepresented; you must not
+ *    claim that you wrote the original software. If you use this software
+ *    in a product, an acknowledgment in the product documentation would be
+ *    appreciated but is not required.
+ * 2. Altered source versions must be plainly marked as such, and must not be
+ *    misrepresented as being the original software.
+ * 3. This notice may not be removed or altered from any source distribution.
+ */
+
+#define JPEG_INTERNALS
+#include "jsimd_rvv.h"
+
+#define CONST_BITS 13
+#define PASS1_BITS 2
+
+#define F_0_298 2446  /* 0.298631336 =  2446 * 2^-13 */
+#define F_0_390 3196  /* 0.390180644 =  3196 * 2^-13 */
+#define F_0_541 4433  /* 0.541196100 =  4433 * 2^-13 */
+#define F_0_765 6270  /* 0.765366865 =  6270 * 2^-13 */
+#define F_0_899 7373  /* 0.899976223 =  7373 * 2^-13 */
+#define F_1_175 9633  /* 1.175875602 =  9633 * 2^-13 */
+#define F_1_501 12299 /* 1.501321110 = 12299 * 2^-13 */
+#define F_1_847 15137 /* 1.847759065 = 15137 * 2^-13 */
+#define F_1_961 16069 /* 1.961570560 = 16069 * 2^-13 */
+#define F_2_053 16819 /* 2.053119869 = 16819 * 2^-13 */
+#define F_2_562 20995 /* 2.562915447 = 20995 * 2^-13 */
+#define F_3_072 25172 /* 3.072711026 = 25172 * 2^-13 */
+
+#define F_1_175_MINUS_1_961 (F_1_175 - F_1_961)
+#define F_1_175_MINUS_0_390 (F_1_175 - F_0_390)
+#define F_0_541_MINUS_1_847 (F_0_541 - F_1_847)
+#define F_3_072_MINUS_2_562 (F_3_072 - F_2_562)
+#define F_0_298_MINUS_0_899 (F_0_298 - F_0_899)
+#define F_1_501_MINUS_0_899 (F_1_501 - F_0_899)
+#define F_2_053_MINUS_2_562 (F_2_053 - F_2_562)
+#define F_0_541_PLUS_0_765 (F_0_541 + F_0_765)
+
+#define ROUND_ADD(n) (int32_t)1 << ((n)-1)
+
+#define DO_REGULAR_IDCT_0(in)                                    \
+    {                                                            \
+        /* Even part */                                          \
+        z1 = __riscv_vwadd_vv_i32m1(in##2, in##6, vl);           \
+        z1 = __riscv_vmul_vx_i32m1(z1, F_0_541, vl);             \
+        tmp2 = __riscv_vwmacc_vx_i32m1(z1, -F_1_847, in##6, vl); \
+        tmp3 = __riscv_vwmacc_vx_i32m1(z1, F_0_765, in##2, vl);  \
+                                                                 \
+        tmp0 = __riscv_vwadd_vv_i32m1(in##0, in##4, vl);         \
+        tmp1 = __riscv_vwsub_vv_i32m1(in##0, in##4, vl);         \
+        tmp0 = __riscv_vsll_vx_i32m1(tmp0, CONST_BITS, vl);      \
+        tmp1 = __riscv_vsll_vx_i32m1(tmp1, CONST_BITS, vl);      \
+    }
+
+#define DO_REGULAR_IDCT_1(in)                              \
+    {                                                      \
+        tmp10 = __riscv_vadd_vv_i32m1(tmp0, tmp3, vl);     \
+        tmp13 = __riscv_vsub_vv_i32m1(tmp0, tmp3, vl);     \
+        tmp11 = __riscv_vadd_vv_i32m1(tmp1, tmp2, vl);     \
+        tmp12 = __riscv_vsub_vv_i32m1(tmp1, tmp2, vl);     \
+                                                           \
+        /* Odd Part */                                     \
+        z1 = __riscv_vwadd_vv_i32m1(in##7, in##1, vl);     \
+        z2 = __riscv_vwadd_vv_i32m1(in##5, in##3, vl);     \
+        z3 = __riscv_vwadd_vv_i32m1(in##7, in##3, vl);     \
+        z4 = __riscv_vwadd_vv_i32m1(in##5, in##1, vl);     \
+        z5 = __riscv_vadd_vv_i32m1(z3, z4, vl);            \
+        z5 = __riscv_vmul_vx_i32m1(z5, F_1_175, vl);       \
+                                                           \
+        tmp0 = __riscv_vwmul_vx_i32m1(in##7, F_0_298, vl); \
+        tmp1 = __riscv_vwmul_vx_i32m1(in##5, F_2_053, vl); \
+        tmp2 = __riscv_vwmul_vx_i32m1(in##3, F_3_072, vl); \
+        tmp3 = __riscv_vwmul_vx_i32m1(in##1, F_1_501, vl); \
+        z1 = __riscv_vmul_vx_i32m1(z1, -F_0_899, vl);      \
+        z2 = __riscv_vmul_vx_i32m1(z2, -F_2_562, vl);      \
+        z3 = __riscv_vmul_vx_i32m1(z3, -F_1_961, vl);      \
+        z4 = __riscv_vmul_vx_i32m1(z4, -F_0_390, vl);      \
+                                                           \
+        z3 = __riscv_vadd_vv_i32m1(z3, z5, vl);            \
+        z4 = __riscv_vadd_vv_i32m1(z4, z5, vl);            \
+                                                           \
+        tmp0 = __riscv_vadd_vv_i32m1(tmp0, z1, vl);        \
+        tmp0 = __riscv_vadd_vv_i32m1(tmp0, z3, vl);        \
+        tmp1 = __riscv_vadd_vv_i32m1(tmp1, z2, vl);        \
+        tmp1 = __riscv_vadd_vv_i32m1(tmp1, z4, vl);        \
+        tmp2 = __riscv_vadd_vv_i32m1(tmp2, z2, vl);        \
+        tmp2 = __riscv_vadd_vv_i32m1(tmp2, z3, vl);        \
+        tmp3 = __riscv_vadd_vv_i32m1(tmp3, z1, vl);        \
+        tmp3 = __riscv_vadd_vv_i32m1(tmp3, z4, vl);        \
+    }
+
+#define DO_SPARSE_IDCT_0(in)                                          \
+    {                                                                 \
+        /* Even part */                                               \
+        tmp2 = __riscv_vwmul_vx_i32m1(in##2, F_0_541, vl);            \
+        tmp3 = __riscv_vwmul_vx_i32m1(in##2, F_0_541_PLUS_0_765, vl); \
+                                                                      \
+        tmp0 = __riscv_vwadd_vv_i32m1(in##0, in##4, vl);              \
+        tmp1 = __riscv_vwsub_vv_i32m1(in##0, in##4, vl);              \
+        tmp0 = __riscv_vsll_vx_i32m1(tmp0, CONST_BITS, vl);           \
+        tmp1 = __riscv_vsll_vx_i32m1(tmp1, CONST_BITS, vl);           \
+    }
+
+#define DO_SPARSE_IDCT_1(in)                                                \
+    {                                                                       \
+        tmp10 = __riscv_vadd_vv_i32m1(tmp0, tmp3, vl);                      \
+        tmp13 = __riscv_vsub_vv_i32m1(tmp0, tmp3, vl);                      \
+        tmp11 = __riscv_vadd_vv_i32m1(tmp1, tmp2, vl);                      \
+        tmp12 = __riscv_vsub_vv_i32m1(tmp1, tmp2, vl);                      \
+                                                                            \
+        /* Odd Part */                                                      \
+        z3 = __riscv_vwmul_vx_i32m1(in##3, F_1_175_MINUS_1_961, vl);        \
+        z4 = __riscv_vwmul_vx_i32m1(in##3, F_1_175, vl);                    \
+        z3 = __riscv_vwmacc_vx_i32m1(z3, F_1_175, in##1, vl);               \
+        z4 = __riscv_vwmacc_vx_i32m1(z4, F_1_175_MINUS_0_390, in##1, vl);   \
+                                                                            \
+        tmp0 = __riscv_vwmacc_vx_i32m1(z3, -F_0_899, in##1, vl);            \
+        tmp1 = __riscv_vwmacc_vx_i32m1(z4, -F_2_562, in##3, vl);            \
+        tmp2 = __riscv_vwmacc_vx_i32m1(z3, F_3_072_MINUS_2_562, in##3, vl); \
+        tmp3 = __riscv_vwmacc_vx_i32m1(z4, F_1_501_MINUS_0_899, in##1, vl); \
+    }
+
+#define OUTPUT(bm)                                   \
+    {                                                \
+        o0 = __riscv_vadd_vv_i32m1(tmp10, tmp3, vl); \
+        o7 = __riscv_vsub_vv_i32m1(tmp10, tmp3, vl); \
+                                                     \
+        o1 = __riscv_vadd_vv_i32m1(tmp11, tmp2, vl); \
+        o6 = __riscv_vsub_vv_i32m1(tmp11, tmp2, vl); \
+                                                     \
+        o2 = __riscv_vadd_vv_i32m1(tmp12, tmp1, vl); \
+        o5 = __riscv_vsub_vv_i32m1(tmp12, tmp1, vl); \
+                                                     \
+        o3 = __riscv_vadd_vv_i32m1(tmp13, tmp0, vl); \
+        o4 = __riscv_vsub_vv_i32m1(tmp13, tmp0, vl); \
+                                                     \
+        out2 = __riscv_vnsra_wx_i16mf2(o2, bm, vl);  \
+        out1 = __riscv_vnsra_wx_i16mf2(o1, bm, vl);  \
+        out6 = __riscv_vnsra_wx_i16mf2(o6, bm, vl);  \
+        out5 = __riscv_vnsra_wx_i16mf2(o5, bm, vl);  \
+        out0 = __riscv_vnsra_wx_i16mf2(o0, bm, vl);  \
+        out7 = __riscv_vnsra_wx_i16mf2(o7, bm, vl);  \
+        out3 = __riscv_vnsra_wx_i16mf2(o3, bm, vl);  \
+        out4 = __riscv_vnsra_wx_i16mf2(o4, bm, vl);  \
+    }
+
+#define STORE_ROW_LOAD_COL()                                           \
+    {                                                                  \
+        __riscv_vse16_v_i16mf2(workspace + DCTSIZE * 0, out0, vl);     \
+        __riscv_vse16_v_i16mf2(workspace + DCTSIZE * 1, out1, vl);     \
+        __riscv_vse16_v_i16mf2(workspace + DCTSIZE * 2, out2, vl);     \
+        __riscv_vse16_v_i16mf2(workspace + DCTSIZE * 3, out3, vl);     \
+        __riscv_vse16_v_i16mf2(workspace + DCTSIZE * 4, out4, vl);     \
+        __riscv_vse16_v_i16mf2(workspace + DCTSIZE * 5, out5, vl);     \
+        __riscv_vse16_v_i16mf2(workspace + DCTSIZE * 6, out6, vl);     \
+        __riscv_vse16_v_i16mf2(workspace + DCTSIZE * 7, out7, vl);     \
+                                                                       \
+        col0 = __riscv_vlse16_v_i16mf2(workspace + 0, col_stride, vl); \
+        col1 = __riscv_vlse16_v_i16mf2(workspace + 1, col_stride, vl); \
+        col2 = __riscv_vlse16_v_i16mf2(workspace + 2, col_stride, vl); \
+        col3 = __riscv_vlse16_v_i16mf2(workspace + 3, col_stride, vl); \
+        col4 = __riscv_vlse16_v_i16mf2(workspace + 4, col_stride, vl); \
+        col5 = __riscv_vlse16_v_i16mf2(workspace + 5, col_stride, vl); \
+        col6 = __riscv_vlse16_v_i16mf2(workspace + 6, col_stride, vl); \
+        col7 = __riscv_vlse16_v_i16mf2(workspace + 7, col_stride, vl); \
+    }
+
+void jsimd_idct_islow_rvv(void *dct_table, JCOEFPTR coef_block,
+                          JSAMPARRAY output_buf, JDIMENSION output_col)
+{
+    int col_stride = DCTSIZE * sizeof(DCTELEM);
+    int bm0 = CONST_BITS - PASS1_BITS;
+    int bm1 = CONST_BITS + PASS1_BITS + 3;
+    int32_t bias0 = ROUND_ADD(CONST_BITS - PASS1_BITS);
+    int32_t bias1 = ROUND_ADD(CONST_BITS + PASS1_BITS + 3);
+    size_t stride[8];
+    size_t vl = __riscv_vsetvl_e16m2(DCTSIZE);
+    ISLOW_MULT_TYPE *quantptr = dct_table;
+    DCTELEM workspace[DCTSIZE2];
+    JSAMPROW output_row = output_buf[0] + output_col;
+
+    stride[0] = 0;
+    for (int i = 1; i < 8; ++i)
+    {
+        stride[i] = output_buf[i] - output_buf[0];
+    }
+
+    vbool32_t beq0;
+    vint16mf2_t bit;
+    vint8mf4_t dst0, dst1, dst2, dst3, dst4, dst5, dst6, dst7;
+    vint16mf2_t row0, row1, row2, row3, row4, row5, row6, row7;
+    vint16mf2_t col0, col1, col2, col3, col4, col5, col6, col7;
+    vint16mf2_t out0, out1, out2, out3, out4, out5, out6, out7;
+    vint16mf2_t quant0, quant1, quant2, quant3, quant4, quant5, quant6, quant7;
+    vint32m1_t z1, z2, z3, z4, z5;
+    vint32m1_t tmp0, tmp1, tmp2, tmp3, tmp4;
+    vint32m1_t tmp10, tmp11, tmp12, tmp13;
+    vint32m1_t o0, o1, o2, o3, o4, o5, o6, o7;
+
+    /* Pass 1: process columns from input, store into work array. */
+    /* Load DCT coefficients. */
+    row0 = __riscv_vle16_v_i16mf2(coef_block + DCTSIZE * 0, vl);
+    row1 = __riscv_vle16_v_i16mf2(coef_block + DCTSIZE * 1, vl);
+    row2 = __riscv_vle16_v_i16mf2(coef_block + DCTSIZE * 2, vl);
+    row3 = __riscv_vle16_v_i16mf2(coef_block + DCTSIZE * 3, vl);
+    row4 = __riscv_vle16_v_i16mf2(coef_block + DCTSIZE * 4, vl);
+    row5 = __riscv_vle16_v_i16mf2(coef_block + DCTSIZE * 5, vl);
+    row6 = __riscv_vle16_v_i16mf2(coef_block + DCTSIZE * 6, vl);
+    row7 = __riscv_vle16_v_i16mf2(coef_block + DCTSIZE * 7, vl);
+
+    bit = __riscv_vor_vv_i16mf2(row4, row5, vl);
+    bit = __riscv_vor_vv_i16mf2(bit, row6, vl);
+    bit = __riscv_vor_vv_i16mf2(bit, row7, vl);
+    beq0 = __riscv_vmseq_vx_i16mf2_b32(bit, 0, vl);
+    unsigned long row4567_cpop0 = __riscv_vcpop_m_b32(beq0, vl);
+
+    bit = __riscv_vor_vv_i16mf2(row1, row2, vl);
+    bit = __riscv_vor_vv_i16mf2(bit, row3, vl);
+    beq0 = __riscv_vmseq_vx_i16mf2_b32(bit, 0, vl);
+    unsigned long row123_cpop0 = __riscv_vcpop_m_b32(beq0, vl);
+
+    if (8 == row123_cpop0 && 8 == row4567_cpop0)
+    {
+        /* Load quantization table values for DC coefficients. */
+        quant0 = __riscv_vle16_v_i16mf2(quantptr + 0 * DCTSIZE, vl);
+        row0 = __riscv_vmul_vv_i16mf2(row0, quant0, vl);
+        row0 = __riscv_vsll_vx_i16mf2(row0, PASS1_BITS, vl);
+
+        /* Store rows */
+        __riscv_vse16_v_i16mf2(workspace + DCTSIZE * 0, row0, vl);
+
+        col0 = __riscv_vmv_v_x_i16mf2(workspace[0], vl);
+        col1 = __riscv_vmv_v_x_i16mf2(workspace[1], vl);
+        col2 = __riscv_vmv_v_x_i16mf2(workspace[2], vl);
+        col3 = __riscv_vmv_v_x_i16mf2(workspace[3], vl);
+        col4 = __riscv_vmv_v_x_i16mf2(workspace[4], vl);
+        col5 = __riscv_vmv_v_x_i16mf2(workspace[5], vl);
+        col6 = __riscv_vmv_v_x_i16mf2(workspace[6], vl);
+        col7 = __riscv_vmv_v_x_i16mf2(workspace[7], vl);
+    }
+    else
+    {
+        if (8 == row4567_cpop0)
+        {
+            quant0 = __riscv_vle16_v_i16mf2(quantptr + 0 * DCTSIZE, vl);
+            quant1 = __riscv_vle16_v_i16mf2(quantptr + 1 * DCTSIZE, vl);
+            quant2 = __riscv_vle16_v_i16mf2(quantptr + 2 * DCTSIZE, vl);
+            quant3 = __riscv_vle16_v_i16mf2(quantptr + 3 * DCTSIZE, vl);
+            row0 = __riscv_vmul_vv_i16mf2(row0, quant0, vl);
+            row1 = __riscv_vmul_vv_i16mf2(row1, quant1, vl);
+            row2 = __riscv_vmul_vv_i16mf2(row2, quant2, vl);
+            row3 = __riscv_vmul_vv_i16mf2(row3, quant3, vl);
+
+            DO_SPARSE_IDCT_0(row);
+            /* early bias addition for better performance */
+            tmp0 = __riscv_vadd_vx_i32m1(tmp0, bias0, vl);
+            tmp1 = __riscv_vadd_vx_i32m1(tmp1, bias0, vl);
+            DO_SPARSE_IDCT_1(row);
+        }
+        else
+        {
+            /* Load quantization table values for DC coefficients. */
+            quant0 = __riscv_vle16_v_i16mf2(quantptr + 0 * DCTSIZE, vl);
+            quant1 = __riscv_vle16_v_i16mf2(quantptr + 1 * DCTSIZE, vl);
+            quant2 = __riscv_vle16_v_i16mf2(quantptr + 2 * DCTSIZE, vl);
+            quant3 = __riscv_vle16_v_i16mf2(quantptr + 3 * DCTSIZE, vl);
+            quant4 = __riscv_vle16_v_i16mf2(quantptr + 4 * DCTSIZE, vl);
+            quant5 = __riscv_vle16_v_i16mf2(quantptr + 5 * DCTSIZE, vl);
+            quant6 = __riscv_vle16_v_i16mf2(quantptr + 6 * DCTSIZE, vl);
+            quant7 = __riscv_vle16_v_i16mf2(quantptr + 7 * DCTSIZE, vl);
+
+            row0 = __riscv_vmul_vv_i16mf2(row0, quant0, vl);
+            row1 = __riscv_vmul_vv_i16mf2(row1, quant1, vl);
+            row2 = __riscv_vmul_vv_i16mf2(row2, quant2, vl);
+            row3 = __riscv_vmul_vv_i16mf2(row3, quant3, vl);
+            row4 = __riscv_vmul_vv_i16mf2(row4, quant4, vl);
+            row5 = __riscv_vmul_vv_i16mf2(row5, quant5, vl);
+            row6 = __riscv_vmul_vv_i16mf2(row6, quant6, vl);
+            row7 = __riscv_vmul_vv_i16mf2(row7, quant7, vl);
+
+            DO_REGULAR_IDCT_0(row);
+            /* early bias addition for better performance */
+            tmp0 = __riscv_vadd_vx_i32m1(tmp0, bias0, vl);
+            tmp1 = __riscv_vadd_vx_i32m1(tmp1, bias0, vl);
+            DO_REGULAR_IDCT_1(row);
+        }
+        OUTPUT(bm0);
+        STORE_ROW_LOAD_COL();
+    }
+
+    /* Second pass: compute IDCT on rows in workspace. */
+    bit = __riscv_vor_vv_i16mf2(col4, col5, vl);
+    bit = __riscv_vor_vv_i16mf2(bit, col6, vl);
+    bit = __riscv_vor_vv_i16mf2(bit, col7, vl);
+    beq0 = __riscv_vmseq_vx_i16mf2_b32(bit, 0, vl);
+    unsigned long col4567_cpop0 = __riscv_vcpop_m_b32(beq0, vl);
+
+    if (8 == col4567_cpop0)
+    {
+        DO_SPARSE_IDCT_0(col);
+        tmp0 = __riscv_vadd_vx_i32m1(tmp0, bias1, vl);
+        tmp0 = __riscv_vadd_vx_i32m1(tmp0, CENTERJSAMPLE << bm1, vl);
+        tmp1 = __riscv_vadd_vx_i32m1(tmp1, bias1, vl);
+        tmp1 = __riscv_vadd_vx_i32m1(tmp1, CENTERJSAMPLE << bm1, vl);
+        DO_SPARSE_IDCT_1(col);
+    }
+    else
+    {
+        DO_REGULAR_IDCT_0(col);
+        /* early bias addition for better performance */
+        tmp0 = __riscv_vadd_vx_i32m1(tmp0, bias1, vl);
+        tmp0 = __riscv_vadd_vx_i32m1(tmp0, CENTERJSAMPLE << bm1, vl);
+        tmp1 = __riscv_vadd_vx_i32m1(tmp1, bias1, vl);
+        tmp1 = __riscv_vadd_vx_i32m1(tmp1, CENTERJSAMPLE << bm1, vl);
+        DO_REGULAR_IDCT_1(col);
+    }
+    OUTPUT(bm1);
+
+    CLIP(out0, i16mf2);
+    CLIP(out1, i16mf2);
+    CLIP(out2, i16mf2);
+    CLIP(out3, i16mf2);
+    CLIP(out4, i16mf2);
+    CLIP(out5, i16mf2);
+    CLIP(out6, i16mf2);
+    CLIP(out7, i16mf2);
+
+    dst0 = __riscv_vncvt_x_x_w_i8mf4(out0, vl);
+    dst1 = __riscv_vncvt_x_x_w_i8mf4(out1, vl);
+    dst2 = __riscv_vncvt_x_x_w_i8mf4(out2, vl);
+    dst3 = __riscv_vncvt_x_x_w_i8mf4(out3, vl);
+    dst4 = __riscv_vncvt_x_x_w_i8mf4(out4, vl);
+    dst5 = __riscv_vncvt_x_x_w_i8mf4(out5, vl);
+    dst6 = __riscv_vncvt_x_x_w_i8mf4(out6, vl);
+    dst7 = __riscv_vncvt_x_x_w_i8mf4(out7, vl);
+
+    /* store columns */
+    vuint64m2_t vstride = __riscv_vle64_v_u64m2(stride, vl);
+    __riscv_vsoxei64_v_i8mf4(output_row + 0, vstride, dst0, vl);
+    __riscv_vsoxei64_v_i8mf4(output_row + 1, vstride, dst1, vl);
+    __riscv_vsoxei64_v_i8mf4(output_row + 2, vstride, dst2, vl);
+    __riscv_vsoxei64_v_i8mf4(output_row + 3, vstride, dst3, vl);
+    __riscv_vsoxei64_v_i8mf4(output_row + 4, vstride, dst4, vl);
+    __riscv_vsoxei64_v_i8mf4(output_row + 5, vstride, dst5, vl);
+    __riscv_vsoxei64_v_i8mf4(output_row + 6, vstride, dst6, vl);
+    __riscv_vsoxei64_v_i8mf4(output_row + 7, vstride, dst7, vl);
+}
\ No newline at end of file
diff --git a/simd/rvv/jidctred-rvv.c b/simd/rvv/jidctred-rvv.c
new file mode 100644
index 0000000..ddee39b
--- /dev/null
+++ b/simd/rvv/jidctred-rvv.c
@@ -0,0 +1,353 @@
+/*
+ * jidctred-rvv.c - reduced-size IDCT
+ *
+ * Copyright (C) 2023, Spacemit, Inc.  All Rights Reserved.
+ * Contributed by Liang Junzhao <junzhao.liang@spacemit.com>
+ *
+ * This software is provided 'as-is', without any express or implied
+ * warranty.  In no event will the authors be held liable for any damages
+ * arising from the use of this software.
+ *
+ * Permission is granted to anyone to use this software for any purpose,
+ * including commercial applications, and to alter it and redistribute it
+ * freely, subject to the following restrictions:
+ *
+ * 1. The origin of this software must not be misrepresented; you must not
+ *    claim that you wrote the original software. If you use this software
+ *    in a product, an acknowledgment in the product documentation would be
+ *    appreciated but is not required.
+ * 2. Altered source versions must be plainly marked as such, and must not be
+ *    misrepresented as being the original software.
+ * 3. This notice may not be removed or altered from any source distribution.
+ */
+
+#define JPEG_INTERNALS
+#include "jsimd_rvv.h"
+
+#define CONST_BITS 13
+#define PASS1_BITS 2
+
+#define F_0_720 5906  /* 0.720959822 =  5906 * 2^-13 */
+#define F_0_850 6967  /* 0.850430095 =  6967 * 2^-13 */
+#define F_1_272 10426 /* 1.272758580 = 10426 * 2^-13 */
+#define F_3_624 29692 /* 3.624509785 = 29692 * 2^-13 */
+
+#define ONE_HALF 1 << (CONST_BITS - 1)
+#define bstride sizeof(JCOEF)
+
+static const uint8_t index_1155_high[2] = {5 * bstride, 13 * bstride};
+static const uint8_t index_1155_low[2] = {1 * bstride, 9 * bstride};
+static const uint8_t index_3377_high[2] = {7 * bstride, 15 * bstride};
+static const uint8_t index_3377_low[2] = {3 * bstride, 11 * bstride};
+static const uint8_t index_0246_low[2] = {0 * bstride, 8 * bstride};
+
+void jsimd_idct_2x2_rvv(void *dct_table, JCOEFPTR coef_block,
+                        JSAMPARRAY output_buf, JDIMENSION output_col)
+{
+    size_t vl = __riscv_vsetvl_e16mf2(DCTSIZE);
+    size_t vl_2 = vl >> 2;
+    ISLOW_MULT_TYPE *quantptr = dct_table;
+
+    vuint8mf4_t bindex;
+    vint8mf4_t tmp_l_8, tmp_h_8;
+    vint16mf2_t row0, row1, row3, row5, row7;
+    vint16mf2_t quant_row0, quant_row1, quant_row3, quant_row5, quant_row7;
+    vint16mf2_t cols_1155_low, cols_1155_high, cols_3377_low, cols_3377_high, cols_0246_low;
+    vint16mf2_t tmp_l_16, tmp_h_16;
+    vint32m1_t tmp0, tmp10, tmp, tmp_l, tmp_h;
+
+    /* Load DCT coefficients. */
+    row0 = __riscv_vle16_v_i16mf2(coef_block + 0 * DCTSIZE, vl);
+    row1 = __riscv_vle16_v_i16mf2(coef_block + 1 * DCTSIZE, vl);
+    row3 = __riscv_vle16_v_i16mf2(coef_block + 3 * DCTSIZE, vl);
+    row5 = __riscv_vle16_v_i16mf2(coef_block + 5 * DCTSIZE, vl);
+    row7 = __riscv_vle16_v_i16mf2(coef_block + 7 * DCTSIZE, vl);
+
+    /* Load quantization table values. */
+    quant_row0 = __riscv_vle16_v_i16mf2(quantptr + 0 * DCTSIZE, vl);
+    quant_row1 = __riscv_vle16_v_i16mf2(quantptr + 1 * DCTSIZE, vl);
+    quant_row3 = __riscv_vle16_v_i16mf2(quantptr + 3 * DCTSIZE, vl);
+    quant_row5 = __riscv_vle16_v_i16mf2(quantptr + 5 * DCTSIZE, vl);
+    quant_row7 = __riscv_vle16_v_i16mf2(quantptr + 7 * DCTSIZE, vl);
+
+    /* Dequantize DCT coefficients. */
+    row0 = __riscv_vmul_vv_i16mf2(row0, quant_row0, vl);
+    row1 = __riscv_vmul_vv_i16mf2(row1, quant_row1, vl);
+    row3 = __riscv_vmul_vv_i16mf2(row3, quant_row3, vl);
+    row5 = __riscv_vmul_vv_i16mf2(row5, quant_row5, vl);
+    row7 = __riscv_vmul_vv_i16mf2(row7, quant_row7, vl);
+
+    /* Pass 1: process columns from input, put results in vectors row0 and row1. */
+
+    /* Even part */
+    tmp10 = __riscv_vwcvt_x_x_v_i32m1(row0, vl);
+    tmp10 = __riscv_vsll_vx_i32m1(tmp10, CONST_BITS + 2, vl);
+
+    /* Odd part */
+    tmp0 = __riscv_vwmul_vx_i32m1(row1, F_3_624, vl);
+    tmp0 = __riscv_vwmacc_vx_i32m1(tmp0, -F_1_272, row3, vl);
+    tmp0 = __riscv_vwmacc_vx_i32m1(tmp0, F_0_850, row5, vl);
+    tmp0 = __riscv_vwmacc_vx_i32m1(tmp0, -F_0_720, row7, vl);
+
+    /* Final output stage: descale and narrow to 16-bit. */
+    tmp = __riscv_vadd_vv_i32m1(tmp10, tmp0, vl);
+    tmp = __riscv_vadd_vx_i32m1(tmp, ONE_HALF, vl);
+    row0 = __riscv_vnsra_wx_i16mf2(tmp, CONST_BITS, vl);
+
+    tmp = __riscv_vsub_vv_i32m1(tmp10, tmp0, vl);
+    tmp = __riscv_vadd_vx_i32m1(tmp, ONE_HALF, vl);
+    row1 = __riscv_vnsra_wx_i16mf2(tmp, CONST_BITS, vl);
+
+    /* Transpose two rows, ready for second pass. */
+    __riscv_vse16_v_i16mf2(coef_block + 0 * DCTSIZE, row0, vl);
+    __riscv_vse16_v_i16mf2(coef_block + 1 * DCTSIZE, row1, vl);
+
+    bindex = __riscv_vle8_v_u8mf4(index_1155_low, vl_2);
+    cols_1155_low = __riscv_vloxei8_v_i16mf2(coef_block, bindex, vl_2);
+    bindex = __riscv_vle8_v_u8mf4(index_1155_high, vl_2);
+    cols_1155_high = __riscv_vloxei8_v_i16mf2(coef_block, bindex, vl_2);
+
+    bindex = __riscv_vle8_v_u8mf4(index_3377_low, vl_2);
+    cols_3377_low = __riscv_vloxei8_v_i16mf2(coef_block, bindex, vl_2);
+    bindex = __riscv_vle8_v_u8mf4(index_3377_high, vl_2);
+    cols_3377_high = __riscv_vloxei8_v_i16mf2(coef_block, bindex, vl_2);
+
+    bindex = __riscv_vle8_v_u8mf4(index_0246_low, vl_2);
+    cols_0246_low = __riscv_vloxei8_v_i16mf2(coef_block, bindex, vl_2);
+
+    /* Pass 2: process two rows, store to output array. */
+
+    /* Even part: we're only interested in col0; the top half of tmp10 is "don't care." */
+    tmp10 = __riscv_vwcvt_x_x_v_i32m1(cols_0246_low, vl_2);
+    tmp10 = __riscv_vsll_vx_i32m1(tmp10, CONST_BITS + 2, vl_2);
+
+    /* Odd part: we're only interested in the bottom half of tmp0. */
+    tmp0 = __riscv_vwmul_vx_i32m1(cols_1155_low, F_3_624, vl_2);
+    tmp0 = __riscv_vwmacc_vx_i32m1(tmp0, -F_1_272, cols_3377_low, vl_2);
+    tmp0 = __riscv_vwmacc_vx_i32m1(tmp0, F_0_850, cols_1155_high, vl_2);
+    tmp0 = __riscv_vwmacc_vx_i32m1(tmp0, -F_0_720, cols_3377_high, vl_2);
+
+    /* Final output stage: descale and clamp to range [0-255]. */
+    tmp_l = __riscv_vadd_vv_i32m1(tmp10, tmp0, vl_2);
+    tmp_h = __riscv_vsub_vv_i32m1(tmp10, tmp0, vl_2);
+
+    tmp_l = __riscv_vadd_vx_i32m1(tmp_l, (1 << (CONST_BITS + PASS1_BITS + 3 + 2 - 1)) + (CENTERJSAMPLE << (CONST_BITS + PASS1_BITS + 3 + 2)), vl_2);
+    tmp_h = __riscv_vadd_vx_i32m1(tmp_h, (1 << (CONST_BITS + PASS1_BITS + 3 + 2 - 1)) + (CENTERJSAMPLE << (CONST_BITS + PASS1_BITS + 3 + 2)), vl_2);
+
+    tmp_l_16 = __riscv_vnsra_wx_i16mf2(tmp_l, CONST_BITS + PASS1_BITS + 3 + 2, vl_2);
+    tmp_h_16 = __riscv_vnsra_wx_i16mf2(tmp_h, CONST_BITS + PASS1_BITS + 3 + 2, vl_2);
+
+    CLIP(tmp_l_16, i16mf2);
+    CLIP(tmp_h_16, i16mf2);
+
+    tmp_l_8 = __riscv_vncvt_x_x_w_i8mf4(tmp_l_16, vl_2);
+    tmp_h_8 = __riscv_vncvt_x_x_w_i8mf4(tmp_h_16, vl_2);
+
+    __riscv_vsse8_v_i8mf4(output_buf[0] + output_col, (output_buf[1] - output_buf[0]), tmp_l_8, vl_2);
+    __riscv_vsse8_v_i8mf4(output_buf[0] + output_col + 1, (output_buf[1] - output_buf[0]), tmp_h_8, vl_2);
+}
+
+#define F_1_847 15137 /* 1.847759065 = 15137 * 2^-13 */
+#define F_0_765 6270  /* 0.765366865 =  6270 * 2^-13 */
+#define F_0_211 1730  /* 0.211164243 =  1730 * 2^-13 */
+#define F_1_451 11893 /* 1.451774981 = 11893 * 2^-13 */
+#define F_2_172 17799 /* 2.172734803 = 17799 * 2^-13 */
+#define F_1_061 8697  /* 1.061594337 =  8697 * 2^-13 */
+#define F_0_509 4176  /* 0.509795579 =  4176 * 2^-13 */
+#define F_0_601 4926  /* 0.601344887 =  4926 * 2^-13 */
+#define F_0_899 7373  /* 0.899976223 =  7373 * 2^-13 */
+#define F_2_562 20995 /* 2.562915447 = 20995 * 2^-13 */
+
+void jsimd_idct_4x4_rvv(void *dct_table, JCOEFPTR coef_block,
+                        JSAMPARRAY output_buf, JDIMENSION output_col)
+{
+    int col_stride = DCTSIZE * sizeof(DCTELEM);
+    size_t stride[4];
+    size_t vl = __riscv_vsetvl_e16mf2(DCTSIZE);
+    size_t vl_2 = vl >> 1;
+    DCTELEM workspace[DCTSIZE2 / 2];
+    ISLOW_MULT_TYPE *quantptr = dct_table;
+    JSAMPROW output_row = output_buf[0] + output_col;
+
+    stride[0] = 0;
+    for (int i = 1; i < 4; ++i)
+    {
+        stride[i] = output_buf[i] - output_buf[0];
+    }
+
+    vbool32_t beq0;
+    vint8mf4_t cols_02_low_8, cols_02_high_8, cols_13_low_8, cols_13_high_8;
+    vint16mf2_t bit;
+    vint16mf2_t z1, z2, z3, z4;
+    vint16mf2_t row0, row1, row2, row3, row5, row6, row7;
+    vint16mf2_t col0, col1, col2, col3, col5, col6, col7;
+    vint16mf2_t quant0, quant1, quant2, quant3, quant4, quant5, quant6, quant7;
+    vint16mf2_t cols_02_low_16, cols_02_high_16, cols_13_low_16, cols_13_high_16;
+    vint32m1_t o0, o1, o2, o3, o4, o5, o6, o7;
+    vint32m1_t tmp0, tmp2, tmp10, tmp12;
+    vint32m1_t cols_02_low_32, cols_02_high_32, cols_13_low_32, cols_13_high_32;
+
+    /* Load DCT coefficients. */
+    row0 = __riscv_vle16_v_i16mf2(coef_block + 0 * DCTSIZE, vl);
+    row1 = __riscv_vle16_v_i16mf2(coef_block + 1 * DCTSIZE, vl);
+    row2 = __riscv_vle16_v_i16mf2(coef_block + 2 * DCTSIZE, vl);
+    row3 = __riscv_vle16_v_i16mf2(coef_block + 3 * DCTSIZE, vl);
+    row5 = __riscv_vle16_v_i16mf2(coef_block + 5 * DCTSIZE, vl);
+    row6 = __riscv_vle16_v_i16mf2(coef_block + 6 * DCTSIZE, vl);
+    row7 = __riscv_vle16_v_i16mf2(coef_block + 7 * DCTSIZE, vl);
+
+    bit = __riscv_vor_vv_i16mf2(row1, row2, vl);
+    bit = __riscv_vor_vv_i16mf2(bit, row3, vl);
+    bit = __riscv_vor_vv_i16mf2(bit, row5, vl);
+    bit = __riscv_vor_vv_i16mf2(bit, row6, vl);
+    bit = __riscv_vor_vv_i16mf2(bit, row7, vl);
+    beq0 = __riscv_vmseq_vx_i16mf2_b32(bit, 0, vl);
+    unsigned long row1234567_cpop0 = __riscv_vcpop_m_b32(beq0, vl);
+
+    if (8 == row1234567_cpop0)
+    {
+        /* Load quantization table values for DC coefficients. */
+        quant0 = __riscv_vle16_v_i16mf2(quantptr + 0 * DCTSIZE, vl);
+        row0 = __riscv_vmul_vv_i16mf2(row0, quant0, vl);
+        row0 = __riscv_vsll_vx_i16mf2(row0, PASS1_BITS, vl);
+        row1 = row0;
+        row2 = row0;
+        row3 = row0;
+
+        /* Store rows */
+        __riscv_vse16_v_i16mf2(workspace + DCTSIZE * 0, row0, vl);
+
+        col0 = __riscv_vmv_v_x_i16mf2(workspace[0], vl);
+        col1 = __riscv_vmv_v_x_i16mf2(workspace[1], vl);
+        col2 = __riscv_vmv_v_x_i16mf2(workspace[2], vl);
+        col3 = __riscv_vmv_v_x_i16mf2(workspace[3], vl);
+        col5 = __riscv_vmv_v_x_i16mf2(workspace[5], vl);
+        col6 = __riscv_vmv_v_x_i16mf2(workspace[6], vl);
+        col7 = __riscv_vmv_v_x_i16mf2(workspace[7], vl);
+    }
+    else
+    {
+        quant0 = __riscv_vle16_v_i16mf2(quantptr + 0 * DCTSIZE, vl);
+        quant1 = __riscv_vle16_v_i16mf2(quantptr + 1 * DCTSIZE, vl);
+        quant2 = __riscv_vle16_v_i16mf2(quantptr + 2 * DCTSIZE, vl);
+        quant3 = __riscv_vle16_v_i16mf2(quantptr + 3 * DCTSIZE, vl);
+        quant5 = __riscv_vle16_v_i16mf2(quantptr + 5 * DCTSIZE, vl);
+        quant6 = __riscv_vle16_v_i16mf2(quantptr + 6 * DCTSIZE, vl);
+        quant7 = __riscv_vle16_v_i16mf2(quantptr + 7 * DCTSIZE, vl);
+
+        /* Even part */
+        tmp0 = __riscv_vwmul_vv_i32m1(row0, quant0, vl);
+        tmp0 = __riscv_vsll_vx_i32m1(tmp0, CONST_BITS + 1, vl);
+
+        z2 = __riscv_vmul_vv_i16mf2(row2, quant2, vl);
+        z3 = __riscv_vmul_vv_i16mf2(row6, quant6, vl);
+
+        tmp2 = __riscv_vwmul_vx_i32m1(z2, F_1_847, vl);
+        tmp2 = __riscv_vwmacc_vx_i32m1(tmp2, -F_0_765, z3, vl);
+
+        tmp10 = __riscv_vadd_vv_i32m1(tmp0, tmp2, vl);
+        tmp12 = __riscv_vsub_vv_i32m1(tmp0, tmp2, vl);
+
+        /* Odd part */
+        z1 = __riscv_vmul_vv_i16mf2(row7, quant7, vl);
+        z2 = __riscv_vmul_vv_i16mf2(row5, quant5, vl);
+        z3 = __riscv_vmul_vv_i16mf2(row3, quant3, vl);
+        z4 = __riscv_vmul_vv_i16mf2(row1, quant1, vl);
+
+        tmp0 = __riscv_vwmul_vx_i32m1(z1, -F_0_211, vl);
+        tmp0 = __riscv_vwmacc_vx_i32m1(tmp0, F_1_451, z2, vl);
+        tmp0 = __riscv_vwmacc_vx_i32m1(tmp0, -F_2_172, z3, vl);
+        tmp0 = __riscv_vwmacc_vx_i32m1(tmp0, F_1_061, z4, vl);
+
+        tmp2 = __riscv_vwmul_vx_i32m1(z1, -F_0_509, vl);
+        tmp2 = __riscv_vwmacc_vx_i32m1(tmp2, -F_0_601, z2, vl);
+        tmp2 = __riscv_vwmacc_vx_i32m1(tmp2, F_0_899, z3, vl);
+        tmp2 = __riscv_vwmacc_vx_i32m1(tmp2, F_2_562, z4, vl);
+
+        /* Final output stage: descale and narrow to 16-bit. */
+        o0 = __riscv_vadd_vv_i32m1(tmp10, tmp2, vl);
+        o3 = __riscv_vsub_vv_i32m1(tmp10, tmp2, vl);
+        o1 = __riscv_vadd_vv_i32m1(tmp12, tmp0, vl);
+        o2 = __riscv_vsub_vv_i32m1(tmp12, tmp0, vl);
+
+        o0 = __riscv_vadd_vx_i32m1(o0, 1 << CONST_BITS - PASS1_BITS, vl);
+        o3 = __riscv_vadd_vx_i32m1(o3, 1 << CONST_BITS - PASS1_BITS, vl);
+        o1 = __riscv_vadd_vx_i32m1(o1, 1 << CONST_BITS - PASS1_BITS, vl);
+        o2 = __riscv_vadd_vx_i32m1(o2, 1 << CONST_BITS - PASS1_BITS, vl);
+
+        row0 = __riscv_vnsra_wx_i16mf2(o0, CONST_BITS - PASS1_BITS + 1, vl);
+        row3 = __riscv_vnsra_wx_i16mf2(o3, CONST_BITS - PASS1_BITS + 1, vl);
+        row1 = __riscv_vnsra_wx_i16mf2(o1, CONST_BITS - PASS1_BITS + 1, vl);
+        row2 = __riscv_vnsra_wx_i16mf2(o2, CONST_BITS - PASS1_BITS + 1, vl);
+
+        /* Transpose 8x4 block to perform IDCT on rows in second pass. */
+        /* Store rows */
+        __riscv_vse16_v_i16mf2(workspace + DCTSIZE * 0, row0, vl);
+        __riscv_vse16_v_i16mf2(workspace + DCTSIZE * 1, row1, vl);
+        __riscv_vse16_v_i16mf2(workspace + DCTSIZE * 2, row2, vl);
+        __riscv_vse16_v_i16mf2(workspace + DCTSIZE * 3, row3, vl);
+
+        col0 = __riscv_vlse16_v_i16mf2(workspace + 0, col_stride, vl_2);
+        col1 = __riscv_vlse16_v_i16mf2(workspace + 1, col_stride, vl_2);
+        col2 = __riscv_vlse16_v_i16mf2(workspace + 2, col_stride, vl_2);
+        col3 = __riscv_vlse16_v_i16mf2(workspace + 3, col_stride, vl_2);
+        col5 = __riscv_vlse16_v_i16mf2(workspace + 5, col_stride, vl_2);
+        col6 = __riscv_vlse16_v_i16mf2(workspace + 6, col_stride, vl_2);
+        col7 = __riscv_vlse16_v_i16mf2(workspace + 7, col_stride, vl_2);
+    }
+
+    /* Commence second pass of IDCT. */
+
+    /* Even part */
+    tmp0 = __riscv_vwcvt_x_x_v_i32m1(col0, vl_2);
+    tmp0 = __riscv_vsll_vx_i32m1(tmp0, CONST_BITS + 1, vl_2);
+
+    tmp2 = __riscv_vwmul_vx_i32m1(col2, F_1_847, vl_2);
+    tmp2 = __riscv_vwmacc_vx_i32m1(tmp2, -F_0_765, col6, vl_2);
+
+    tmp10 = __riscv_vadd_vv_i32m1(tmp0, tmp2, vl_2);
+    tmp12 = __riscv_vsub_vv_i32m1(tmp0, tmp2, vl_2);
+
+    /* Odd part */
+    tmp0 = __riscv_vwmul_vx_i32m1(col7, -F_0_211, vl_2);
+    tmp0 = __riscv_vwmacc_vx_i32m1(tmp0, F_1_451, col5, vl_2);
+    tmp0 = __riscv_vwmacc_vx_i32m1(tmp0, -F_2_172, col3, vl_2);
+    tmp0 = __riscv_vwmacc_vx_i32m1(tmp0, F_1_061, col1, vl_2);
+
+    tmp2 = __riscv_vwmul_vx_i32m1(col7, -F_0_509, vl_2);
+    tmp2 = __riscv_vwmacc_vx_i32m1(tmp2, -F_0_601, col5, vl_2);
+    tmp2 = __riscv_vwmacc_vx_i32m1(tmp2, F_0_899, col3, vl_2);
+    tmp2 = __riscv_vwmacc_vx_i32m1(tmp2, F_2_562, col1, vl_2);
+
+    /* Final output stage: descale and clamp to range [0-255]. */
+    cols_02_low_32 = __riscv_vadd_vv_i32m1(tmp10, tmp2, vl_2);
+    cols_02_high_32 = __riscv_vsub_vv_i32m1(tmp12, tmp0, vl_2);
+    cols_13_low_32 = __riscv_vadd_vv_i32m1(tmp12, tmp0, vl_2);
+    cols_13_high_32 = __riscv_vsub_vv_i32m1(tmp10, tmp2, vl_2);
+
+    cols_02_low_32 = __riscv_vadd_vx_i32m1(cols_02_low_32, (1 << (CONST_BITS + PASS1_BITS + 3)) + (CENTERJSAMPLE << (CONST_BITS + PASS1_BITS + 3 + 1)), vl_2);
+    cols_02_high_32 = __riscv_vadd_vx_i32m1(cols_02_high_32, (1 << (CONST_BITS + PASS1_BITS + 3)) + (CENTERJSAMPLE << (CONST_BITS + PASS1_BITS + 3 + 1)), vl_2);
+    cols_13_low_32 = __riscv_vadd_vx_i32m1(cols_13_low_32, (1 << (CONST_BITS + PASS1_BITS + 3)) + (CENTERJSAMPLE << (CONST_BITS + PASS1_BITS + 3 + 1)), vl_2);
+    cols_13_high_32 = __riscv_vadd_vx_i32m1(cols_13_high_32, (1 << (CONST_BITS + PASS1_BITS + 3)) + (CENTERJSAMPLE << (CONST_BITS + PASS1_BITS + 3 + 1)), vl_2);
+
+    cols_02_low_16 = __riscv_vnsra_wx_i16mf2(cols_02_low_32, CONST_BITS + PASS1_BITS + 3 + 1, vl_2);
+    cols_02_high_16 = __riscv_vnsra_wx_i16mf2(cols_02_high_32, CONST_BITS + PASS1_BITS + 3 + 1, vl_2);
+    cols_13_low_16 = __riscv_vnsra_wx_i16mf2(cols_13_low_32, CONST_BITS + PASS1_BITS + 3 + 1, vl_2);
+    cols_13_high_16 = __riscv_vnsra_wx_i16mf2(cols_13_high_32, CONST_BITS + PASS1_BITS + 3 + 1, vl_2);
+
+    CLIP(cols_02_low_16, i16mf2);
+    CLIP(cols_02_high_16, i16mf2);
+    CLIP(cols_13_low_16, i16mf2);
+    CLIP(cols_13_high_16, i16mf2);
+
+    cols_02_low_8 = __riscv_vncvt_x_x_w_i8mf4(cols_02_low_16, vl_2);
+    cols_02_high_8 = __riscv_vncvt_x_x_w_i8mf4(cols_02_high_16, vl_2);
+    cols_13_low_8 = __riscv_vncvt_x_x_w_i8mf4(cols_13_low_16, vl_2);
+    cols_13_high_8 = __riscv_vncvt_x_x_w_i8mf4(cols_13_high_16, vl_2);
+
+    vuint64m2_t vstride = __riscv_vle64_v_u64m2(stride, vl);
+    __riscv_vsoxei64_v_i8mf4(output_row + 0, vstride, cols_02_low_8, vl_2);
+    __riscv_vsoxei64_v_i8mf4(output_row + 1, vstride, cols_13_low_8, vl_2);
+    __riscv_vsoxei64_v_i8mf4(output_row + 2, vstride, cols_02_high_8, vl_2);
+    __riscv_vsoxei64_v_i8mf4(output_row + 3, vstride, cols_13_high_8, vl_2);
+}
\ No newline at end of file
diff --git a/simd/rvv/jquanti-rvv.c b/simd/rvv/jquanti-rvv.c
new file mode 100644
index 0000000..69b2c20
--- /dev/null
+++ b/simd/rvv/jquanti-rvv.c
@@ -0,0 +1,132 @@
+/*
+ * jquanti-rvv.c - sample data conversion and quantization
+ *
+ * Copyright (C) 2023, Spacemit, Inc.  All Rights Reserved.
+ * Contributed by Liang Junzhao <junzhao.liang@spacemit.com>
+ *
+ * This software is provided 'as-is', without any express or implied
+ * warranty.  In no event will the authors be held liable for any damages
+ * arising from the use of this software.
+ *
+ * Permission is granted to anyone to use this software for any purpose,
+ * including commercial applications, and to alter it and redistribute it
+ * freely, subject to the following restrictions:
+ *
+ * 1. The origin of this software must not be misrepresented; you must not
+ *    claim that you wrote the original software. If you use this software
+ *    in a product, an acknowledgment in the product documentation would be
+ *    appreciated but is not required.
+ * 2. Altered source versions must be plainly marked as such, and must not be
+ *    misrepresented as being the original software.
+ * 3. This notice may not be removed or altered from any source distribution.
+ */
+
+/* INTEGER QUANTIZATION AND SAMPLE CONVERSION */
+
+#define JPEG_INTERNALS
+#include "jsimd_rvv.h"
+
+void jsimd_convsamp_rvv(JSAMPARRAY sample_data, JDIMENSION start_col,
+                        DCTELEM *workspace)
+{
+    size_t vl = __riscv_vsetvl_e16mf2(DCTSIZE);
+
+    vuint8mf4_t in0, in1, in2, in3, in4, in5, in6, in7;
+    vuint16mf2_t row0, row1, row2, row3, row4, row5, row6, row7;
+    vint16mf2_t out0, out1, out2, out3, out4, out5, out6, out7;
+
+    in0 = __riscv_vle8_v_u8mf4(sample_data[0] + start_col, vl);
+    in1 = __riscv_vle8_v_u8mf4(sample_data[1] + start_col, vl);
+    in2 = __riscv_vle8_v_u8mf4(sample_data[2] + start_col, vl);
+    in3 = __riscv_vle8_v_u8mf4(sample_data[3] + start_col, vl);
+    in4 = __riscv_vle8_v_u8mf4(sample_data[4] + start_col, vl);
+    in5 = __riscv_vle8_v_u8mf4(sample_data[5] + start_col, vl);
+    in6 = __riscv_vle8_v_u8mf4(sample_data[6] + start_col, vl);
+    in7 = __riscv_vle8_v_u8mf4(sample_data[7] + start_col, vl);
+
+    row0 = __riscv_vwcvtu_x_x_v_u16mf2(in0, vl);
+    row1 = __riscv_vwcvtu_x_x_v_u16mf2(in1, vl);
+    row2 = __riscv_vwcvtu_x_x_v_u16mf2(in2, vl);
+    row3 = __riscv_vwcvtu_x_x_v_u16mf2(in3, vl);
+    row4 = __riscv_vwcvtu_x_x_v_u16mf2(in4, vl);
+    row5 = __riscv_vwcvtu_x_x_v_u16mf2(in5, vl);
+    row6 = __riscv_vwcvtu_x_x_v_u16mf2(in6, vl);
+    row7 = __riscv_vwcvtu_x_x_v_u16mf2(in7, vl);
+
+    out0 = __riscv_vreinterpret_v_u16mf2_i16mf2(row0);
+    out1 = __riscv_vreinterpret_v_u16mf2_i16mf2(row1);
+    out2 = __riscv_vreinterpret_v_u16mf2_i16mf2(row2);
+    out3 = __riscv_vreinterpret_v_u16mf2_i16mf2(row3);
+    out4 = __riscv_vreinterpret_v_u16mf2_i16mf2(row4);
+    out5 = __riscv_vreinterpret_v_u16mf2_i16mf2(row5);
+    out6 = __riscv_vreinterpret_v_u16mf2_i16mf2(row6);
+    out7 = __riscv_vreinterpret_v_u16mf2_i16mf2(row7);
+
+    out0 = __riscv_vsub_vx_i16mf2(out0, CENTERJSAMPLE, vl);
+    out1 = __riscv_vsub_vx_i16mf2(out1, CENTERJSAMPLE, vl);
+    out2 = __riscv_vsub_vx_i16mf2(out2, CENTERJSAMPLE, vl);
+    out3 = __riscv_vsub_vx_i16mf2(out3, CENTERJSAMPLE, vl);
+    out4 = __riscv_vsub_vx_i16mf2(out4, CENTERJSAMPLE, vl);
+    out5 = __riscv_vsub_vx_i16mf2(out5, CENTERJSAMPLE, vl);
+    out6 = __riscv_vsub_vx_i16mf2(out6, CENTERJSAMPLE, vl);
+    out7 = __riscv_vsub_vx_i16mf2(out7, CENTERJSAMPLE, vl);
+
+    __riscv_vse16_v_i16mf2(workspace + 0 * DCTSIZE, out0, vl);
+    __riscv_vse16_v_i16mf2(workspace + 1 * DCTSIZE, out1, vl);
+    __riscv_vse16_v_i16mf2(workspace + 2 * DCTSIZE, out2, vl);
+    __riscv_vse16_v_i16mf2(workspace + 3 * DCTSIZE, out3, vl);
+    __riscv_vse16_v_i16mf2(workspace + 4 * DCTSIZE, out4, vl);
+    __riscv_vse16_v_i16mf2(workspace + 5 * DCTSIZE, out5, vl);
+    __riscv_vse16_v_i16mf2(workspace + 6 * DCTSIZE, out6, vl);
+    __riscv_vse16_v_i16mf2(workspace + 7 * DCTSIZE, out7, vl);
+}
+
+void jsimd_quantize_rvv(JCOEFPTR coef_block, DCTELEM *divisors,
+                        DCTELEM *workspace)
+{
+    int cols_remaining;
+    size_t vl;
+    JCOEFPTR out_ptr = coef_block;
+    DCTELEM *in_ptr = workspace;
+    DCTELEM *shift_ptr = divisors + 3 * DCTSIZE2;
+    UDCTELEM *recip_ptr = (UDCTELEM *)divisors;
+    UDCTELEM *corr_ptr = (UDCTELEM *)divisors + DCTSIZE2;
+
+    vbool4_t mask;
+    vint16m4_t out, shift;
+    vuint16m4_t temp, recip, corr, ushift;
+    vuint32m8_t product;
+
+    for (cols_remaining = DCTSIZE2; cols_remaining > 0; cols_remaining -= vl)
+    {
+        /* Set vl for each iteration. */
+        vl = __riscv_vsetvl_e16m4(cols_remaining);
+
+        /* Load needed variables. */
+        out = __riscv_vle16_v_i16m4(in_ptr, vl);
+        recip = __riscv_vle16_v_u16m4(recip_ptr, vl);
+        corr = __riscv_vle16_v_u16m4(corr_ptr, vl);
+        shift = __riscv_vle16_v_i16m4(shift_ptr, vl);
+
+        /* Mask set to 1 where elements are negative. */
+        mask = __riscv_vmslt_vx_i16m4_b4(out, 0, vl);
+        out = __riscv_vneg_v_i16m4_m(mask, out, vl);
+        temp = __riscv_vreinterpret_v_i16m4_u16m4(out);
+
+        temp = __riscv_vadd_vv_u16m4(temp, corr, vl);
+        product = __riscv_vwmulu_vv_u32m8(temp, recip, vl);
+        shift = __riscv_vadd_vx_i16m4(shift, sizeof(DCTELEM) * 8, vl);
+        ushift = __riscv_vreinterpret_v_i16m4_u16m4(shift);
+        temp = __riscv_vnsrl_wv_u16m4(product, ushift, vl);
+
+        out = __riscv_vreinterpret_v_u16m4_i16m4(temp);
+        out = __riscv_vneg_v_i16m4_m(mask, out, vl);
+        __riscv_vse16_v_i16m4(out_ptr, out, vl);
+
+        in_ptr += vl;
+        out_ptr += vl;
+        recip_ptr += vl;
+        corr_ptr += vl;
+        shift_ptr += vl;
+    }
+}
\ No newline at end of file
diff --git a/simd/rvv/jsimd.c b/simd/rvv/jsimd.c
new file mode 100644
index 0000000..9277e76
--- /dev/null
+++ b/simd/rvv/jsimd.c
@@ -0,0 +1,940 @@
+/*
+ * jsimd_rvv.c
+ *
+ * Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+ * Copyright (C) 2011, Nokia Corporation and/or its subsidiary(-ies).
+ * Copyright (C) 2009-2011, 2013-2014, 2016, 2018, 2020, 2022, D. R. Commander.
+ * Copyright (C) 2015-2016, 2018, Matthieu Darbois.
+ * Copyright (C) 2020, Arm Limited.
+ * Copyright (C) 2023, Spacemit, Inc. Liang Junzhao.
+ *
+ * Based on the x86 SIMD extension for IJG JPEG library,
+ * Copyright (C) 1999-2006, MIYASAKA Masaru.
+ * For conditions of distribution and use, see copyright notice in jsimdext.inc
+ *
+ * This file contains the interface between the "normal" portions
+ * of the library and the RVV implementations when running on a risc-v architecture.
+ */
+
+#define JPEG_INTERNALS
+#include "../../jinclude.h"
+#include "../../jpeglib.h"
+#include "../../jsimd.h"
+#include "../../jdct.h"
+#include "../../jsimddct.h"
+#include "../jsimd.h"
+
+static unsigned int simd_support = ~0;
+
+#if defined(__linux__)
+
+#define SOMEWHAT_SANE_PROC_CPUINFO_SIZE_LIMIT (1024 * 1024)
+/* TODO: Check rvv intrinsic support by examine /proc/cpuinfo */
+
+#endif
+
+/* RVV SIMD support is always available during test. */
+/*
+ * Check what SIMD accelerations are supported.
+ *
+ * FIXME: This code is racy under a multi-threaded environment.
+ */
+LOCAL(void)
+init_simd(void)
+{
+#ifndef NO_GETENV
+  char *env = NULL;
+#endif
+#if defined(__linux__)
+  int bufsize = 1024; /* an initial guess for the line buffer size limit */
+#endif
+
+  if (simd_support != ~0U)
+    return;
+
+  simd_support = 0;
+  simd_support |= JSIMD_RVV;
+
+#ifndef NO_GETENV
+  /* Force different settings through environment variables */
+  env = getenv("JSIMD_FORCERVV");
+  if ((env != NULL) && (strcmp(env, "1") == 0))
+    simd_support = JSIMD_RVV;
+  env = getenv("JSIMD_FORCENONE");
+  if ((env != NULL) && (strcmp(env, "1") == 0))
+    simd_support = 0;
+#endif
+}
+
+//1
+GLOBAL(int)
+jsimd_can_rgb_ycc(void)
+{
+  init_simd();
+
+  /* The code is optimised for these values only */
+  if (BITS_IN_JSAMPLE != 8)
+    return 0;
+  if (sizeof(JDIMENSION) != 4)
+    return 0;
+  if ((RGB_PIXELSIZE != 3) && (RGB_PIXELSIZE != 4))
+    return 0;
+
+  if (simd_support & JSIMD_RVV)
+    return 1;
+
+  return 0;
+}
+
+//2
+GLOBAL(int)
+jsimd_can_rgb_gray(void)
+{
+  init_simd();
+
+  /* The code is optimised for these values only */
+  if (BITS_IN_JSAMPLE != 8)
+    return 0;
+  if (sizeof(JDIMENSION) != 4)
+    return 0;
+  if ((RGB_PIXELSIZE != 3) && (RGB_PIXELSIZE != 4))
+    return 0;
+
+  if (simd_support & JSIMD_RVV)
+    return 1;
+
+  return 0;
+}
+
+//5
+GLOBAL(int)
+jsimd_can_ycc_rgb(void)
+{
+  init_simd();
+
+  /* The code is optimised for these values only */
+  if (BITS_IN_JSAMPLE != 8)
+    return 0;
+  if (sizeof(JDIMENSION) != 4)
+    return 0;
+  if ((RGB_PIXELSIZE != 3) && (RGB_PIXELSIZE != 4))
+    return 0;
+
+  if (simd_support & JSIMD_RVV)
+    return 1;
+
+  return 0;
+}
+
+GLOBAL(int)
+jsimd_can_ycc_rgb565(void)
+{
+  return 0;
+}
+
+GLOBAL(int)
+jsimd_c_can_null_convert(void)
+{
+  return 0;
+}
+
+GLOBAL(void)
+jsimd_rgb_ycc_convert(j_compress_ptr cinfo, JSAMPARRAY input_buf,
+                      JSAMPIMAGE output_buf, JDIMENSION output_row,
+                      int num_rows)
+{
+  void (*rvvfct)(JDIMENSION, JSAMPARRAY, JSAMPIMAGE, JDIMENSION, int);
+
+  switch (cinfo->in_color_space)
+  {
+  case JCS_EXT_RGB:
+    rvvfct = jsimd_extrgb_ycc_convert_rvv;
+    break;
+  case JCS_EXT_RGBX:
+  case JCS_EXT_RGBA:
+    rvvfct = jsimd_extrgbx_ycc_convert_rvv;
+    break;
+  case JCS_EXT_BGR:
+    rvvfct = jsimd_extbgr_ycc_convert_rvv;
+    break;
+  case JCS_EXT_BGRX:
+  case JCS_EXT_BGRA:
+    rvvfct = jsimd_extbgrx_ycc_convert_rvv;
+    break;
+  case JCS_EXT_XBGR:
+  case JCS_EXT_ABGR:
+    rvvfct = jsimd_extxbgr_ycc_convert_rvv;
+    break;
+  case JCS_EXT_XRGB:
+  case JCS_EXT_ARGB:
+    rvvfct = jsimd_extxrgb_ycc_convert_rvv;
+    break;
+  default:
+    rvvfct = jsimd_rgb_ycc_convert_rvv;
+    break;
+  }
+
+  rvvfct(cinfo->image_width, input_buf, output_buf, output_row, num_rows);
+}
+
+GLOBAL(void)
+jsimd_rgb_gray_convert(j_compress_ptr cinfo, JSAMPARRAY input_buf,
+                       JSAMPIMAGE output_buf, JDIMENSION output_row,
+                       int num_rows)
+{
+  void (*rvvfct)(JDIMENSION, JSAMPARRAY, JSAMPIMAGE, JDIMENSION, int);
+
+  switch (cinfo->in_color_space)
+  {
+  case JCS_EXT_RGB:
+    rvvfct = jsimd_extrgb_gray_convert_rvv;
+    break;
+  case JCS_EXT_RGBX:
+  case JCS_EXT_RGBA:
+    rvvfct = jsimd_extrgbx_gray_convert_rvv;
+    break;
+  case JCS_EXT_BGR:
+    rvvfct = jsimd_extbgr_gray_convert_rvv;
+    break;
+  case JCS_EXT_BGRX:
+  case JCS_EXT_BGRA:
+    rvvfct = jsimd_extbgrx_gray_convert_rvv;
+    break;
+  case JCS_EXT_XBGR:
+  case JCS_EXT_ABGR:
+    rvvfct = jsimd_extxbgr_gray_convert_rvv;
+    break;
+  case JCS_EXT_XRGB:
+  case JCS_EXT_ARGB:
+    rvvfct = jsimd_extxrgb_gray_convert_rvv;
+    break;
+  default:
+    rvvfct = jsimd_rgb_gray_convert_rvv;
+    break;
+  }
+
+  rvvfct(cinfo->image_width, input_buf, output_buf, output_row, num_rows);
+}
+
+GLOBAL(void)
+jsimd_ycc_rgb_convert(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,
+                      JDIMENSION input_row, JSAMPARRAY output_buf,
+                      int num_rows)
+{
+  void (*rvvfct)(JDIMENSION, JSAMPIMAGE, JDIMENSION, JSAMPARRAY, int);
+
+  switch (cinfo->out_color_space)
+  {
+  case JCS_EXT_RGB:
+    rvvfct = jsimd_ycc_extrgb_convert_rvv;
+    break;
+  case JCS_EXT_RGBX:
+  case JCS_EXT_RGBA:
+    rvvfct = jsimd_ycc_extrgbx_convert_rvv;
+    break;
+  case JCS_EXT_BGR:
+    rvvfct = jsimd_ycc_extbgr_convert_rvv;
+    break;
+  case JCS_EXT_BGRX:
+  case JCS_EXT_BGRA:
+    rvvfct = jsimd_ycc_extbgrx_convert_rvv;
+    break;
+  case JCS_EXT_XBGR:
+  case JCS_EXT_ABGR:
+    rvvfct = jsimd_ycc_extxbgr_convert_rvv;
+    break;
+  case JCS_EXT_XRGB:
+  case JCS_EXT_ARGB:
+    rvvfct = jsimd_ycc_extxrgb_convert_rvv;
+    break;
+  default:
+    rvvfct = jsimd_ycc_rgb_convert_rvv;
+    break;
+  }
+
+  rvvfct(cinfo->output_width, input_buf, input_row, output_buf, num_rows);
+}
+
+GLOBAL(void)
+jsimd_ycc_rgb565_convert(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,
+                         JDIMENSION input_row, JSAMPARRAY output_buf,
+                         int num_rows)
+{
+}
+
+GLOBAL(void)
+jsimd_c_null_convert(j_compress_ptr cinfo, JSAMPARRAY input_buf,
+                     JSAMPIMAGE output_buf, JDIMENSION output_row,
+                     int num_rows)
+{
+}
+
+//4
+GLOBAL(int)
+jsimd_can_h2v2_downsample(void)
+{
+  init_simd();
+
+  /* The code is optimised for these values only */
+  if (BITS_IN_JSAMPLE != 8)
+    return 0;
+  if (sizeof(JDIMENSION) != 4)
+    return 0;
+
+  if (simd_support & JSIMD_RVV)
+    return 1;
+
+  return 0;
+}
+
+GLOBAL(int)
+jsimd_can_h2v2_smooth_downsample(void)
+{
+  return 0;
+}
+
+//3
+GLOBAL(int)
+jsimd_can_h2v1_downsample(void)
+{
+  init_simd();
+
+  /* The code is optimised for these values only */
+  if (BITS_IN_JSAMPLE != 8)
+    return 0;
+  if (sizeof(JDIMENSION) != 4)
+    return 0;
+
+  if (simd_support & JSIMD_RVV)
+    return 1;
+
+  return 0;
+}
+
+GLOBAL(void)
+jsimd_h2v2_downsample(j_compress_ptr cinfo, jpeg_component_info *compptr,
+                      JSAMPARRAY input_data, JSAMPARRAY output_data)
+{
+  jsimd_h2v2_downsample_rvv(cinfo->image_width, cinfo->max_v_samp_factor,
+                            compptr->v_samp_factor, compptr->width_in_blocks,
+                            input_data, output_data);
+}
+
+GLOBAL(void)
+jsimd_h2v2_smooth_downsample(j_compress_ptr cinfo,
+                             jpeg_component_info *compptr,
+                             JSAMPARRAY input_data, JSAMPARRAY output_data)
+{
+}
+
+GLOBAL(void)
+jsimd_h2v1_downsample(j_compress_ptr cinfo, jpeg_component_info *compptr,
+                      JSAMPARRAY input_data, JSAMPARRAY output_data)
+{
+  jsimd_h2v1_downsample_rvv(cinfo->image_width, cinfo->max_v_samp_factor,
+                            compptr->v_samp_factor, compptr->width_in_blocks,
+                            input_data, output_data);
+}
+
+//11
+GLOBAL(int)
+jsimd_can_h2v2_upsample(void)
+{
+  init_simd();
+
+  /* The code is optimised for these values only */
+  if (BITS_IN_JSAMPLE != 8)
+    return 0;
+  if (sizeof(JDIMENSION) != 4)
+    return 0;
+
+  if (simd_support & JSIMD_RVV)
+    return 1;
+
+  return 0;
+}
+
+//10
+GLOBAL(int)
+jsimd_can_h2v1_upsample(void)
+{
+  init_simd();
+
+  /* The code is optimised for these values only */
+  if (BITS_IN_JSAMPLE != 8)
+    return 0;
+  if (sizeof(JDIMENSION) != 4)
+    return 0;
+
+  if (simd_support & JSIMD_RVV)
+    return 1;
+
+  return 0;
+}
+
+GLOBAL(int)
+jsimd_can_int_upsample(void)
+{
+  return 0;
+}
+
+GLOBAL(void)
+jsimd_h2v2_upsample(j_decompress_ptr cinfo, jpeg_component_info *compptr,
+                    JSAMPARRAY input_data, JSAMPARRAY *output_data_ptr)
+{
+  jsimd_h2v2_upsample_rvv(cinfo->max_v_samp_factor,
+                          cinfo->output_width, input_data,
+                          output_data_ptr);
+}
+
+GLOBAL(void)
+jsimd_h2v1_upsample(j_decompress_ptr cinfo, jpeg_component_info *compptr,
+                    JSAMPARRAY input_data, JSAMPARRAY *output_data_ptr)
+{
+  jsimd_h2v1_upsample_rvv(cinfo->max_v_samp_factor,
+                          cinfo->output_width, input_data,
+                          output_data_ptr);
+}
+
+GLOBAL(void)
+jsimd_int_upsample(j_decompress_ptr cinfo, jpeg_component_info *compptr,
+                   JSAMPARRAY input_data, JSAMPARRAY *output_data_ptr)
+{
+}
+
+//8
+GLOBAL(int)
+jsimd_can_h2v2_fancy_upsample(void)
+{
+  init_simd();
+
+  /* The code is optimised for these values only */
+  if (BITS_IN_JSAMPLE != 8)
+    return 0;
+  if (sizeof(JDIMENSION) != 4)
+    return 0;
+
+  if (simd_support & JSIMD_RVV)
+    return 1;
+
+  return 0;
+}
+
+//7
+GLOBAL(int)
+jsimd_can_h2v1_fancy_upsample(void)
+{
+  init_simd();
+
+  /* The code is optimised for these values only */
+  if (BITS_IN_JSAMPLE != 8)
+    return 0;
+  if (sizeof(JDIMENSION) != 4)
+    return 0;
+
+  if (simd_support & JSIMD_RVV)
+    return 1;
+
+  return 0;
+}
+
+//9
+GLOBAL(int)
+jsimd_can_h1v2_fancy_upsample(void)
+{
+  init_simd();
+
+  /* The code is optimised for these values only */
+  if (BITS_IN_JSAMPLE != 8)
+    return 0;
+  if (sizeof(JDIMENSION) != 4)
+    return 0;
+
+  if (simd_support & JSIMD_RVV)
+    return 1;
+
+  return 0;
+}
+
+GLOBAL(void)
+jsimd_h2v2_fancy_upsample(j_decompress_ptr cinfo, jpeg_component_info *compptr,
+                          JSAMPARRAY input_data, JSAMPARRAY *output_data_ptr)
+{
+  jsimd_h2v2_fancy_upsample_rvv(cinfo->max_v_samp_factor,
+                                compptr->downsampled_width, input_data,
+                                output_data_ptr);
+}
+
+GLOBAL(void)
+jsimd_h2v1_fancy_upsample(j_decompress_ptr cinfo, jpeg_component_info *compptr,
+                          JSAMPARRAY input_data, JSAMPARRAY *output_data_ptr)
+{
+  jsimd_h2v1_fancy_upsample_rvv(cinfo->max_v_samp_factor,
+                                compptr->downsampled_width, input_data,
+                                output_data_ptr);
+}
+
+GLOBAL(void)
+jsimd_h1v2_fancy_upsample(j_decompress_ptr cinfo, jpeg_component_info *compptr,
+                          JSAMPARRAY input_data, JSAMPARRAY *output_data_ptr)
+{
+  jsimd_h1v2_fancy_upsample_rvv(cinfo->max_v_samp_factor,
+                                 compptr->downsampled_width, input_data,
+                                 output_data_ptr);
+}
+
+GLOBAL(int)
+jsimd_can_h2v2_merged_upsample(void)
+{
+  init_simd();
+
+  /* The code is optimised for these values only */
+  if (BITS_IN_JSAMPLE != 8)
+    return 0;
+  if (sizeof(JDIMENSION) != 4)
+    return 0;
+
+  if (simd_support & JSIMD_RVV)
+    return 1;
+
+  return 0;
+}
+
+//6
+GLOBAL(int)
+jsimd_can_h2v1_merged_upsample(void)
+{
+  init_simd();
+
+  /* The code is optimised for these values only */
+  if (BITS_IN_JSAMPLE != 8)
+    return 0;
+  if (sizeof(JDIMENSION) != 4)
+    return 0;
+
+  if (simd_support & JSIMD_RVV)
+    return 1;
+
+  return 0;
+}
+
+GLOBAL(void)
+jsimd_h2v2_merged_upsample(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,
+                           JDIMENSION in_row_group_ctr, JSAMPARRAY output_buf)
+{
+  void (*rvvfct)(JDIMENSION, JSAMPIMAGE, JDIMENSION, JSAMPARRAY);
+
+  switch (cinfo->out_color_space)
+  {
+  case JCS_EXT_RGB:
+    rvvfct = jsimd_h2v2_extrgb_merged_upsample_rvv;
+    break;
+  case JCS_EXT_RGBX:
+  case JCS_EXT_RGBA:
+    rvvfct = jsimd_h2v2_extrgbx_merged_upsample_rvv;
+    break;
+  case JCS_EXT_BGR:
+    rvvfct = jsimd_h2v2_extbgr_merged_upsample_rvv;
+    break;
+  case JCS_EXT_BGRX:
+  case JCS_EXT_BGRA:
+    rvvfct = jsimd_h2v2_extbgrx_merged_upsample_rvv;
+    break;
+  case JCS_EXT_XBGR:
+  case JCS_EXT_ABGR:
+    rvvfct = jsimd_h2v2_extxbgr_merged_upsample_rvv;
+    break;
+  case JCS_EXT_XRGB:
+  case JCS_EXT_ARGB:
+    rvvfct = jsimd_h2v2_extxrgb_merged_upsample_rvv;
+    break;
+  default:
+    rvvfct = jsimd_h2v2_merged_upsample_rvv;
+    break;
+  }
+
+  rvvfct(cinfo->output_width, input_buf, in_row_group_ctr, output_buf);
+}
+
+//6
+GLOBAL(void)
+jsimd_h2v1_merged_upsample(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,
+                           JDIMENSION in_row_group_ctr, JSAMPARRAY output_buf)
+{
+  void (*rvvfct)(JDIMENSION, JSAMPIMAGE, JDIMENSION, JSAMPARRAY);
+
+  switch (cinfo->out_color_space)
+  {
+  case JCS_EXT_RGB:
+    rvvfct = jsimd_h2v1_extrgb_merged_upsample_rvv;
+    break;
+  case JCS_EXT_RGBX:
+  case JCS_EXT_RGBA:
+    rvvfct = jsimd_h2v1_extrgbx_merged_upsample_rvv;
+    break;
+  case JCS_EXT_BGR:
+    rvvfct = jsimd_h2v1_extbgr_merged_upsample_rvv;
+    break;
+  case JCS_EXT_BGRX:
+  case JCS_EXT_BGRA:
+    rvvfct = jsimd_h2v1_extbgrx_merged_upsample_rvv;
+    break;
+  case JCS_EXT_XBGR:
+  case JCS_EXT_ABGR:
+    rvvfct = jsimd_h2v1_extxbgr_merged_upsample_rvv;
+    break;
+  case JCS_EXT_XRGB:
+  case JCS_EXT_ARGB:
+    rvvfct = jsimd_h2v1_extxrgb_merged_upsample_rvv;
+    break;
+  default:
+    rvvfct = jsimd_h2v1_merged_upsample_rvv;
+    break;
+  }
+
+  rvvfct(cinfo->output_width, input_buf, in_row_group_ctr, output_buf);
+}
+
+//16
+GLOBAL(int)
+jsimd_can_convsamp(void)
+{
+  init_simd();
+
+  /* The code is optimised for these values only */
+  if (BITS_IN_JSAMPLE != 8)
+    return 0;
+  if (sizeof(DCTELEM) != 2)
+    return 0;
+  if (sizeof(JDIMENSION) != 4)
+    return 0;
+
+  if (simd_support & JSIMD_RVV)
+    return 1;
+
+  return 0;
+}
+
+GLOBAL(int)
+jsimd_can_convsamp_float(void)
+{
+  return 0;
+}
+
+GLOBAL(void)
+jsimd_convsamp(JSAMPARRAY sample_data, JDIMENSION start_col,
+               DCTELEM *workspace)
+{
+  jsimd_convsamp_rvv(sample_data, start_col, workspace);
+}
+
+GLOBAL(void)
+jsimd_convsamp_float(JSAMPARRAY sample_data, JDIMENSION start_col,
+                     FAST_FLOAT *workspace)
+{
+}
+
+//13
+GLOBAL(int)
+jsimd_can_fdct_islow(void)
+{
+  init_simd();
+
+  /* The code is optimised for these values only */
+  if (DCTSIZE != 8)
+    return 0;
+  if (sizeof(DCTELEM) != 2)
+    return 0;
+
+  if (simd_support & JSIMD_RVV)
+    return 1;
+
+  return 0;
+}
+
+//12
+GLOBAL(int)
+jsimd_can_fdct_ifast(void)
+{
+  init_simd();
+
+  /* The code is optimised for these values only */
+  if (DCTSIZE != 8)
+    return 0;
+  if (sizeof(DCTELEM) != 2)
+    return 0;
+
+  if (simd_support & JSIMD_RVV)
+    return 1;
+
+  return 0;
+}
+
+GLOBAL(int)
+jsimd_can_fdct_float(void)
+{
+  return 0;
+}
+
+GLOBAL(void)
+jsimd_fdct_islow(DCTELEM *data)
+{
+  jsimd_fdct_islow_rvv(data);
+}
+
+GLOBAL(void)
+jsimd_fdct_ifast(DCTELEM *data)
+{
+  jsimd_fdct_ifast_rvv(data);
+}
+
+GLOBAL(void)
+jsimd_fdct_float(FAST_FLOAT *data)
+{
+}
+
+//17
+GLOBAL(int)
+jsimd_can_quantize(void)
+{
+  init_simd();
+
+  /* The code is optimised for these values only */
+  if (DCTSIZE != 8)
+    return 0;
+  if (sizeof(JCOEF) != 2)
+    return 0;
+  if (sizeof(DCTELEM) != 2)
+    return 0;
+
+  if (simd_support & JSIMD_RVV)
+    return 1;
+
+  return 0;
+}
+
+GLOBAL(int)
+jsimd_can_quantize_float(void)
+{
+  return 0;
+}
+
+GLOBAL(void)
+jsimd_quantize(JCOEFPTR coef_block, DCTELEM *divisors, DCTELEM *workspace)
+{
+  jsimd_quantize_rvv(coef_block, divisors, workspace);
+}
+
+GLOBAL(void)
+jsimd_quantize_float(JCOEFPTR coef_block, FAST_FLOAT *divisors,
+                     FAST_FLOAT *workspace)
+{
+}
+
+GLOBAL(int)
+jsimd_can_idct_2x2(void)
+{
+  init_simd();
+
+  /* The code is optimised for these values only */
+  if (DCTSIZE != 8)
+    return 0;
+  if (sizeof(JCOEF) != 2)
+    return 0;
+  if (BITS_IN_JSAMPLE != 8)
+    return 0;
+  if (sizeof(JDIMENSION) != 4)
+    return 0;
+  if (sizeof(ISLOW_MULT_TYPE) != 2)
+    return 0;
+
+  if (simd_support & JSIMD_RVV)
+    return 1;
+
+  return 0;
+}
+
+GLOBAL(int)
+jsimd_can_idct_4x4(void)
+{
+  init_simd();
+
+  /* The code is optimised for these values only */
+  if (DCTSIZE != 8)
+    return 0;
+  if (sizeof(JCOEF) != 2)
+    return 0;
+  if (BITS_IN_JSAMPLE != 8)
+    return 0;
+  if (sizeof(JDIMENSION) != 4)
+    return 0;
+  if (sizeof(ISLOW_MULT_TYPE) != 2)
+    return 0;
+
+  if (simd_support & JSIMD_RVV)
+    return 1;
+
+  return 0;
+}
+
+GLOBAL(int)
+jsimd_can_idct_6x6(void)
+{
+  return 0;
+}
+
+GLOBAL(int)
+jsimd_can_idct_12x12(void)
+{
+  return 0;
+}
+
+GLOBAL(void)
+jsimd_idct_2x2(j_decompress_ptr cinfo, jpeg_component_info *compptr,
+               JCOEFPTR coef_block, JSAMPARRAY output_buf,
+               JDIMENSION output_col)
+{
+  jsimd_idct_2x2_rvv(compptr->dct_table, coef_block, output_buf, output_col);
+}
+
+GLOBAL(void)
+jsimd_idct_4x4(j_decompress_ptr cinfo, jpeg_component_info *compptr,
+               JCOEFPTR coef_block, JSAMPARRAY output_buf,
+               JDIMENSION output_col)
+{
+  jsimd_idct_4x4_rvv(compptr->dct_table, coef_block, output_buf, output_col);
+}
+
+GLOBAL(void)
+jsimd_idct_6x6(j_decompress_ptr cinfo, jpeg_component_info *compptr,
+               JCOEFPTR coef_block, JSAMPARRAY output_buf,
+               JDIMENSION output_col)
+{
+}
+
+GLOBAL(void)
+jsimd_idct_12x12(j_decompress_ptr cinfo, jpeg_component_info *compptr,
+                 JCOEFPTR coef_block, JSAMPARRAY output_buf,
+                 JDIMENSION output_col)
+{
+}
+
+//15
+GLOBAL(int)
+jsimd_can_idct_islow(void)
+{
+  init_simd();
+
+  /* The code is optimised for these values only */
+  if (DCTSIZE != 8)
+    return 0;
+  if (sizeof(JCOEF) != 2)
+    return 0;
+  if (BITS_IN_JSAMPLE != 8)
+    return 0;
+  if (sizeof(JDIMENSION) != 4)
+    return 0;
+  if (sizeof(ISLOW_MULT_TYPE) != 2)
+    return 0;
+
+  if (simd_support & JSIMD_RVV)
+    return 1;
+
+  return 0;
+}
+
+//14
+GLOBAL(int)
+jsimd_can_idct_ifast(void)
+{
+  init_simd();
+
+  /* The code is optimised for these values only */
+  if (DCTSIZE != 8)
+    return 0;
+  if (sizeof(JCOEF) != 2)
+    return 0;
+  if (BITS_IN_JSAMPLE != 8)
+    return 0;
+  if (sizeof(JDIMENSION) != 4)
+    return 0;
+  if (sizeof(IFAST_MULT_TYPE) != 2)
+    return 0;
+  if (IFAST_SCALE_BITS != 2)
+    return 0;
+
+  if (simd_support & JSIMD_RVV)
+    return 1;
+
+  return 0;
+}
+
+GLOBAL(int)
+jsimd_can_idct_float(void)
+{
+  return 0;
+}
+
+GLOBAL(void)
+jsimd_idct_islow(j_decompress_ptr cinfo, jpeg_component_info *compptr,
+                 JCOEFPTR coef_block, JSAMPARRAY output_buf,
+                 JDIMENSION output_col)
+{
+  jsimd_idct_islow_rvv(compptr->dct_table, coef_block, output_buf, output_col);
+}
+
+GLOBAL(void)
+jsimd_idct_ifast(j_decompress_ptr cinfo, jpeg_component_info *compptr,
+                 JCOEFPTR coef_block, JSAMPARRAY output_buf,
+                 JDIMENSION output_col)
+{
+  jsimd_idct_ifast_rvv(compptr->dct_table, coef_block, output_buf, output_col);
+}
+
+GLOBAL(void)
+jsimd_idct_float(j_decompress_ptr cinfo, jpeg_component_info *compptr,
+                 JCOEFPTR coef_block, JSAMPARRAY output_buf,
+                 JDIMENSION output_col)
+{
+}
+
+GLOBAL(int)
+jsimd_can_huff_encode_one_block(void)
+{
+  return 0;
+}
+
+GLOBAL(JOCTET *)
+jsimd_huff_encode_one_block(void *state, JOCTET *buffer, JCOEFPTR block,
+                            int last_dc_val, c_derived_tbl *dctbl,
+                            c_derived_tbl *actbl)
+{
+  return NULL;
+}
+
+GLOBAL(int)
+jsimd_can_encode_mcu_AC_first_prepare(void)
+{
+  return 0;
+}
+
+GLOBAL(void)
+jsimd_encode_mcu_AC_first_prepare(const JCOEF *block,
+                                  const int *jpeg_natural_order_start, int Sl,
+                                  int Al, UJCOEF *values, size_t *zerobits)
+{
+}
+
+GLOBAL(int)
+jsimd_can_encode_mcu_AC_refine_prepare(void)
+{
+  return 0;
+}
+
+GLOBAL(int)
+jsimd_encode_mcu_AC_refine_prepare(const JCOEF *block,
+                                   const int *jpeg_natural_order_start, int Sl,
+                                   int Al, UJCOEF *absvalues, size_t *bits)
+{
+  return 0;
+}
diff --git a/simd/rvv/jsimd_rvv.h b/simd/rvv/jsimd_rvv.h
new file mode 100644
index 0000000..e3bb7d8
--- /dev/null
+++ b/simd/rvv/jsimd_rvv.h
@@ -0,0 +1,39 @@
+/*
+ * Risc-V vector extension optimizations for libjpeg-turbo
+ *
+ * Copyright (C) 2023, Spacemit, Inc.  All Rights Reserved.
+ * Contributed by Liang Junzhao <junzhao.liang@spacemit.com>
+ *
+ * This software is provided 'as-is', without any express or implied
+ * warranty.  In no event will the authors be held liable for any damages
+ * arising from the use of this software.
+ *
+ * Permission is granted to anyone to use this software for any purpose,
+ * including commercial applications, and to alter it and redistribute it
+ * freely, subject to the following restrictions:
+ *
+ * 1. The origin of this software must not be misrepresented; you must not
+ *    claim that you wrote the original software. If you use this software
+ *    in a product, an acknowledgment in the product documentation would be
+ *    appreciated but is not required.
+ * 2. Altered source versions must be plainly marked as such, and must not be
+ *    misrepresented as being the original software.
+ * 3. This notice may not be removed or altered from any source distribution.
+ */
+
+#define JPEG_INTERNALS
+#include "../../jinclude.h"
+#include "../../jpeglib.h"
+#include "../../jsimd.h"
+#include "../../jdct.h"
+#include "../../jsimddct.h"
+#include "../jsimd.h"
+#include <riscv_vector.h>
+
+#define BYTE_BIT 8
+
+#define CLIP(in, dtype)                                   \
+    {                                                     \
+        in = __riscv_vmax_vx_##dtype(in, 0, vl);          \
+        in = __riscv_vmin_vx_##dtype(in, MAXJSAMPLE, vl); \
+    }
diff --git a/simd/x86_64/jsimd.c b/simd/x86_64/jsimd.c
index 584a010..3f5ee77 100644
--- a/simd/x86_64/jsimd.c
+++ b/simd/x86_64/jsimd.c
@@ -2,8 +2,8 @@
  * jsimd_x86_64.c
  *
  * Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
- * Copyright (C) 2009-2011, 2014, 2016, 2018, 2022, D. R. Commander.
- * Copyright (C) 2015-2016, 2018, Matthieu Darbois.
+ * Copyright (C) 2009-2011, 2014, 2016, 2018, 2022-2023, D. R. Commander.
+ * Copyright (C) 2015-2016, 2018, 2022, Matthieu Darbois.
  *
  * Based on the x86 SIMD extension for IJG JPEG library,
  * Copyright (C) 1999-2006, MIYASAKA Masaru.
@@ -21,7 +21,6 @@
 #include "../../jdct.h"
 #include "../../jsimddct.h"
 #include "../jsimd.h"
-#include "jconfigint.h"
 
 /*
  * In the PIC cases, we have no guarantee that constants will keep
@@ -32,13 +31,11 @@
 #define IS_ALIGNED_SSE(ptr)  (IS_ALIGNED(ptr, 4)) /* 16 byte alignment */
 #define IS_ALIGNED_AVX(ptr)  (IS_ALIGNED(ptr, 5)) /* 32 byte alignment */
 
-static unsigned int simd_support = (unsigned int)(~0);
-static unsigned int simd_huffman = 1;
+static THREAD_LOCAL unsigned int simd_support = (unsigned int)(~0);
+static THREAD_LOCAL unsigned int simd_huffman = 1;
 
 /*
  * Check what SIMD accelerations are supported.
- *
- * FIXME: This code is racy under a multi-threaded environment.
  */
 LOCAL(void)
 init_simd(void)
@@ -148,6 +145,9 @@ jsimd_rgb_ycc_convert(j_compress_ptr cinfo, JSAMPARRAY input_buf,
   void (*avx2fct) (JDIMENSION, JSAMPARRAY, JSAMPIMAGE, JDIMENSION, int);
   void (*sse2fct) (JDIMENSION, JSAMPARRAY, JSAMPIMAGE, JDIMENSION, int);
 
+  if (simd_support == ~0U)
+    init_simd();
+
   switch (cinfo->in_color_space) {
   case JCS_EXT_RGB:
     avx2fct = jsimd_extrgb_ycc_convert_avx2;
@@ -197,6 +197,9 @@ jsimd_rgb_gray_convert(j_compress_ptr cinfo, JSAMPARRAY input_buf,
   void (*avx2fct) (JDIMENSION, JSAMPARRAY, JSAMPIMAGE, JDIMENSION, int);
   void (*sse2fct) (JDIMENSION, JSAMPARRAY, JSAMPIMAGE, JDIMENSION, int);
 
+  if (simd_support == ~0U)
+    init_simd();
+
   switch (cinfo->in_color_space) {
   case JCS_EXT_RGB:
     avx2fct = jsimd_extrgb_gray_convert_avx2;
@@ -246,6 +249,9 @@ jsimd_ycc_rgb_convert(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,
   void (*avx2fct) (JDIMENSION, JSAMPIMAGE, JDIMENSION, JSAMPARRAY, int);
   void (*sse2fct) (JDIMENSION, JSAMPIMAGE, JDIMENSION, JSAMPARRAY, int);
 
+  if (simd_support == ~0U)
+    init_simd();
+
   switch (cinfo->out_color_space) {
   case JCS_EXT_RGB:
     avx2fct = jsimd_ycc_extrgb_convert_avx2;
@@ -336,6 +342,9 @@ GLOBAL(void)
 jsimd_h2v2_downsample(j_compress_ptr cinfo, jpeg_component_info *compptr,
                       JSAMPARRAY input_data, JSAMPARRAY output_data)
 {
+  if (simd_support == ~0U)
+    init_simd();
+
   if (simd_support & JSIMD_AVX2)
     jsimd_h2v2_downsample_avx2(cinfo->image_width, cinfo->max_v_samp_factor,
                                compptr->v_samp_factor,
@@ -352,6 +361,9 @@ GLOBAL(void)
 jsimd_h2v1_downsample(j_compress_ptr cinfo, jpeg_component_info *compptr,
                       JSAMPARRAY input_data, JSAMPARRAY output_data)
 {
+  if (simd_support == ~0U)
+    init_simd();
+
   if (simd_support & JSIMD_AVX2)
     jsimd_h2v1_downsample_avx2(cinfo->image_width, cinfo->max_v_samp_factor,
                                compptr->v_samp_factor,
@@ -406,6 +418,9 @@ GLOBAL(void)
 jsimd_h2v2_upsample(j_decompress_ptr cinfo, jpeg_component_info *compptr,
                     JSAMPARRAY input_data, JSAMPARRAY *output_data_ptr)
 {
+  if (simd_support == ~0U)
+    init_simd();
+
   if (simd_support & JSIMD_AVX2)
     jsimd_h2v2_upsample_avx2(cinfo->max_v_samp_factor, cinfo->output_width,
                              input_data, output_data_ptr);
@@ -418,6 +433,9 @@ GLOBAL(void)
 jsimd_h2v1_upsample(j_decompress_ptr cinfo, jpeg_component_info *compptr,
                     JSAMPARRAY input_data, JSAMPARRAY *output_data_ptr)
 {
+  if (simd_support == ~0U)
+    init_simd();
+
   if (simd_support & JSIMD_AVX2)
     jsimd_h2v1_upsample_avx2(cinfo->max_v_samp_factor, cinfo->output_width,
                              input_data, output_data_ptr);
@@ -472,6 +490,9 @@ GLOBAL(void)
 jsimd_h2v2_fancy_upsample(j_decompress_ptr cinfo, jpeg_component_info *compptr,
                           JSAMPARRAY input_data, JSAMPARRAY *output_data_ptr)
 {
+  if (simd_support == ~0U)
+    init_simd();
+
   if (simd_support & JSIMD_AVX2)
     jsimd_h2v2_fancy_upsample_avx2(cinfo->max_v_samp_factor,
                                    compptr->downsampled_width, input_data,
@@ -486,6 +507,9 @@ GLOBAL(void)
 jsimd_h2v1_fancy_upsample(j_decompress_ptr cinfo, jpeg_component_info *compptr,
                           JSAMPARRAY input_data, JSAMPARRAY *output_data_ptr)
 {
+  if (simd_support == ~0U)
+    init_simd();
+
   if (simd_support & JSIMD_AVX2)
     jsimd_h2v1_fancy_upsample_avx2(cinfo->max_v_samp_factor,
                                    compptr->downsampled_width, input_data,
@@ -545,6 +569,9 @@ jsimd_h2v2_merged_upsample(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,
   void (*avx2fct) (JDIMENSION, JSAMPIMAGE, JDIMENSION, JSAMPARRAY);
   void (*sse2fct) (JDIMENSION, JSAMPIMAGE, JDIMENSION, JSAMPARRAY);
 
+  if (simd_support == ~0U)
+    init_simd();
+
   switch (cinfo->out_color_space) {
   case JCS_EXT_RGB:
     avx2fct = jsimd_h2v2_extrgb_merged_upsample_avx2;
@@ -593,6 +620,9 @@ jsimd_h2v1_merged_upsample(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,
   void (*avx2fct) (JDIMENSION, JSAMPIMAGE, JDIMENSION, JSAMPARRAY);
   void (*sse2fct) (JDIMENSION, JSAMPIMAGE, JDIMENSION, JSAMPARRAY);
 
+  if (simd_support == ~0U)
+    init_simd();
+
   switch (cinfo->out_color_space) {
   case JCS_EXT_RGB:
     avx2fct = jsimd_h2v1_extrgb_merged_upsample_avx2;
@@ -682,6 +712,9 @@ GLOBAL(void)
 jsimd_convsamp(JSAMPARRAY sample_data, JDIMENSION start_col,
                DCTELEM *workspace)
 {
+  if (simd_support == ~0U)
+    init_simd();
+
   if (simd_support & JSIMD_AVX2)
     jsimd_convsamp_avx2(sample_data, start_col, workspace);
   else
@@ -751,6 +784,9 @@ jsimd_can_fdct_float(void)
 GLOBAL(void)
 jsimd_fdct_islow(DCTELEM *data)
 {
+  if (simd_support == ~0U)
+    init_simd();
+
   if (simd_support & JSIMD_AVX2)
     jsimd_fdct_islow_avx2(data);
   else
@@ -812,6 +848,9 @@ jsimd_can_quantize_float(void)
 GLOBAL(void)
 jsimd_quantize(JCOEFPTR coef_block, DCTELEM *divisors, DCTELEM *workspace)
 {
+  if (simd_support == ~0U)
+    init_simd();
+
   if (simd_support & JSIMD_AVX2)
     jsimd_quantize_avx2(coef_block, divisors, workspace);
   else
@@ -966,6 +1005,9 @@ jsimd_idct_islow(j_decompress_ptr cinfo, jpeg_component_info *compptr,
                  JCOEFPTR coef_block, JSAMPARRAY output_buf,
                  JDIMENSION output_col)
 {
+  if (simd_support == ~0U)
+    init_simd();
+
   if (simd_support & JSIMD_AVX2)
     jsimd_idct_islow_avx2(compptr->dct_table, coef_block, output_buf,
                           output_col);
@@ -1036,7 +1078,7 @@ jsimd_can_encode_mcu_AC_first_prepare(void)
 GLOBAL(void)
 jsimd_encode_mcu_AC_first_prepare(const JCOEF *block,
                                   const int *jpeg_natural_order_start, int Sl,
-                                  int Al, JCOEF *values, size_t *zerobits)
+                                  int Al, UJCOEF *values, size_t *zerobits)
 {
   jsimd_encode_mcu_AC_first_prepare_sse2(block, jpeg_natural_order_start,
                                          Sl, Al, values, zerobits);
@@ -1060,7 +1102,7 @@ jsimd_can_encode_mcu_AC_refine_prepare(void)
 GLOBAL(int)
 jsimd_encode_mcu_AC_refine_prepare(const JCOEF *block,
                                    const int *jpeg_natural_order_start, int Sl,
-                                   int Al, JCOEF *absvalues, size_t *bits)
+                                   int Al, UJCOEF *absvalues, size_t *bits)
 {
   return jsimd_encode_mcu_AC_refine_prepare_sse2(block,
                                                  jpeg_natural_order_start,
diff --git a/tjbench.c b/tjbench.c
index 90786cf..624127f 100644
--- a/tjbench.c
+++ b/tjbench.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C)2009-2019, 2021-2022 D. R. Commander.  All Rights Reserved.
+ * Copyright (C)2009-2019, 2021-2023 D. R. Commander.  All Rights Reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -82,7 +82,7 @@ int tjErrorLine = -1, tjErrorCode = -1;
 }
 
 int flags = TJFLAG_NOREALLOC, compOnly = 0, decompOnly = 0, doYUV = 0,
-  quiet = 0, doTile = 0, pf = TJPF_BGR, yuvPad = 1, doWrite = 1;
+  quiet = 0, doTile = 0, pf = TJPF_BGR, yuvAlign = 1, doWrite = 1;
 char *ext = "ppm";
 const char *pixFormatStr[TJ_NUMPF] = {
   "RGB", "BGR", "RGBX", "BGRX", "XBGR", "XRGB", "GRAY", "", "", "", "", "CMYK"
@@ -182,7 +182,7 @@ static int decomp(unsigned char *srcBuf, unsigned char **jpegBuf,
   if (doYUV) {
     int width = doTile ? tilew : scaledw;
     int height = doTile ? tileh : scaledh;
-    unsigned long yuvSize = tjBufSizeYUV2(width, yuvPad, height, subsamp);
+    unsigned long yuvSize = tjBufSizeYUV2(width, yuvAlign, height, subsamp);
 
     if (yuvSize == (unsigned long)-1)
       THROW_TJ("allocating YUV buffer");
@@ -209,10 +209,10 @@ static int decomp(unsigned char *srcBuf, unsigned char **jpegBuf,
           double startDecode;
 
           if (tjDecompressToYUV2(handle, jpegBuf[tile], jpegSize[tile], yuvBuf,
-                                 width, yuvPad, height, flags) == -1)
+                                 width, yuvAlign, height, flags) == -1)
             THROW_TJ("executing tjDecompressToYUV2()");
           startDecode = getTime();
-          if (tjDecodeYUV(handle, yuvBuf, yuvPad, subsamp, dstPtr2, width,
+          if (tjDecodeYUV(handle, yuvBuf, yuvAlign, subsamp, dstPtr2, width,
                           pitch, height, pf, flags) == -1)
             THROW_TJ("executing tjDecodeYUV()");
           if (iter >= 0) elapsedDecode += getTime() - startDecode;
@@ -273,12 +273,12 @@ static int decomp(unsigned char *srcBuf, unsigned char **jpegBuf,
              qualStr, sizeStr, ext);
 
   if (tjSaveImage(tempStr, dstBuf, scaledw, 0, scaledh, pf, flags) == -1)
-    THROW_TJG("saving bitmap");
+    THROW_TJG("saving output image");
   ptr = strrchr(tempStr, '.');
   SNPRINTF(ptr, 1024 - (ptr - tempStr), "-err.%s", ext);
   if (srcBuf && sf.num == 1 && sf.denom == 1) {
     if (!quiet) printf("Compression error written to %s.\n", tempStr);
-    if (subsamp == TJ_GRAYSCALE) {
+    if (subsamp == TJSAMP_GRAY) {
       unsigned long index, index2;
 
       for (row = 0, index = 0; row < h; row++, index += pitch) {
@@ -305,7 +305,7 @@ static int decomp(unsigned char *srcBuf, unsigned char **jpegBuf,
                                srcBuf[pitch * row + col]);
     }
     if (tjSaveImage(tempStr, dstBuf, w, 0, h, pf, flags) == -1)
-      THROW_TJG("saving bitmap");
+      THROW_TJG("saving output image");
   }
 
 bailout:
@@ -380,7 +380,7 @@ static int fullTest(unsigned char *srcBuf, int w, int h, int subsamp,
       THROW_TJ("executing tjInitCompress()");
 
     if (doYUV) {
-      yuvSize = tjBufSizeYUV2(tilew, yuvPad, tileh, subsamp);
+      yuvSize = tjBufSizeYUV2(tilew, yuvAlign, tileh, subsamp);
       if (yuvSize == (unsigned long)-1)
         THROW_TJ("allocating YUV buffer");
       if ((yuvBuf = (unsigned char *)malloc(yuvSize)) == NULL)
@@ -407,10 +407,10 @@ static int fullTest(unsigned char *srcBuf, int w, int h, int subsamp,
             double startEncode = getTime();
 
             if (tjEncodeYUV3(handle, srcPtr2, width, pitch, height, pf, yuvBuf,
-                             yuvPad, subsamp, flags) == -1)
+                             yuvAlign, subsamp, flags) == -1)
               THROW_TJ("executing tjEncodeYUV3()");
             if (iter >= 0) elapsedEncode += getTime() - startEncode;
-            if (tjCompressFromYUV(handle, yuvBuf, width, yuvPad, height,
+            if (tjCompressFromYUV(handle, yuvBuf, width, yuvAlign, height,
                                   subsamp, &jpegBuf[tile], &jpegSize[tile],
                                   jpegQual, flags) == -1)
               THROW_TJ("executing tjCompressFromYUV()");
@@ -568,7 +568,7 @@ static int decompTest(char *fileName)
 
   if (quiet == 1) {
     printf("All performance values in Mpixels/sec\n\n");
-    printf("Bitmap     JPEG   JPEG     %s  %s   Xform   Comp    Decomp  ",
+    printf("Pixel      JPEG   JPEG     %s  %s   Xform   Comp    Decomp  ",
            doTile ? "Tile " : "Image", doTile ? "Tile " : "Image");
     if (doYUV) printf("Decode");
     printf("\n");
@@ -630,7 +630,7 @@ static int decompTest(char *fileName)
         tw = h;  th = w;  ttilew = tileh;  ttileh = tilew;
       }
 
-      if (xformOpt & TJXOPT_GRAY) tsubsamp = TJ_GRAYSCALE;
+      if (xformOpt & TJXOPT_GRAY) tsubsamp = TJSAMP_GRAY;
       if (xformOp == TJXOP_HFLIP || xformOp == TJXOP_ROT180)
         tw = tw - (tw % tjMCUWidth[tsubsamp]);
       if (xformOp == TJXOP_VFLIP || xformOp == TJXOP_ROT180)
@@ -750,38 +750,34 @@ static void usage(char *progName)
   int i;
 
   printf("USAGE: %s\n", progName);
-  printf("       <Inputfile (BMP|PPM)> <Quality> [options]\n\n");
+  printf("       <Inputimage (BMP|PPM)> <Quality> [options]\n\n");
   printf("       %s\n", progName);
-  printf("       <Inputfile (JPG)> [options]\n\n");
+  printf("       <Inputimage (JPG)> [options]\n\n");
   printf("Options:\n\n");
-  printf("-alloc = Dynamically allocate JPEG image buffers\n");
-  printf("-bmp = Generate output images in Windows Bitmap format (default = PPM)\n");
-  printf("-bottomup = Test bottom-up compression/decompression\n");
-  printf("-tile = Test performance of the codec when the image is encoded as separate\n");
-  printf("     tiles of varying sizes.\n");
+  printf("-alloc = Dynamically allocate JPEG buffers\n");
+  printf("-bmp = Use Windows Bitmap format for output images [default = PPM]\n");
+  printf("-bottomup = Use bottom-up row order for packed-pixel source/destination buffers\n");
+  printf("-tile = Compress/transform the input image into separate JPEG tiles of varying\n");
+  printf("     sizes (useful for measuring JPEG overhead)\n");
   printf("-rgb, -bgr, -rgbx, -bgrx, -xbgr, -xrgb =\n");
-  printf("     Test the specified color conversion path in the codec (default = BGR)\n");
-  printf("-cmyk = Indirectly test YCCK JPEG compression/decompression (the source\n");
-  printf("     and destination bitmaps are still RGB.  The conversion is done\n");
-  printf("     internally prior to compression or after decompression.)\n");
-  printf("-fastupsample = Use the fastest chrominance upsampling algorithm available in\n");
-  printf("     the underlying codec\n");
-  printf("-fastdct = Use the fastest DCT/IDCT algorithms available in the underlying\n");
-  printf("     codec\n");
-  printf("-accuratedct = Use the most accurate DCT/IDCT algorithms available in the\n");
-  printf("     underlying codec\n");
+  printf("     Use the specified pixel format for packed-pixel source/destination buffers\n");
+  printf("     [default = BGR]\n");
+  printf("-cmyk = Indirectly test YCCK JPEG compression/decompression\n");
+  printf("     (use the CMYK pixel format for packed-pixel source/destination buffers)\n");
+  printf("-fastupsample = Use the fastest chrominance upsampling algorithm available\n");
+  printf("-fastdct = Use the fastest DCT/IDCT algorithm available\n");
+  printf("-accuratedct = Use the most accurate DCT/IDCT algorithm available\n");
   printf("-progressive = Use progressive entropy coding in JPEG images generated by\n");
-  printf("     compression and transform operations.\n");
-  printf("-subsamp <s> = When testing JPEG compression, this option specifies the level\n");
-  printf("     of chrominance subsampling to use (<s> = 444, 422, 440, 420, 411, or\n");
-  printf("     GRAY).  The default is to test Grayscale, 4:2:0, 4:2:2, and 4:4:4 in\n");
-  printf("     sequence.\n");
+  printf("     compression and transform operations\n");
+  printf("-subsamp <s> = When compressing, use the specified level of chrominance\n");
+  printf("     subsampling (<s> = 444, 422, 440, 420, 411, or GRAY) [default = test\n");
+  printf("     Grayscale, 4:2:0, 4:2:2, and 4:4:4 in sequence]\n");
   printf("-quiet = Output results in tabular rather than verbose format\n");
-  printf("-yuv = Test YUV encoding/decoding functions\n");
-  printf("-yuvpad <p> = If testing YUV encoding/decoding, this specifies the number of\n");
-  printf("     bytes to which each row of each plane in the intermediate YUV image is\n");
-  printf("     padded (default = 1)\n");
-  printf("-scale M/N = Scale down the width/height of the decompressed JPEG image by a\n");
+  printf("-yuv = Compress from/decompress to intermediate planar YUV images\n");
+  printf("-yuvpad <p> = The number of bytes by which each row in each plane of an\n");
+  printf("     intermediate YUV image is evenly divisible (must be a power of 2)\n");
+  printf("     [default = 1]\n");
+  printf("-scale M/N = When decompressing, scale the width/height of the JPEG image by a\n");
   printf("     factor of M/N (M/N = ");
   for (i = 0; i < nsf; i++) {
     printf("%d/%d", scalingFactors[i].num, scalingFactors[i].denom);
@@ -794,24 +790,24 @@ static void usage(char *progName)
   }
   printf(")\n");
   printf("-hflip, -vflip, -transpose, -transverse, -rot90, -rot180, -rot270 =\n");
-  printf("     Perform the corresponding lossless transform prior to\n");
-  printf("     decompression (these options are mutually exclusive)\n");
-  printf("-grayscale = Perform lossless grayscale conversion prior to decompression\n");
-  printf("     test (can be combined with the other transforms above)\n");
+  printf("     Perform the specified lossless transform operation on the input image\n");
+  printf("     prior to decompression (these operations are mutually exclusive)\n");
+  printf("-grayscale = Transform the input image into a grayscale JPEG image prior to\n");
+  printf("     decompression (can be combined with the other transform operations above)\n");
   printf("-copynone = Do not copy any extra markers (including EXIF and ICC profile data)\n");
-  printf("     when transforming the image.\n");
-  printf("-benchtime <t> = Run each benchmark for at least <t> seconds (default = 5.0)\n");
-  printf("-warmup <t> = Run each benchmark for <t> seconds (default = 1.0) prior to\n");
+  printf("     when transforming the input image\n");
+  printf("-benchtime <t> = Run each benchmark for at least <t> seconds [default = 5.0]\n");
+  printf("-warmup <t> = Run each benchmark for <t> seconds [default = 1.0] prior to\n");
   printf("     starting the timer, in order to prime the caches and thus improve the\n");
-  printf("     consistency of the results.\n");
+  printf("     consistency of the benchmark results\n");
   printf("-componly = Stop after running compression tests.  Do not test decompression.\n");
   printf("-nowrite = Do not write reference or output images (improves consistency of\n");
-  printf("     performance measurements.)\n");
+  printf("     benchmark results)\n");
   printf("-limitscans = Refuse to decompress or transform progressive JPEG images that\n");
   printf("     have an unreasonably large number of scans\n");
   printf("-stoponwarning = Immediately discontinue the current\n");
-  printf("     compression/decompression/transform operation if the underlying codec\n");
-  printf("     throws a warning (non-fatal error)\n\n");
+  printf("     compression/decompression/transform operation if a warning (non-fatal\n");
+  printf("     error) occurs\n\n");
   printf("NOTE:  If the quality is specified as a range (e.g. 90-100), a separate\n");
   printf("test will be performed for all quality values in the range.\n\n");
   exit(1);
@@ -857,7 +853,7 @@ int main(int argc, char *argv[])
       if (!strcasecmp(argv[i], "-tile")) {
         doTile = 1;  xformOpt |= TJXOPT_CROP;
       } else if (!strcasecmp(argv[i], "-fastupsample")) {
-        printf("Using fast upsampling code\n\n");
+        printf("Using fastest upsampling algorithm\n\n");
         flags |= TJFLAG_FASTUPSAMPLE;
       } else if (!strcasecmp(argv[i], "-fastdct")) {
         printf("Using fastest DCT/IDCT algorithm\n\n");
@@ -868,6 +864,7 @@ int main(int argc, char *argv[])
       } else if (!strcasecmp(argv[i], "-progressive")) {
         printf("Using progressive entropy coding\n\n");
         flags |= TJFLAG_PROGRESSIVE;
+        xformOpt |= TJXOPT_PROGRESSIVE;
       } else if (!strcasecmp(argv[i], "-rgb"))
         pf = TJPF_RGB;
       else if (!strcasecmp(argv[i], "-rgbx"))
@@ -940,12 +937,13 @@ int main(int argc, char *argv[])
       else if (!strcasecmp(argv[i], "-bmp"))
         ext = "bmp";
       else if (!strcasecmp(argv[i], "-yuv")) {
-        printf("Testing YUV planar encoding/decoding\n\n");
+        printf("Testing planar YUV encoding/decoding\n\n");
         doYUV = 1;
       } else if (!strcasecmp(argv[i], "-yuvpad") && i < argc - 1) {
         int tempi = atoi(argv[++i]);
 
-        if (tempi >= 1) yuvPad = tempi;
+        if (tempi >= 1 && (tempi & (tempi - 1)) == 0) yuvAlign = tempi;
+        else usage(argv[0]);
       } else if (!strcasecmp(argv[i], "-subsamp") && i < argc - 1) {
         i++;
         if (toupper(argv[i][0]) == 'G') subsamp = TJSAMP_GRAY;
@@ -958,6 +956,7 @@ int main(int argc, char *argv[])
           case 440:  subsamp = TJSAMP_440;  break;
           case 420:  subsamp = TJSAMP_420;  break;
           case 411:  subsamp = TJSAMP_411;  break;
+          default:  usage(argv[0]);
           }
         }
       } else if (!strcasecmp(argv[i], "-componly"))
@@ -974,26 +973,26 @@ int main(int argc, char *argv[])
 
   if ((sf.num != 1 || sf.denom != 1) && doTile) {
     printf("Disabling tiled compression/decompression tests, because those tests do not\n");
-    printf("work when scaled decompression is enabled.\n");
-    doTile = 0;
+    printf("work when scaled decompression is enabled.\n\n");
+    doTile = 0;  xformOpt &= (~TJXOPT_CROP);
   }
 
   if ((flags & TJFLAG_NOREALLOC) == 0 && doTile) {
     printf("Disabling tiled compression/decompression tests, because those tests do not\n");
     printf("work when dynamic JPEG buffer allocation is enabled.\n\n");
-    doTile = 0;
+    doTile = 0;  xformOpt &= (~TJXOPT_CROP);
   }
 
   if (!decompOnly) {
     if ((srcBuf = tjLoadImage(argv[1], &w, 1, &h, &pf, flags)) == NULL)
-      THROW_TJG("loading bitmap");
+      THROW_TJG("loading input image");
     temp = strrchr(argv[1], '.');
     if (temp != NULL) *temp = '\0';
   }
 
   if (quiet == 1 && !decompOnly) {
     printf("All performance values in Mpixels/sec\n\n");
-    printf("Bitmap     JPEG     JPEG  %s  %s   ",
+    printf("Pixel      JPEG     JPEG  %s  %s   ",
            doTile ? "Tile " : "Image", doTile ? "Tile " : "Image");
     if (doYUV) printf("Encode  ");
     printf("Comp    Comp    Decomp  ");
diff --git a/tjexample.c b/tjexample.c
index 505c9dd..0943725 100644
--- a/tjexample.c
+++ b/tjexample.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C)2011-2012, 2014-2015, 2017, 2019, 2021-2022
+ * Copyright (C)2011-2012, 2014-2015, 2017, 2019, 2021-2023
  *           D. R. Commander.  All Rights Reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -149,14 +149,11 @@ static void usage(char *programName)
   printf("General Options\n");
   printf("---------------\n\n");
 
-  printf("-fastupsample = Use the fastest chrominance upsampling algorithm available in\n");
-  printf("     the underlying codec.\n\n");
+  printf("-fastupsample = Use the fastest chrominance upsampling algorithm available\n\n");
 
-  printf("-fastdct = Use the fastest DCT/IDCT algorithms available in the underlying\n");
-  printf("     codec.\n\n");
+  printf("-fastdct = Use the fastest DCT/IDCT algorithm available\n\n");
 
-  printf("-accuratedct = Use the most accurate DCT/IDCT algorithms available in the\n");
-  printf("     underlying codec.\n\n");
+  printf("-accuratedct = Use the most accurate DCT/IDCT algorithm available\n\n");
 
   exit(1);
 }
diff --git a/tjunittest.c b/tjunittest.c
index b3f0311..0082149 100644
--- a/tjunittest.c
+++ b/tjunittest.c
@@ -1,6 +1,6 @@
 /*
- * Copyright (C)2009-2014, 2017-2019, 2022 D. R. Commander.
- *                                         All Rights Reserved.
+ * Copyright (C)2009-2014, 2017-2019, 2022-2023 D. R. Commander.
+ *                                              All Rights Reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -38,6 +38,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <limits.h>
 #include <errno.h>
 #include "tjutil.h"
 #include "turbojpeg.h"
@@ -55,11 +56,11 @@ static void usage(char *progName)
 {
   printf("\nUSAGE: %s [options]\n\n", progName);
   printf("Options:\n");
-  printf("-yuv = test YUV encoding/decoding support\n");
-  printf("-noyuvpad = do not pad each line of each Y, U, and V plane to the nearest\n");
-  printf("            4-byte boundary\n");
-  printf("-alloc = test automatic buffer allocation\n");
-  printf("-bmp = tjLoadImage()/tjSaveImage() unit test\n\n");
+  printf("-yuv = test YUV encoding/compression/decompression/decoding\n");
+  printf("-noyuvpad = do not pad each row in each Y, U, and V plane to the nearest\n");
+  printf("            multiple of 4 bytes\n");
+  printf("-alloc = test automatic JPEG buffer allocation\n");
+  printf("-bmp = test packed-pixel image I/O\n");
   exit(1);
 }
 
@@ -95,7 +96,7 @@ const int _4byteFormats[] = {
 const int _onlyGray[] = { TJPF_GRAY };
 const int _onlyRGB[] = { TJPF_RGB };
 
-int doYUV = 0, alloc = 0, pad = 4;
+int doYUV = 0, alloc = 0, yuvAlign = 4;
 
 int exitStatus = 0;
 #define BAILOUT() { exitStatus = -1;  goto bailout; }
@@ -282,7 +283,7 @@ static int checkBufYUV(unsigned char *buf, int w, int h, int subsamp,
   int hsf = tjMCUWidth[subsamp] / 8, vsf = tjMCUHeight[subsamp] / 8;
   int pw = PAD(w, hsf), ph = PAD(h, vsf);
   int cw = pw / hsf, ch = ph / vsf;
-  int ypitch = PAD(pw, pad), uvpitch = PAD(cw, pad);
+  int ypitch = PAD(pw, yuvAlign), uvpitch = PAD(cw, yuvAlign);
   int retval = 1;
   int halfway = 16 * sf.num / sf.denom;
   int blocksize = 8 * sf.num / sf.denom;
@@ -381,7 +382,7 @@ static void compTest(tjhandle handle, unsigned char **dstBuf,
 
   if (!alloc) flags |= TJFLAG_NOREALLOC;
   if (doYUV) {
-    unsigned long yuvSize = tjBufSizeYUV2(w, pad, h, subsamp);
+    unsigned long yuvSize = tjBufSizeYUV2(w, yuvAlign, h, subsamp);
     tjscalingfactor sf = { 1, 1 };
     tjhandle handle2 = tjInitCompress();
 
@@ -392,15 +393,15 @@ static void compTest(tjhandle handle, unsigned char **dstBuf,
     memset(yuvBuf, 0, yuvSize);
 
     printf("%s %s -> YUV %s ... ", pfStr, buStrLong, subNameLong[subsamp]);
-    TRY_TJ(tjEncodeYUV3(handle2, srcBuf, w, 0, h, pf, yuvBuf, pad, subsamp,
-                        flags));
+    TRY_TJ(tjEncodeYUV3(handle2, srcBuf, w, 0, h, pf, yuvBuf, yuvAlign,
+                        subsamp, flags));
     tjDestroy(handle2);
     if (checkBufYUV(yuvBuf, w, h, subsamp, sf)) printf("Passed.\n");
     else printf("FAILED!\n");
 
     printf("YUV %s %s -> JPEG Q%d ... ", subNameLong[subsamp], buStrLong,
            jpegQual);
-    TRY_TJ(tjCompressFromYUV(handle, yuvBuf, w, pad, h, subsamp, dstBuf,
+    TRY_TJ(tjCompressFromYUV(handle, yuvBuf, w, yuvAlign, h, subsamp, dstBuf,
                              dstSize, jpegQual, flags));
   } else {
     printf("%s %s -> %s Q%d ... ", pfStr, buStrLong, subNameLong[subsamp],
@@ -442,7 +443,7 @@ static void _decompTest(tjhandle handle, unsigned char *jpegBuf,
   memset(dstBuf, 0, dstSize);
 
   if (doYUV) {
-    unsigned long yuvSize = tjBufSizeYUV2(scaledWidth, pad, scaledHeight,
+    unsigned long yuvSize = tjBufSizeYUV2(scaledWidth, yuvAlign, scaledHeight,
                                           subsamp);
     tjhandle handle2 = tjInitDecompress();
 
@@ -456,16 +457,20 @@ static void _decompTest(tjhandle handle, unsigned char *jpegBuf,
     if (sf.num != 1 || sf.denom != 1)
       printf("%d/%d ... ", sf.num, sf.denom);
     else printf("... ");
-    TRY_TJ(tjDecompressToYUV2(handle, jpegBuf, jpegSize, yuvBuf, scaledWidth,
-                              pad, scaledHeight, flags));
+    /* We pass scaledWidth + 1 and scaledHeight + 1 to validate that
+       tjDecompressToYUV2() generates the largest possible scaled image that
+       fits within the desired dimensions, as documented. */
+    TRY_TJ(tjDecompressToYUV2(handle, jpegBuf, jpegSize, yuvBuf,
+                              scaledWidth + 1, yuvAlign, scaledHeight + 1,
+                              flags));
     if (checkBufYUV(yuvBuf, scaledWidth, scaledHeight, subsamp, sf))
       printf("Passed.\n");
     else printf("FAILED!\n");
 
     printf("YUV %s -> %s %s ... ", subNameLong[subsamp], pixFormatStr[pf],
            (flags & TJFLAG_BOTTOMUP) ? "Bottom-Up" : "Top-Down ");
-    TRY_TJ(tjDecodeYUV(handle2, yuvBuf, pad, subsamp, dstBuf, scaledWidth, 0,
-                       scaledHeight, pf, flags));
+    TRY_TJ(tjDecodeYUV(handle2, yuvBuf, yuvAlign, subsamp, dstBuf, scaledWidth,
+                       0, scaledHeight, pf, flags));
     tjDestroy(handle2);
   } else {
     printf("JPEG -> %s %s ", pixFormatStr[pf],
@@ -473,8 +478,11 @@ static void _decompTest(tjhandle handle, unsigned char *jpegBuf,
     if (sf.num != 1 || sf.denom != 1)
       printf("%d/%d ... ", sf.num, sf.denom);
     else printf("... ");
-    TRY_TJ(tjDecompress2(handle, jpegBuf, jpegSize, dstBuf, scaledWidth, 0,
-                         scaledHeight, pf, flags));
+    /* We pass scaledWidth + 1 and scaledHeight + 1 to validate that
+       tjDecompress2() generates the largest possible scaled image that fits
+       within the desired dimensions, as documented. */
+    TRY_TJ(tjDecompress2(handle, jpegBuf, jpegSize, dstBuf, scaledWidth + 1, 0,
+                         scaledHeight + 1, pf, flags));
   }
 
   if (checkBuf(dstBuf, scaledWidth, scaledHeight, pf, subsamp, sf, flags))
@@ -571,11 +579,16 @@ bailout:
     THROW(#function " overflow"); \
 }
 #endif
+#define CHECKSIZEINT(function) { \
+  if (intsize != -1 || !strcmp(tjGetErrorStr2(NULL), "No error")) \
+    THROW(#function " overflow"); \
+}
 
 static void overflowTest(void)
 {
   /* Ensure that the various buffer size functions don't overflow */
   unsigned long size;
+  int intsize;
 
   size = tjBufSize(26755, 26755, TJSAMP_444);
   CHECKSIZE(tjBufSize());
@@ -583,12 +596,20 @@ static void overflowTest(void)
   CHECKSIZE(TJBUFSIZE());
   size = tjBufSizeYUV2(37838, 1, 37838, TJSAMP_444);
   CHECKSIZE(tjBufSizeYUV2());
+  size = tjBufSizeYUV2(37837, 3, 37837, TJSAMP_444);
+  CHECKSIZE(tjBufSizeYUV2());
+  size = tjBufSizeYUV2(37837, -1, 37837, TJSAMP_444);
+  CHECKSIZE(tjBufSizeYUV2());
   size = TJBUFSIZEYUV(37838, 37838, TJSAMP_444);
   CHECKSIZE(TJBUFSIZEYUV());
   size = tjBufSizeYUV(37838, 37838, TJSAMP_444);
   CHECKSIZE(tjBufSizeYUV());
   size = tjPlaneSizeYUV(0, 65536, 0, 65536, TJSAMP_444);
   CHECKSIZE(tjPlaneSizeYUV());
+  intsize = tjPlaneWidth(0, INT_MAX, TJSAMP_420);
+  CHECKSIZEINT(tjPlaneWidth());
+  intsize = tjPlaneHeight(0, INT_MAX, TJSAMP_420);
+  CHECKSIZEINT(tjPlaneHeight());
 
 bailout:
   return;
@@ -614,7 +635,7 @@ static void bufSizeTest(void)
         if ((srcBuf = (unsigned char *)malloc(w * h * 4)) == NULL)
           THROW("Memory allocation failure");
         if (!alloc || doYUV) {
-          if (doYUV) dstSize = tjBufSizeYUV2(w, pad, h, subsamp);
+          if (doYUV) dstSize = tjBufSizeYUV2(w, yuvAlign, h, subsamp);
           else dstSize = tjBufSize(w, h, subsamp);
           if ((dstBuf = (unsigned char *)tjAlloc(dstSize)) == NULL)
             THROW("Memory allocation failure");
@@ -626,8 +647,8 @@ static void bufSizeTest(void)
         }
 
         if (doYUV) {
-          TRY_TJ(tjEncodeYUV3(handle, srcBuf, w, 0, h, TJPF_BGRX, dstBuf, pad,
-                              subsamp, 0));
+          TRY_TJ(tjEncodeYUV3(handle, srcBuf, w, 0, h, TJPF_BGRX, dstBuf,
+                              yuvAlign, subsamp, 0));
         } else {
           TRY_TJ(tjCompress2(handle, srcBuf, w, 0, h, TJPF_BGRX, &dstBuf,
                              &dstSize, subsamp, 100,
@@ -641,7 +662,7 @@ static void bufSizeTest(void)
         if ((srcBuf = (unsigned char *)malloc(h * w * 4)) == NULL)
           THROW("Memory allocation failure");
         if (!alloc || doYUV) {
-          if (doYUV) dstSize = tjBufSizeYUV2(h, pad, w, subsamp);
+          if (doYUV) dstSize = tjBufSizeYUV2(h, yuvAlign, w, subsamp);
           else dstSize = tjBufSize(h, w, subsamp);
           if ((dstBuf = (unsigned char *)tjAlloc(dstSize)) == NULL)
             THROW("Memory allocation failure");
@@ -653,8 +674,8 @@ static void bufSizeTest(void)
         }
 
         if (doYUV) {
-          TRY_TJ(tjEncodeYUV3(handle, srcBuf, h, 0, w, TJPF_BGRX, dstBuf, pad,
-                              subsamp, 0));
+          TRY_TJ(tjEncodeYUV3(handle, srcBuf, h, 0, w, TJPF_BGRX, dstBuf,
+                              yuvAlign, subsamp, 0));
         } else {
           TRY_TJ(tjCompress2(handle, srcBuf, h, 0, w, TJPF_BGRX, &dstBuf,
                              &dstSize, subsamp, 100,
@@ -898,7 +919,7 @@ int main(int argc, char *argv[])
   if (argc > 1) {
     for (i = 1; i < argc; i++) {
       if (!strcasecmp(argv[i], "-yuv")) doYUV = 1;
-      else if (!strcasecmp(argv[i], "-noyuvpad")) pad = 1;
+      else if (!strcasecmp(argv[i], "-noyuvpad")) yuvAlign = 1;
       else if (!strcasecmp(argv[i], "-alloc")) alloc = 1;
       else if (!strcasecmp(argv[i], "-bmp")) return bmpTest();
       else usage(argv[0]);
diff --git a/transupp.c b/transupp.c
index a3d878c..78dc91b 100644
--- a/transupp.c
+++ b/transupp.c
@@ -143,7 +143,7 @@ requant_comp(j_decompress_ptr cinfo, jpeg_component_info *compptr,
         for (k = 0; k < DCTSIZE2; k++) {
           temp = qtblptr->quantval[k];
           qval = qtblptr1->quantval[k];
-          if (temp != qval) {
+          if (temp != qval && qval != 0) {
             temp *= ptr[k];
             /* The following quantization code is copied from jcdctmgr.c */
 #ifdef FAST_DIVIDE
diff --git a/turbojpeg-jni.c b/turbojpeg-jni.c
index 0cf5f70..446cbd2 100644
--- a/turbojpeg-jni.c
+++ b/turbojpeg-jni.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C)2011-2022 D. R. Commander.  All Rights Reserved.
+ * Copyright (C)2011-2023 D. R. Commander.  All Rights Reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -26,6 +26,7 @@
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
+#include <limits.h>
 #include "turbojpeg.h"
 #include "jinclude.h"
 #include <jni.h>
@@ -132,24 +133,28 @@ bailout:
 JNIEXPORT jint JNICALL Java_org_libjpegturbo_turbojpeg_TJ_bufSize
   (JNIEnv *env, jclass cls, jint width, jint height, jint jpegSubsamp)
 {
-  jint retval = (jint)tjBufSize(width, height, jpegSubsamp);
+  unsigned long retval = tjBufSize(width, height, jpegSubsamp);
 
-  if (retval == -1) THROW_ARG(tjGetErrorStr());
+  if (retval == (unsigned long)-1) THROW_ARG(tjGetErrorStr());
+  if (retval > (unsigned long)INT_MAX)
+    THROW_ARG("Image is too large");
 
 bailout:
-  return retval;
+  return (jint)retval;
 }
 
 /* TurboJPEG 1.4.x: TJ::bufSizeYUV() */
 JNIEXPORT jint JNICALL Java_org_libjpegturbo_turbojpeg_TJ_bufSizeYUV__IIII
-  (JNIEnv *env, jclass cls, jint width, jint pad, jint height, jint subsamp)
+  (JNIEnv *env, jclass cls, jint width, jint align, jint height, jint subsamp)
 {
-  jint retval = (jint)tjBufSizeYUV2(width, pad, height, subsamp);
+  unsigned long retval = tjBufSizeYUV2(width, align, height, subsamp);
 
-  if (retval == -1) THROW_ARG(tjGetErrorStr());
+  if (retval == (unsigned long)-1) THROW_ARG(tjGetErrorStr());
+  if (retval > (unsigned long)INT_MAX)
+    THROW_ARG("Image is too large");
 
 bailout:
-  return retval;
+  return (jint)retval;
 }
 
 /* TurboJPEG 1.2.x: TJ::bufSizeYUV() */
@@ -166,13 +171,15 @@ JNIEXPORT jint JNICALL Java_org_libjpegturbo_turbojpeg_TJ_planeSizeYUV__IIIII
   (JNIEnv *env, jclass cls, jint componentID, jint width, jint stride,
    jint height, jint subsamp)
 {
-  jint retval = (jint)tjPlaneSizeYUV(componentID, width, stride, height,
-                                     subsamp);
+  unsigned long retval = tjPlaneSizeYUV(componentID, width, stride, height,
+                                        subsamp);
 
-  if (retval == -1) THROW_ARG(tjGetErrorStr());
+  if (retval == (unsigned long)-1) THROW_ARG(tjGetErrorStr());
+  if (retval > (unsigned long)INT_MAX)
+    THROW_ARG("Image is too large");
 
 bailout:
-  return retval;
+  return (jint)retval;
 }
 
 /* TurboJPEG 1.4.x: TJ::planeWidth() */
diff --git a/turbojpeg-mapfile b/turbojpeg-mapfile
index 5477fed..07a429b 100644
--- a/turbojpeg-mapfile
+++ b/turbojpeg-mapfile
@@ -1,14 +1,14 @@
 TURBOJPEG_1.0
 {
   global:
-    tjInitCompress;
-    tjCompress;
     TJBUFSIZE;
-    tjInitDecompress;
-    tjDecompressHeader;
+    tjCompress;
     tjDecompress;
+    tjDecompressHeader;
     tjDestroy;
     tjGetErrorStr;
+    tjInitCompress;
+    tjInitDecompress;
   local:
     *;
 };
diff --git a/turbojpeg-mapfile.jni b/turbojpeg-mapfile.jni
index 4432791..4ae25aa 100644
--- a/turbojpeg-mapfile.jni
+++ b/turbojpeg-mapfile.jni
@@ -1,14 +1,14 @@
 TURBOJPEG_1.0
 {
   global:
-    tjInitCompress;
-    tjCompress;
     TJBUFSIZE;
-    tjInitDecompress;
-    tjDecompressHeader;
+    tjCompress;
     tjDecompress;
+    tjDecompressHeader;
     tjDestroy;
     tjGetErrorStr;
+    tjInitCompress;
+    tjInitDecompress;
   local:
     *;
 };
diff --git a/turbojpeg.c b/turbojpeg.c
index a1544f2..b5498dc 100644
--- a/turbojpeg.c
+++ b/turbojpeg.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C)2009-2022 D. R. Commander.  All Rights Reserved.
+ * Copyright (C)2009-2023 D. R. Commander.  All Rights Reserved.
  * Copyright (C)2021 Alex Richardson.  All Rights Reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -31,6 +31,7 @@
    libjpeg-turbo */
 
 #include <ctype.h>
+#include <limits.h>
 #include <jinclude.h>
 #define JPEG_INTERNALS
 #include <jpeglib.h>
@@ -42,7 +43,6 @@
 #include "transupp.h"
 #include "./jpegcomp.h"
 #include "./cdjpeg.h"
-#include "jconfigint.h"
 
 extern void jpeg_mem_dest_tj(j_compress_ptr, unsigned char **, unsigned long *,
                              boolean);
@@ -98,7 +98,7 @@ static void my_emit_message(j_common_ptr cinfo, int msg_level)
 }
 
 
-/* Global structures, macros, etc. */
+/********************** Global structures, macros, etc. **********************/
 
 enum { COMPRESS = 1, DECOMPRESS = 2 };
 
@@ -324,11 +324,13 @@ static void setCompDefaults(struct jpeg_compress_struct *cinfo,
   else
     jpeg_set_colorspace(cinfo, JCS_YCbCr);
 
+#ifdef C_PROGRESSIVE_SUPPORTED
   if (flags & TJFLAG_PROGRESSIVE)
     jpeg_simple_progression(cinfo);
 #ifndef NO_GETENV
   else if (!GETENV_S(env, 7, "TJ_PROGRESSIVE") && !strcmp(env, "1"))
     jpeg_simple_progression(cinfo);
+#endif
 #endif
 
   cinfo->comp_info[0].h_samp_factor = tjMCUWidth[subsamp] / 8;
@@ -355,7 +357,7 @@ static int getSubsamp(j_decompress_ptr dinfo)
   if (dinfo->num_components == 1 && dinfo->jpeg_color_space == JCS_GRAYSCALE)
     return TJSAMP_GRAY;
 
-  for (i = 0; i < NUMSUBOPT; i++) {
+  for (i = 0; i < TJ_NUMSAMP; i++) {
     if (dinfo->num_components == pixelsize[i] ||
         ((dinfo->jpeg_color_space == JCS_YCCK ||
           dinfo->jpeg_color_space == JCS_CMYK) &&
@@ -424,8 +426,9 @@ static int getSubsamp(j_decompress_ptr dinfo)
 }
 
 
-/* General API functions */
+/*************************** General API functions ***************************/
 
+/* TurboJPEG 2.0+ */
 DLLEXPORT char *tjGetErrorStr2(tjhandle handle)
 {
   tjinstance *this = (tjinstance *)handle;
@@ -438,12 +441,14 @@ DLLEXPORT char *tjGetErrorStr2(tjhandle handle)
 }
 
 
+/* TurboJPEG 1.0+ */
 DLLEXPORT char *tjGetErrorStr(void)
 {
   return errStr;
 }
 
 
+/* TurboJPEG 2.0+ */
 DLLEXPORT int tjGetErrorCode(tjhandle handle)
 {
   tjinstance *this = (tjinstance *)handle;
@@ -453,6 +458,7 @@ DLLEXPORT int tjGetErrorCode(tjhandle handle)
 }
 
 
+/* TurboJPEG 1.0+ */
 DLLEXPORT int tjDestroy(tjhandle handle)
 {
   GET_INSTANCE(handle);
@@ -470,19 +476,21 @@ DLLEXPORT int tjDestroy(tjhandle handle)
    with turbojpeg.dll for compatibility reasons.  However, these functions
    can potentially be used for other purposes by different implementations. */
 
+/* TurboJPEG 1.2+ */
 DLLEXPORT void tjFree(unsigned char *buf)
 {
   free(buf);
 }
 
 
+/* TurboJPEG 1.2+ */
 DLLEXPORT unsigned char *tjAlloc(int bytes)
 {
   return (unsigned char *)malloc(bytes);
 }
 
 
-/* Compressor  */
+/******************************** Compressor *********************************/
 
 static tjhandle _tjInitCompress(tjinstance *this)
 {
@@ -514,6 +522,7 @@ static tjhandle _tjInitCompress(tjinstance *this)
   return (tjhandle)this;
 }
 
+/* TurboJPEG 1.0+ */
 DLLEXPORT tjhandle tjInitCompress(void)
 {
   tjinstance *this = NULL;
@@ -529,12 +538,13 @@ DLLEXPORT tjhandle tjInitCompress(void)
 }
 
 
+/* TurboJPEG 1.2+ */
 DLLEXPORT unsigned long tjBufSize(int width, int height, int jpegSubsamp)
 {
   unsigned long long retval = 0;
   int mcuw, mcuh, chromasf;
 
-  if (width < 1 || height < 1 || jpegSubsamp < 0 || jpegSubsamp >= NUMSUBOPT)
+  if (width < 1 || height < 1 || jpegSubsamp < 0 || jpegSubsamp >= TJ_NUMSAMP)
     THROWG("tjBufSize(): Invalid argument");
 
   /* This allows for rare corner cases in which a JPEG image can actually be
@@ -551,6 +561,7 @@ bailout:
   return (unsigned long)retval;
 }
 
+/* TurboJPEG 1.0+ */
 DLLEXPORT unsigned long TJBUFSIZE(int width, int height)
 {
   unsigned long long retval = 0;
@@ -570,19 +581,20 @@ bailout:
 }
 
 
-DLLEXPORT unsigned long tjBufSizeYUV2(int width, int pad, int height,
+/* TurboJPEG 1.4+ */
+DLLEXPORT unsigned long tjBufSizeYUV2(int width, int align, int height,
                                       int subsamp)
 {
   unsigned long long retval = 0;
   int nc, i;
 
-  if (subsamp < 0 || subsamp >= NUMSUBOPT)
+  if (align < 1 || !IS_POW2(align) || subsamp < 0 || subsamp >= TJ_NUMSAMP)
     THROWG("tjBufSizeYUV2(): Invalid argument");
 
   nc = (subsamp == TJSAMP_GRAY ? 1 : 3);
   for (i = 0; i < nc; i++) {
     int pw = tjPlaneWidth(i, width, subsamp);
-    int stride = PAD(pw, pad);
+    int stride = PAD(pw, align);
     int ph = tjPlaneHeight(i, height, subsamp);
 
     if (pw < 0 || ph < 0) return -1;
@@ -595,20 +607,24 @@ bailout:
   return (unsigned long)retval;
 }
 
+/* TurboJPEG 1.2+ */
 DLLEXPORT unsigned long tjBufSizeYUV(int width, int height, int subsamp)
 {
   return tjBufSizeYUV2(width, 4, height, subsamp);
 }
 
+/* TurboJPEG 1.1+ */
 DLLEXPORT unsigned long TJBUFSIZEYUV(int width, int height, int subsamp)
 {
   return tjBufSizeYUV(width, height, subsamp);
 }
 
 
+/* TurboJPEG 1.4+ */
 DLLEXPORT int tjPlaneWidth(int componentID, int width, int subsamp)
 {
-  int pw, nc, retval = 0;
+  unsigned long long pw, retval = 0;
+  int nc;
 
   if (width < 1 || subsamp < 0 || subsamp >= TJ_NUMSAMP)
     THROWG("tjPlaneWidth(): Invalid argument");
@@ -616,20 +632,25 @@ DLLEXPORT int tjPlaneWidth(int componentID, int width, int subsamp)
   if (componentID < 0 || componentID >= nc)
     THROWG("tjPlaneWidth(): Invalid argument");
 
-  pw = PAD(width, tjMCUWidth[subsamp] / 8);
+  pw = PAD((unsigned long long)width, tjMCUWidth[subsamp] / 8);
   if (componentID == 0)
     retval = pw;
   else
     retval = pw * 8 / tjMCUWidth[subsamp];
 
+  if (retval > (unsigned long long)INT_MAX)
+    THROWG("tjPlaneWidth(): Width is too large");
+
 bailout:
-  return retval;
+  return (int)retval;
 }
 
 
+/* TurboJPEG 1.4+ */
 DLLEXPORT int tjPlaneHeight(int componentID, int height, int subsamp)
 {
-  int ph, nc, retval = 0;
+  unsigned long long ph, retval = 0;
+  int nc;
 
   if (height < 1 || subsamp < 0 || subsamp >= TJ_NUMSAMP)
     THROWG("tjPlaneHeight(): Invalid argument");
@@ -637,24 +658,28 @@ DLLEXPORT int tjPlaneHeight(int componentID, int height, int subsamp)
   if (componentID < 0 || componentID >= nc)
     THROWG("tjPlaneHeight(): Invalid argument");
 
-  ph = PAD(height, tjMCUHeight[subsamp] / 8);
+  ph = PAD((unsigned long long)height, tjMCUHeight[subsamp] / 8);
   if (componentID == 0)
     retval = ph;
   else
     retval = ph * 8 / tjMCUHeight[subsamp];
 
+  if (retval > (unsigned long long)INT_MAX)
+    THROWG("tjPlaneHeight(): Height is too large");
+
 bailout:
-  return retval;
+  return (int)retval;
 }
 
 
+/* TurboJPEG 1.4+ */
 DLLEXPORT unsigned long tjPlaneSizeYUV(int componentID, int width, int stride,
                                        int height, int subsamp)
 {
   unsigned long long retval = 0;
   int pw, ph;
 
-  if (width < 1 || height < 1 || subsamp < 0 || subsamp >= NUMSUBOPT)
+  if (width < 1 || height < 1 || subsamp < 0 || subsamp >= TJ_NUMSAMP)
     THROWG("tjPlaneSizeYUV(): Invalid argument");
 
   pw = tjPlaneWidth(componentID, width, subsamp);
@@ -673,6 +698,7 @@ bailout:
 }
 
 
+/* TurboJPEG 1.2+ */
 DLLEXPORT int tjCompress2(tjhandle handle, const unsigned char *srcBuf,
                           int width, int pitch, int height, int pixelFormat,
                           unsigned char **jpegBuf, unsigned long *jpegSize,
@@ -689,7 +715,7 @@ DLLEXPORT int tjCompress2(tjhandle handle, const unsigned char *srcBuf,
 
   if (srcBuf == NULL || width <= 0 || pitch < 0 || height <= 0 ||
       pixelFormat < 0 || pixelFormat >= TJ_NUMPF || jpegBuf == NULL ||
-      jpegSize == NULL || jpegSubsamp < 0 || jpegSubsamp >= NUMSUBOPT ||
+      jpegSize == NULL || jpegSubsamp < 0 || jpegSubsamp >= TJ_NUMSAMP ||
       jpegQual < 0 || jpegQual > 100)
     THROW("tjCompress2(): Invalid argument");
 
@@ -741,6 +767,7 @@ bailout:
   return retval;
 }
 
+/* TurboJPEG 1.0+ */
 DLLEXPORT int tjCompress(tjhandle handle, unsigned char *srcBuf, int width,
                          int pitch, int height, int pixelSize,
                          unsigned char *jpegBuf, unsigned long *jpegSize,
@@ -764,6 +791,7 @@ DLLEXPORT int tjCompress(tjhandle handle, unsigned char *srcBuf, int width,
 }
 
 
+/* TurboJPEG 1.4+ */
 DLLEXPORT int tjEncodeYUVPlanes(tjhandle handle, const unsigned char *srcBuf,
                                 int width, int pitch, int height,
                                 int pixelFormat, unsigned char **dstPlanes,
@@ -790,13 +818,13 @@ DLLEXPORT int tjEncodeYUVPlanes(tjhandle handle, const unsigned char *srcBuf,
 
   if (srcBuf == NULL || width <= 0 || pitch < 0 || height <= 0 ||
       pixelFormat < 0 || pixelFormat >= TJ_NUMPF || !dstPlanes ||
-      !dstPlanes[0] || subsamp < 0 || subsamp >= NUMSUBOPT)
+      !dstPlanes[0] || subsamp < 0 || subsamp >= TJ_NUMSAMP)
     THROW("tjEncodeYUVPlanes(): Invalid argument");
   if (subsamp != TJSAMP_GRAY && (!dstPlanes[1] || !dstPlanes[2]))
     THROW("tjEncodeYUVPlanes(): Invalid argument");
 
   if (pixelFormat == TJPF_CMYK)
-    THROW("tjEncodeYUVPlanes(): Cannot generate YUV images from CMYK pixels");
+    THROW("tjEncodeYUVPlanes(): Cannot generate YUV images from packed-pixel CMYK images");
 
   if (pitch == 0) pitch = width * tjPixelSize[pixelFormat];
 
@@ -922,9 +950,10 @@ bailout:
   return retval;
 }
 
+/* TurboJPEG 1.4+ */
 DLLEXPORT int tjEncodeYUV3(tjhandle handle, const unsigned char *srcBuf,
                            int width, int pitch, int height, int pixelFormat,
-                           unsigned char *dstBuf, int pad, int subsamp,
+                           unsigned char *dstBuf, int align, int subsamp,
                            int flags)
 {
   unsigned char *dstPlanes[3];
@@ -934,14 +963,14 @@ DLLEXPORT int tjEncodeYUV3(tjhandle handle, const unsigned char *srcBuf,
   if (!this) THROWG("tjEncodeYUV3(): Invalid handle");
   this->isInstanceError = FALSE;
 
-  if (width <= 0 || height <= 0 || dstBuf == NULL || pad < 0 ||
-      !IS_POW2(pad) || subsamp < 0 || subsamp >= NUMSUBOPT)
+  if (width <= 0 || height <= 0 || dstBuf == NULL || align < 1 ||
+      !IS_POW2(align) || subsamp < 0 || subsamp >= TJ_NUMSAMP)
     THROW("tjEncodeYUV3(): Invalid argument");
 
   pw0 = tjPlaneWidth(0, width, subsamp);
   ph0 = tjPlaneHeight(0, height, subsamp);
   dstPlanes[0] = dstBuf;
-  strides[0] = PAD(pw0, pad);
+  strides[0] = PAD(pw0, align);
   if (subsamp == TJSAMP_GRAY) {
     strides[1] = strides[2] = 0;
     dstPlanes[1] = dstPlanes[2] = NULL;
@@ -949,7 +978,7 @@ DLLEXPORT int tjEncodeYUV3(tjhandle handle, const unsigned char *srcBuf,
     int pw1 = tjPlaneWidth(1, width, subsamp);
     int ph1 = tjPlaneHeight(1, height, subsamp);
 
-    strides[1] = strides[2] = PAD(pw1, pad);
+    strides[1] = strides[2] = PAD(pw1, align);
     dstPlanes[1] = dstPlanes[0] + strides[0] * ph0;
     dstPlanes[2] = dstPlanes[1] + strides[1] * ph1;
   }
@@ -961,6 +990,7 @@ bailout:
   return retval;
 }
 
+/* TurboJPEG 1.2+ */
 DLLEXPORT int tjEncodeYUV2(tjhandle handle, unsigned char *srcBuf, int width,
                            int pitch, int height, int pixelFormat,
                            unsigned char *dstBuf, int subsamp, int flags)
@@ -969,6 +999,7 @@ DLLEXPORT int tjEncodeYUV2(tjhandle handle, unsigned char *srcBuf, int width,
                       dstBuf, 4, subsamp, flags);
 }
 
+/* TurboJPEG 1.1+ */
 DLLEXPORT int tjEncodeYUV(tjhandle handle, unsigned char *srcBuf, int width,
                           int pitch, int height, int pixelSize,
                           unsigned char *dstBuf, int subsamp, int flags)
@@ -979,6 +1010,7 @@ DLLEXPORT int tjEncodeYUV(tjhandle handle, unsigned char *srcBuf, int width,
 }
 
 
+/* TurboJPEG 1.4+ */
 DLLEXPORT int tjCompressFromYUVPlanes(tjhandle handle,
                                       const unsigned char **srcPlanes,
                                       int width, const int *strides,
@@ -1005,7 +1037,7 @@ DLLEXPORT int tjCompressFromYUVPlanes(tjhandle handle,
     THROW("tjCompressFromYUVPlanes(): Instance has not been initialized for compression");
 
   if (!srcPlanes || !srcPlanes[0] || width <= 0 || height <= 0 ||
-      subsamp < 0 || subsamp >= NUMSUBOPT || jpegBuf == NULL ||
+      subsamp < 0 || subsamp >= TJ_NUMSAMP || jpegBuf == NULL ||
       jpegSize == NULL || jpegQual < 0 || jpegQual > 100)
     THROW("tjCompressFromYUVPlanes(): Invalid argument");
   if (subsamp != TJSAMP_GRAY && (!srcPlanes[1] || !srcPlanes[2]))
@@ -1117,8 +1149,9 @@ bailout:
   return retval;
 }
 
+/* TurboJPEG 1.4+ */
 DLLEXPORT int tjCompressFromYUV(tjhandle handle, const unsigned char *srcBuf,
-                                int width, int pad, int height, int subsamp,
+                                int width, int align, int height, int subsamp,
                                 unsigned char **jpegBuf,
                                 unsigned long *jpegSize, int jpegQual,
                                 int flags)
@@ -1130,14 +1163,14 @@ DLLEXPORT int tjCompressFromYUV(tjhandle handle, const unsigned char *srcBuf,
   if (!this) THROWG("tjCompressFromYUV(): Invalid handle");
   this->isInstanceError = FALSE;
 
-  if (srcBuf == NULL || width <= 0 || pad < 1 || height <= 0 || subsamp < 0 ||
-      subsamp >= NUMSUBOPT)
+  if (srcBuf == NULL || width <= 0 || align < 1 || !IS_POW2(align) ||
+      height <= 0 || subsamp < 0 || subsamp >= TJ_NUMSAMP)
     THROW("tjCompressFromYUV(): Invalid argument");
 
   pw0 = tjPlaneWidth(0, width, subsamp);
   ph0 = tjPlaneHeight(0, height, subsamp);
   srcPlanes[0] = srcBuf;
-  strides[0] = PAD(pw0, pad);
+  strides[0] = PAD(pw0, align);
   if (subsamp == TJSAMP_GRAY) {
     strides[1] = strides[2] = 0;
     srcPlanes[1] = srcPlanes[2] = NULL;
@@ -1145,7 +1178,7 @@ DLLEXPORT int tjCompressFromYUV(tjhandle handle, const unsigned char *srcBuf,
     int pw1 = tjPlaneWidth(1, width, subsamp);
     int ph1 = tjPlaneHeight(1, height, subsamp);
 
-    strides[1] = strides[2] = PAD(pw1, pad);
+    strides[1] = strides[2] = PAD(pw1, align);
     srcPlanes[1] = srcPlanes[0] + strides[0] * ph0;
     srcPlanes[2] = srcPlanes[1] + strides[1] * ph1;
   }
@@ -1158,7 +1191,7 @@ bailout:
 }
 
 
-/* Decompressor */
+/******************************* Decompressor ********************************/
 
 static tjhandle _tjInitDecompress(tjinstance *this)
 {
@@ -1188,6 +1221,7 @@ static tjhandle _tjInitDecompress(tjinstance *this)
   return (tjhandle)this;
 }
 
+/* TurboJPEG 1.0+ */
 DLLEXPORT tjhandle tjInitDecompress(void)
 {
   tjinstance *this;
@@ -1203,6 +1237,7 @@ DLLEXPORT tjhandle tjInitDecompress(void)
 }
 
 
+/* TurboJPEG 1.4+ */
 DLLEXPORT int tjDecompressHeader3(tjhandle handle,
                                   const unsigned char *jpegBuf,
                                   unsigned long jpegSize, int *width,
@@ -1259,6 +1294,7 @@ bailout:
   return retval;
 }
 
+/* TurboJPEG 1.1+ */
 DLLEXPORT int tjDecompressHeader2(tjhandle handle, unsigned char *jpegBuf,
                                   unsigned long jpegSize, int *width,
                                   int *height, int *jpegSubsamp)
@@ -1269,6 +1305,7 @@ DLLEXPORT int tjDecompressHeader2(tjhandle handle, unsigned char *jpegBuf,
                              jpegSubsamp, &jpegColorspace);
 }
 
+/* TurboJPEG 1.0+ */
 DLLEXPORT int tjDecompressHeader(tjhandle handle, unsigned char *jpegBuf,
                                  unsigned long jpegSize, int *width,
                                  int *height)
@@ -1280,19 +1317,21 @@ DLLEXPORT int tjDecompressHeader(tjhandle handle, unsigned char *jpegBuf,
 }
 
 
-DLLEXPORT tjscalingfactor *tjGetScalingFactors(int *numscalingfactors)
+/* TurboJPEG 1.2+ */
+DLLEXPORT tjscalingfactor *tjGetScalingFactors(int *numScalingFactors)
 {
-  if (numscalingfactors == NULL) {
+  if (numScalingFactors == NULL) {
     SNPRINTF(errStr, JMSG_LENGTH_MAX,
              "tjGetScalingFactors(): Invalid argument");
     return NULL;
   }
 
-  *numscalingfactors = NUMSF;
+  *numScalingFactors = NUMSF;
   return (tjscalingfactor *)sf;
 }
 
 
+/* TurboJPEG 1.2+ */
 DLLEXPORT int tjDecompress2(tjhandle handle, const unsigned char *jpegBuf,
                             unsigned long jpegSize, unsigned char *dstBuf,
                             int width, int pitch, int height, int pixelFormat,
@@ -1380,6 +1419,7 @@ bailout:
   return retval;
 }
 
+/* TurboJPEG 1.0+ */
 DLLEXPORT int tjDecompress(tjhandle handle, unsigned char *jpegBuf,
                            unsigned long jpegSize, unsigned char *dstBuf,
                            int width, int pitch, int height, int pixelSize,
@@ -1393,8 +1433,8 @@ DLLEXPORT int tjDecompress(tjhandle handle, unsigned char *jpegBuf,
 }
 
 
-static int setDecodeDefaults(struct jpeg_decompress_struct *dinfo,
-                             int pixelFormat, int subsamp, int flags)
+static void setDecodeDefaults(struct jpeg_decompress_struct *dinfo,
+                              int pixelFormat, int subsamp, int flags)
 {
   int i;
 
@@ -1429,8 +1469,6 @@ static int setDecodeDefaults(struct jpeg_decompress_struct *dinfo,
     if (dinfo->quant_tbl_ptrs[i] == NULL)
       dinfo->quant_tbl_ptrs[i] = jpeg_alloc_quant_table((j_common_ptr)dinfo);
   }
-
-  return 0;
 }
 
 
@@ -1443,6 +1481,7 @@ static void my_reset_marker_reader(j_decompress_ptr dinfo)
 {
 }
 
+/* TurboJPEG 1.4+ */
 DLLEXPORT int tjDecodeYUVPlanes(tjhandle handle,
                                 const unsigned char **srcPlanes,
                                 const int *strides, int subsamp,
@@ -1468,7 +1507,7 @@ DLLEXPORT int tjDecodeYUVPlanes(tjhandle handle,
   if ((this->init & DECOMPRESS) == 0)
     THROW("tjDecodeYUVPlanes(): Instance has not been initialized for decompression");
 
-  if (!srcPlanes || !srcPlanes[0] || subsamp < 0 || subsamp >= NUMSUBOPT ||
+  if (!srcPlanes || !srcPlanes[0] || subsamp < 0 || subsamp >= TJ_NUMSAMP ||
       dstBuf == NULL || width <= 0 || pitch < 0 || height <= 0 ||
       pixelFormat < 0 || pixelFormat >= TJ_NUMPF)
     THROW("tjDecodeYUVPlanes(): Invalid argument");
@@ -1481,7 +1520,7 @@ DLLEXPORT int tjDecodeYUVPlanes(tjhandle handle,
   }
 
   if (pixelFormat == TJPF_CMYK)
-    THROW("tjDecodeYUVPlanes(): Cannot decode YUV images into CMYK pixels.");
+    THROW("tjDecodeYUVPlanes(): Cannot decode YUV images into packed-pixel CMYK images.");
 
   if (pitch == 0) pitch = width * tjPixelSize[pixelFormat];
   dinfo->image_width = width;
@@ -1496,9 +1535,7 @@ DLLEXPORT int tjDecodeYUVPlanes(tjhandle handle,
   dinfo->progressive_mode = dinfo->inputctl->has_multiple_scans = FALSE;
   dinfo->Ss = dinfo->Ah = dinfo->Al = 0;
   dinfo->Se = DCTSIZE2 - 1;
-  if (setDecodeDefaults(dinfo, pixelFormat, subsamp, flags) == -1) {
-    retval = -1;  goto bailout;
-  }
+  setDecodeDefaults(dinfo, pixelFormat, subsamp, flags);
   old_read_markers = dinfo->marker->read_markers;
   dinfo->marker->read_markers = my_read_markers;
   old_reset_marker_reader = dinfo->marker->reset_marker_reader;
@@ -1591,8 +1628,9 @@ bailout:
   return retval;
 }
 
+/* TurboJPEG 1.4+ */
 DLLEXPORT int tjDecodeYUV(tjhandle handle, const unsigned char *srcBuf,
-                          int pad, int subsamp, unsigned char *dstBuf,
+                          int align, int subsamp, unsigned char *dstBuf,
                           int width, int pitch, int height, int pixelFormat,
                           int flags)
 {
@@ -1603,14 +1641,14 @@ DLLEXPORT int tjDecodeYUV(tjhandle handle, const unsigned char *srcBuf,
   if (!this) THROWG("tjDecodeYUV(): Invalid handle");
   this->isInstanceError = FALSE;
 
-  if (srcBuf == NULL || pad < 0 || !IS_POW2(pad) || subsamp < 0 ||
-      subsamp >= NUMSUBOPT || width <= 0 || height <= 0)
+  if (srcBuf == NULL || align < 1 || !IS_POW2(align) || subsamp < 0 ||
+      subsamp >= TJ_NUMSAMP || width <= 0 || height <= 0)
     THROW("tjDecodeYUV(): Invalid argument");
 
   pw0 = tjPlaneWidth(0, width, subsamp);
   ph0 = tjPlaneHeight(0, height, subsamp);
   srcPlanes[0] = srcBuf;
-  strides[0] = PAD(pw0, pad);
+  strides[0] = PAD(pw0, align);
   if (subsamp == TJSAMP_GRAY) {
     strides[1] = strides[2] = 0;
     srcPlanes[1] = srcPlanes[2] = NULL;
@@ -1618,7 +1656,7 @@ DLLEXPORT int tjDecodeYUV(tjhandle handle, const unsigned char *srcBuf,
     int pw1 = tjPlaneWidth(1, width, subsamp);
     int ph1 = tjPlaneHeight(1, height, subsamp);
 
-    strides[1] = strides[2] = PAD(pw1, pad);
+    strides[1] = strides[2] = PAD(pw1, align);
     srcPlanes[1] = srcPlanes[0] + strides[0] * ph0;
     srcPlanes[2] = srcPlanes[1] + strides[1] * ph1;
   }
@@ -1630,6 +1668,7 @@ bailout:
   return retval;
 }
 
+/* TurboJPEG 1.4+ */
 DLLEXPORT int tjDecompressToYUVPlanes(tjhandle handle,
                                       const unsigned char *jpegBuf,
                                       unsigned long jpegSize,
@@ -1763,7 +1802,7 @@ DLLEXPORT int tjDecompressToYUVPlanes(tjhandle handle,
     for (i = 0; i < dinfo->num_components; i++) {
       jpeg_component_info *compptr = &dinfo->comp_info[i];
 
-      if (jpegSubsamp == TJ_420) {
+      if (jpegSubsamp == TJSAMP_420) {
         /* When 4:2:0 subsampling is used with IDCT scaling, libjpeg will try
            to be clever and use the IDCT to perform upsampling on the U and V
            planes.  For instance, if the output image is to be scaled by 1/2
@@ -1810,9 +1849,10 @@ bailout:
   return retval;
 }
 
+/* TurboJPEG 1.4+ */
 DLLEXPORT int tjDecompressToYUV2(tjhandle handle, const unsigned char *jpegBuf,
                                  unsigned long jpegSize, unsigned char *dstBuf,
-                                 int width, int pad, int height, int flags)
+                                 int width, int align, int height, int flags)
 {
   unsigned char *dstPlanes[3];
   int pw0, ph0, strides[3], retval = -1, jpegSubsamp = -1;
@@ -1822,7 +1862,7 @@ DLLEXPORT int tjDecompressToYUV2(tjhandle handle, const unsigned char *jpegBuf,
   this->jerr.stopOnWarning = (flags & TJFLAG_STOPONWARNING) ? TRUE : FALSE;
 
   if (jpegBuf == NULL || jpegSize <= 0 || dstBuf == NULL || width < 0 ||
-      pad < 1 || !IS_POW2(pad) || height < 0)
+      align < 1 || !IS_POW2(align) || height < 0)
     THROW("tjDecompressToYUV2(): Invalid argument");
 
   if (setjmp(this->jerr.setjmp_buffer)) {
@@ -1839,7 +1879,6 @@ DLLEXPORT int tjDecompressToYUV2(tjhandle handle, const unsigned char *jpegBuf,
   jpegwidth = dinfo->image_width;  jpegheight = dinfo->image_height;
   if (width == 0) width = jpegwidth;
   if (height == 0) height = jpegheight;
-
   for (i = 0; i < NUMSF; i++) {
     scaledw = TJSCALED(jpegwidth, sf[i]);
     scaledh = TJSCALED(jpegheight, sf[i]);
@@ -1849,10 +1888,12 @@ DLLEXPORT int tjDecompressToYUV2(tjhandle handle, const unsigned char *jpegBuf,
   if (i >= NUMSF)
     THROW("tjDecompressToYUV2(): Could not scale down to desired image dimensions");
 
+  width = scaledw;  height = scaledh;
+
   pw0 = tjPlaneWidth(0, width, jpegSubsamp);
   ph0 = tjPlaneHeight(0, height, jpegSubsamp);
   dstPlanes[0] = dstBuf;
-  strides[0] = PAD(pw0, pad);
+  strides[0] = PAD(pw0, align);
   if (jpegSubsamp == TJSAMP_GRAY) {
     strides[1] = strides[2] = 0;
     dstPlanes[1] = dstPlanes[2] = NULL;
@@ -1860,7 +1901,7 @@ DLLEXPORT int tjDecompressToYUV2(tjhandle handle, const unsigned char *jpegBuf,
     int pw1 = tjPlaneWidth(1, width, jpegSubsamp);
     int ph1 = tjPlaneHeight(1, height, jpegSubsamp);
 
-    strides[1] = strides[2] = PAD(pw1, pad);
+    strides[1] = strides[2] = PAD(pw1, align);
     dstPlanes[1] = dstPlanes[0] + strides[0] * ph0;
     dstPlanes[2] = dstPlanes[1] + strides[1] * ph1;
   }
@@ -1874,6 +1915,7 @@ bailout:
   return retval;
 }
 
+/* TurboJPEG 1.1+ */
 DLLEXPORT int tjDecompressToYUV(tjhandle handle, unsigned char *jpegBuf,
                                 unsigned long jpegSize, unsigned char *dstBuf,
                                 int flags)
@@ -1882,8 +1924,9 @@ DLLEXPORT int tjDecompressToYUV(tjhandle handle, unsigned char *jpegBuf,
 }
 
 
-/* Transformer */
+/******************************** Transformer ********************************/
 
+/* TurboJPEG 1.2+ */
 DLLEXPORT tjhandle tjInitTransform(void)
 {
   tjinstance *this = NULL;
@@ -1903,6 +1946,7 @@ DLLEXPORT tjhandle tjInitTransform(void)
 }
 
 
+/* TurboJPEG 1.2+ */
 DLLEXPORT int tjTransform(tjhandle handle, const unsigned char *jpegBuf,
                           unsigned long jpegSize, int n,
                           unsigned char **dstBufs, unsigned long *dstSizes,
@@ -2013,8 +2057,10 @@ DLLEXPORT int tjTransform(tjhandle handle, const unsigned char *jpegBuf,
       jpeg_mem_dest_tj(cinfo, &dstBufs[i], &dstSizes[i], alloc);
     jpeg_copy_critical_parameters(dinfo, cinfo);
     dstcoefs = jtransform_adjust_parameters(dinfo, cinfo, srccoefs, &xinfo[i]);
+#ifdef C_PROGRESSIVE_SUPPORTED
     if (flags & TJFLAG_PROGRESSIVE || t[i].options & TJXOPT_PROGRESSIVE)
       jpeg_simple_progression(cinfo);
+#endif
     if (!(t[i].options & TJXOPT_NOOUTPUT)) {
       jpeg_write_coefficients(cinfo, dstcoefs);
       jcopy_markers_execute(dinfo, cinfo, t[i].options & TJXOPT_COPYNONE ?
@@ -2069,6 +2115,9 @@ bailout:
 }
 
 
+/*************************** Packed-Pixel Image I/O **************************/
+
+/* TurboJPEG 2.0+ */
 DLLEXPORT unsigned char *tjLoadImage(const char *filename, int *width,
                                      int align, int *height, int *pixelFormat,
                                      int flags)
@@ -2118,7 +2167,7 @@ DLLEXPORT unsigned char *tjLoadImage(const char *filename, int *width,
     invert = (flags & TJFLAG_BOTTOMUP) == 0;
   } else if (tempc == 'P') {
     if ((src = jinit_read_ppm(cinfo)) == NULL)
-      THROWG("tjLoadImage(): Could not initialize bitmap loader");
+      THROWG("tjLoadImage(): Could not initialize PPM loader");
     invert = (flags & TJFLAG_BOTTOMUP) != 0;
   } else
     THROWG("tjLoadImage(): Unsupported file type");
@@ -2171,6 +2220,7 @@ bailout:
 }
 
 
+/* TurboJPEG 2.0+ */
 DLLEXPORT int tjSaveImage(const char *filename, unsigned char *buffer,
                           int width, int pitch, int height, int pixelFormat,
                           int flags)
diff --git a/turbojpeg.h b/turbojpeg.h
index 02b54ca..1f8756a 100644
--- a/turbojpeg.h
+++ b/turbojpeg.h
@@ -1,6 +1,6 @@
 /*
- * Copyright (C)2009-2015, 2017, 2020-2021 D. R. Commander.
- *                                         All Rights Reserved.
+ * Copyright (C)2009-2015, 2017, 2020-2021, 2023 D. R. Commander.
+ *                                               All Rights Reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -54,23 +54,24 @@
  * Each plane is simply a 2D array of bytes, each byte representing the value
  * of one of the components (Y, Cb, or Cr) at a particular location in the
  * image.  The width and height of each plane are determined by the image
- * width, height, and level of chrominance subsampling.   The luminance plane
+ * width, height, and level of chrominance subsampling.  The luminance plane
  * width is the image width padded to the nearest multiple of the horizontal
- * subsampling factor (2 in the case of 4:2:0 and 4:2:2, 4 in the case of
- * 4:1:1, 1 in the case of 4:4:4 or grayscale.)  Similarly, the luminance plane
- * height is the image height padded to the nearest multiple of the vertical
- * subsampling factor (2 in the case of 4:2:0 or 4:4:0, 1 in the case of 4:4:4
- * or grayscale.)  This is irrespective of any additional padding that may be
- * specified as an argument to the various YUV functions.  The chrominance
- * plane width is equal to the luminance plane width divided by the horizontal
- * subsampling factor, and the chrominance plane height is equal to the
- * luminance plane height divided by the vertical subsampling factor.
+ * subsampling factor (1 in the case of 4:4:4, grayscale, or 4:4:0; 2 in the
+ * case of 4:2:2 or 4:2:0; 4 in the case of 4:1:1.)  Similarly, the luminance
+ * plane height is the image height padded to the nearest multiple of the
+ * vertical subsampling factor (1 in the case of 4:4:4, 4:2:2, grayscale, or
+ * 4:1:1; 2 in the case of 4:2:0 or 4:4:0.)  This is irrespective of any
+ * additional padding that may be specified as an argument to the various YUV
+ * functions.  The chrominance plane width is equal to the luminance plane
+ * width divided by the horizontal subsampling factor, and the chrominance
+ * plane height is equal to the luminance plane height divided by the vertical
+ * subsampling factor.
  *
  * For example, if the source image is 35 x 35 pixels and 4:2:2 subsampling is
  * used, then the luminance plane would be 36 x 35 bytes, and each of the
- * chrominance planes would be 18 x 35 bytes.  If you specify a line padding of
- * 4 bytes on top of this, then the luminance plane would be 36 x 35 bytes, and
- * each of the chrominance planes would be 20 x 35 bytes.
+ * chrominance planes would be 18 x 35 bytes.  If you specify a row alignment
+ * of 4 bytes on top of this, then the luminance plane would be 36 x 35 bytes,
+ * and each of the chrominance planes would be 20 x 35 bytes.
  *
  * @{
  */
@@ -86,8 +87,8 @@
  * When pixels are converted from RGB to YCbCr (see #TJCS_YCbCr) or from CMYK
  * to YCCK (see #TJCS_YCCK) as part of the JPEG compression process, some of
  * the Cb and Cr (chrominance) components can be discarded or averaged together
- * to produce a smaller image with little perceptible loss of image clarity
- * (the human eye is more sensitive to small changes in brightness than to
+ * to produce a smaller image with little perceptible loss of image clarity.
+ * (The human eye is more sensitive to small changes in brightness than to
  * small changes in color.)  This is called "chrominance subsampling".
  */
 enum TJSAMP {
@@ -245,8 +246,8 @@ enum TJPF {
    * vice versa, but the mapping is typically not 1:1 or reversible, nor can it
    * be defined with a simple formula.  Thus, such a conversion is out of scope
    * for a codec library.  However, the TurboJPEG API allows for compressing
-   * CMYK pixels into a YCCK JPEG image (see #TJCS_YCCK) and decompressing YCCK
-   * JPEG images into CMYK pixels.
+   * packed-pixel CMYK images into YCCK JPEG images (see #TJCS_YCCK) and
+   * decompressing YCCK JPEG images into packed-pixel CMYK images.
    */
   TJPF_CMYK,
   /**
@@ -258,9 +259,10 @@ enum TJPF {
 /**
  * Red offset (in bytes) for a given pixel format.  This specifies the number
  * of bytes that the red component is offset from the start of the pixel.  For
- * instance, if a pixel of format TJ_BGRX is stored in <tt>char pixel[]</tt>,
- * then the red component will be <tt>pixel[tjRedOffset[TJ_BGRX]]</tt>.  This
- * will be -1 if the pixel format does not have a red component.
+ * instance, if a pixel of format TJPF_BGRX is stored in
+ * `unsigned char pixel[]`, then the red component will be
+ *`pixel[tjRedOffset[TJPF_BGRX]]`.  This will be -1 if the pixel format does
+ * not have a red component.
  */
 static const int tjRedOffset[TJ_NUMPF] = {
   0, 2, 0, 2, 3, 1, -1, 0, 2, 3, 1, -1
@@ -268,31 +270,32 @@ static const int tjRedOffset[TJ_NUMPF] = {
 /**
  * Green offset (in bytes) for a given pixel format.  This specifies the number
  * of bytes that the green component is offset from the start of the pixel.
- * For instance, if a pixel of format TJ_BGRX is stored in
- * <tt>char pixel[]</tt>, then the green component will be
- * <tt>pixel[tjGreenOffset[TJ_BGRX]]</tt>.  This will be -1 if the pixel format
- * does not have a green component.
+ * For instance, if a pixel of format TJPF_BGRX is stored in
+ * `unsigned char pixel[]`, then the green component will be
+ * `pixel[tjGreenOffset[TJPF_BGRX]]`.  This will be -1 if the pixel format does
+ * not have a green component.
  */
 static const int tjGreenOffset[TJ_NUMPF] = {
   1, 1, 1, 1, 2, 2, -1, 1, 1, 2, 2, -1
 };
 /**
  * Blue offset (in bytes) for a given pixel format.  This specifies the number
- * of bytes that the Blue component is offset from the start of the pixel.  For
- * instance, if a pixel of format TJ_BGRX is stored in <tt>char pixel[]</tt>,
- * then the blue component will be <tt>pixel[tjBlueOffset[TJ_BGRX]]</tt>.  This
- * will be -1 if the pixel format does not have a blue component.
+ * of bytes that the blue component is offset from the start of the pixel.  For
+ * instance, if a pixel of format TJPF_BGRX is stored in
+ * `unsigned char pixel[]`, then the blue component will be
+ * `pixel[tjBlueOffset[TJPF_BGRX]]`.  This will be -1 if the pixel format does
+ * not have a blue component.
  */
 static const int tjBlueOffset[TJ_NUMPF] = {
   2, 0, 2, 0, 1, 3, -1, 2, 0, 1, 3, -1
 };
 /**
  * Alpha offset (in bytes) for a given pixel format.  This specifies the number
- * of bytes that the Alpha component is offset from the start of the pixel.
- * For instance, if a pixel of format TJ_BGRA is stored in
- * <tt>char pixel[]</tt>, then the alpha component will be
- * <tt>pixel[tjAlphaOffset[TJ_BGRA]]</tt>.  This will be -1 if the pixel format
- * does not have an alpha component.
+ * of bytes that the alpha component is offset from the start of the pixel.
+ * For instance, if a pixel of format TJPF_BGRA is stored in
+ * `unsigned char pixel[]`, then the alpha component will be
+ * `pixel[tjAlphaOffset[TJPF_BGRA]]`.  This will be -1 if the pixel format does
+ * not have an alpha component.
  */
 static const int tjAlphaOffset[TJ_NUMPF] = {
   -1, -1, -1, -1, -1, -1, -1, 3, 3, 0, 0, -1
@@ -318,8 +321,9 @@ enum TJCS {
    * RGB colorspace.  When compressing the JPEG image, the R, G, and B
    * components in the source image are reordered into image planes, but no
    * colorspace conversion or subsampling is performed.  RGB JPEG images can be
-   * decompressed to any of the extended RGB pixel formats or grayscale, but
-   * they cannot be decompressed to YUV images.
+   * decompressed to packed-pixel images with any of the extended RGB or
+   * grayscale pixel formats, but they cannot be decompressed to planar YUV
+   * images.
    */
   TJCS_RGB = 0,
   /**
@@ -332,25 +336,27 @@ enum TJCS {
    * original image.  Originally, the analog equivalent of this transformation
    * allowed the same signal to drive both black & white and color televisions,
    * but JPEG images use YCbCr primarily because it allows the color data to be
-   * optionally subsampled for the purposes of reducing bandwidth or disk
-   * space.  YCbCr is the most common JPEG colorspace, and YCbCr JPEG images
-   * can be compressed from and decompressed to any of the extended RGB pixel
-   * formats or grayscale, or they can be decompressed to YUV planar images.
+   * optionally subsampled for the purposes of reducing network or disk usage.
+   * YCbCr is the most common JPEG colorspace, and YCbCr JPEG images can be
+   * compressed from and decompressed to packed-pixel images with any of the
+   * extended RGB or grayscale pixel formats.  YCbCr JPEG images can also be
+   * compressed from and decompressed to planar YUV images.
    */
   TJCS_YCbCr,
   /**
    * Grayscale colorspace.  The JPEG image retains only the luminance data (Y
    * component), and any color data from the source image is discarded.
-   * Grayscale JPEG images can be compressed from and decompressed to any of
-   * the extended RGB pixel formats or grayscale, or they can be decompressed
-   * to YUV planar images.
+   * Grayscale JPEG images can be compressed from and decompressed to
+   * packed-pixel images with any of the extended RGB or grayscale pixel
+   * formats, or they can be compressed from and decompressed to planar YUV
+   * images.
    */
   TJCS_GRAY,
   /**
    * CMYK colorspace.  When compressing the JPEG image, the C, M, Y, and K
    * components in the source image are reordered into image planes, but no
    * colorspace conversion or subsampling is performed.  CMYK JPEG images can
-   * only be decompressed to CMYK pixels.
+   * only be decompressed to packed-pixel images with the CMYK pixel format.
    */
   TJCS_CMYK,
   /**
@@ -360,56 +366,54 @@ enum TJCS {
    * reversibly transformed into YCCK, and as with YCbCr, the chrominance
    * components in the YCCK pixels can be subsampled without incurring major
    * perceptual loss.  YCCK JPEG images can only be compressed from and
-   * decompressed to CMYK pixels.
+   * decompressed to packed-pixel images with the CMYK pixel format.
    */
   TJCS_YCCK
 };
 
 
 /**
- * The uncompressed source/destination image is stored in bottom-up (Windows,
- * OpenGL) order, not top-down (X11) order.
+ * Rows in the packed-pixel source/destination image are stored in bottom-up
+ * (Windows, OpenGL) order rather than in top-down (X11) order.
  */
 #define TJFLAG_BOTTOMUP  2
 /**
  * When decompressing an image that was compressed using chrominance
- * subsampling, use the fastest chrominance upsampling algorithm available in
- * the underlying codec.  The default is to use smooth upsampling, which
- * creates a smooth transition between neighboring chrominance components in
- * order to reduce upsampling artifacts in the decompressed image.
+ * subsampling, use the fastest chrominance upsampling algorithm available.
+ * The default is to use smooth upsampling, which creates a smooth transition
+ * between neighboring chrominance components in order to reduce upsampling
+ * artifacts in the decompressed image.
  */
 #define TJFLAG_FASTUPSAMPLE  256
 /**
- * Disable buffer (re)allocation.  If passed to one of the JPEG compression or
- * transform functions, this flag will cause those functions to generate an
- * error if the JPEG image buffer is invalid or too small rather than
- * attempting to allocate or reallocate that buffer.  This reproduces the
- * behavior of earlier versions of TurboJPEG.
+ * Disable JPEG buffer (re)allocation.  If passed to one of the JPEG
+ * compression or transform functions, this flag will cause those functions to
+ * generate an error if the JPEG destination buffer is invalid or too small,
+ * rather than attempt to allocate or reallocate that buffer.
  */
 #define TJFLAG_NOREALLOC  1024
 /**
- * Use the fastest DCT/IDCT algorithm available in the underlying codec.  The
- * default if this flag is not specified is implementation-specific.  For
- * example, the implementation of TurboJPEG for libjpeg[-turbo] uses the fast
- * algorithm by default when compressing, because this has been shown to have
- * only a very slight effect on accuracy, but it uses the accurate algorithm
- * when decompressing, because this has been shown to have a larger effect.
+ * Use the fastest DCT/IDCT algorithm available.  The default if this flag is
+ * not specified is implementation-specific.  For example, the implementation
+ * of the TurboJPEG API in libjpeg-turbo uses the fast algorithm by default
+ * when compressing, because this has been shown to have only a very slight
+ * effect on accuracy, but it uses the accurate algorithm when decompressing,
+ * because this has been shown to have a larger effect.
  */
 #define TJFLAG_FASTDCT  2048
 /**
- * Use the most accurate DCT/IDCT algorithm available in the underlying codec.
- * The default if this flag is not specified is implementation-specific.  For
- * example, the implementation of TurboJPEG for libjpeg[-turbo] uses the fast
- * algorithm by default when compressing, because this has been shown to have
- * only a very slight effect on accuracy, but it uses the accurate algorithm
- * when decompressing, because this has been shown to have a larger effect.
+ * Use the most accurate DCT/IDCT algorithm available.  The default if this
+ * flag is not specified is implementation-specific.  For example, the
+ * implementation of the TurboJPEG API in libjpeg-turbo uses the fast algorithm
+ * by default when compressing, because this has been shown to have only a very
+ * slight effect on accuracy, but it uses the accurate algorithm when
+ * decompressing, because this has been shown to have a larger effect.
  */
 #define TJFLAG_ACCURATEDCT  4096
 /**
  * Immediately discontinue the current compression/decompression/transform
- * operation if the underlying codec throws a warning (non-fatal error).  The
- * default behavior is to allow the operation to complete unless a fatal error
- * is encountered.
+ * operation if a warning (non-fatal error) occurs.  The default behavior is to
+ * allow the operation to complete unless a fatal error is encountered.
  */
 #define TJFLAG_STOPONWARNING  8192
 /**
@@ -441,8 +445,8 @@ enum TJCS {
  */
 enum TJERR {
   /**
-   * The error was non-fatal and recoverable, but the image may still be
-   * corrupt.
+   * The error was non-fatal and recoverable, but the destination image may
+   * still be corrupt.
    */
   TJERR_WARNING = 0,
   /**
@@ -509,9 +513,9 @@ enum TJXOP {
 /**
  * This option will cause #tjTransform() to return an error if the transform is
  * not perfect.  Lossless transforms operate on MCU blocks, whose size depends
- * on the level of chrominance subsampling used (see #tjMCUWidth
- * and #tjMCUHeight.)  If the image's width or height is not evenly divisible
- * by the MCU block size, then there will be partial MCU blocks on the right
+ * on the level of chrominance subsampling used (see #tjMCUWidth and
+ * #tjMCUHeight.)  If the image's width or height is not evenly divisible by
+ * the MCU block size, then there will be partial MCU blocks on the right
  * and/or bottom edges.  It is not possible to move these partial MCU blocks to
  * the top or left of the image, so any transform that would require that is
  * "imperfect."  If this option is not specified, then any partial MCU blocks
@@ -530,29 +534,28 @@ enum TJXOP {
  */
 #define TJXOPT_CROP  4
 /**
- * This option will discard the color data in the input image and produce
- * a grayscale output image.
+ * This option will discard the color data in the source image and produce a
+ * grayscale destination image.
  */
 #define TJXOPT_GRAY  8
 /**
  * This option will prevent #tjTransform() from outputting a JPEG image for
- * this particular transform (this can be used in conjunction with a custom
+ * this particular transform.  (This can be used in conjunction with a custom
  * filter to capture the transformed DCT coefficients without transcoding
  * them.)
  */
 #define TJXOPT_NOOUTPUT  16
 /**
- * This option will enable progressive entropy coding in the output image
+ * This option will enable progressive entropy coding in the JPEG image
  * generated by this particular transform.  Progressive entropy coding will
  * generally improve compression relative to baseline entropy coding (the
- * default), but it will reduce compression and decompression performance
- * considerably.
+ * default), but it will reduce decompression performance considerably.
  */
 #define TJXOPT_PROGRESSIVE  32
 /**
  * This option will prevent #tjTransform() from copying any extra markers
- * (including EXIF and ICC profile data) from the source image to the output
- * image.
+ * (including EXIF and ICC profile data) from the source image to the
+ * destination image.
  */
 #define TJXOPT_COPYNONE  64
 
@@ -586,12 +589,12 @@ typedef struct {
    */
   int y;
   /**
-   * The width of the cropping region. Setting this to 0 is the equivalent of
+   * The width of the cropping region.  Setting this to 0 is the equivalent of
    * setting it to the width of the source JPEG image - x.
    */
   int w;
   /**
-   * The height of the cropping region. Setting this to 0 is the equivalent of
+   * The height of the cropping region.  Setting this to 0 is the equivalent of
    * setting it to the height of the source JPEG image - y.
    */
   int h;
@@ -610,7 +613,8 @@ typedef struct tjtransform {
    */
   int op;
   /**
-   * The bitwise OR of one of more of the @ref TJXOPT_CROP "transform options"
+   * The bitwise OR of one of more of the @ref TJXOPT_COPYNONE
+   * "transform options"
    */
   int options;
   /**
@@ -619,10 +623,10 @@ typedef struct tjtransform {
    */
   void *data;
   /**
-   * A callback function that can be used to modify the DCT coefficients
-   * after they are losslessly transformed but before they are transcoded to a
-   * new JPEG image.  This allows for custom filters or other transformations
-   * to be applied in the frequency domain.
+   * A callback function that can be used to modify the DCT coefficients after
+   * they are losslessly transformed but before they are transcoded to a new
+   * JPEG image.  This allows for custom filters or other transformations to be
+   * applied in the frequency domain.
    *
    * @param coeffs pointer to an array of transformed DCT coefficients.  (NOTE:
    * this pointer is not guaranteed to be valid once the callback returns, so
@@ -630,21 +634,21 @@ typedef struct tjtransform {
    * or library should make a copy of them within the body of the callback.)
    *
    * @param arrayRegion #tjregion structure containing the width and height of
-   * the array pointed to by <tt>coeffs</tt> as well as its offset relative to
-   * the component plane.  TurboJPEG implementations may choose to split each
+   * the array pointed to by `coeffs` as well as its offset relative to the
+   * component plane.  TurboJPEG implementations may choose to split each
    * component plane into multiple DCT coefficient arrays and call the callback
    * function once for each array.
    *
    * @param planeRegion #tjregion structure containing the width and height of
-   * the component plane to which <tt>coeffs</tt> belongs
+   * the component plane to which `coeffs` belongs
    *
-   * @param componentID ID number of the component plane to which
-   * <tt>coeffs</tt> belongs (Y, Cb, and Cr have, respectively, ID's of 0, 1,
-   * and 2 in typical JPEG images.)
+   * @param componentID ID number of the component plane to which `coeffs`
+   * belongs.  (Y, Cb, and Cr have, respectively, ID's of 0, 1, and 2 in
+   * typical JPEG images.)
    *
-   * @param transformID ID number of the transformed image to which
-   * <tt>coeffs</tt> belongs.  This is the same as the index of the transform
-   * in the <tt>transforms</tt> array that was passed to #tjTransform().
+   * @param transformID ID number of the transformed image to which `coeffs`
+   * belongs.  This is the same as the index of the transform in the
+   * `transforms` array that was passed to #tjTransform().
    *
    * @param transform a pointer to a #tjtransform structure that specifies the
    * parameters and/or cropping region for this transform
@@ -663,14 +667,14 @@ typedef void *tjhandle;
 
 
 /**
- * Pad the given width to the nearest 32-bit boundary
+ * Pad the given width to the nearest multiple of 4
  */
 #define TJPAD(width)  (((width) + 3) & (~3))
 
 /**
- * Compute the scaled value of <tt>dimension</tt> using the given scaling
- * factor.  This macro performs the integer equivalent of <tt>ceil(dimension *
- * scalingFactor)</tt>.
+ * Compute the scaled value of `dimension` using the given scaling factor.
+ * This macro performs the integer equivalent of `ceil(dimension *
+ * scalingFactor)`.
  */
 #define TJSCALED(dimension, scalingFactor) \
   (((dimension) * scalingFactor.num + scalingFactor.denom - 1) / \
@@ -685,27 +689,27 @@ extern "C" {
 /**
  * Create a TurboJPEG compressor instance.
  *
- * @return a handle to the newly-created instance, or NULL if an error
- * occurred (see #tjGetErrorStr2().)
+ * @return a handle to the newly-created instance, or NULL if an error occurred
+ * (see #tjGetErrorStr2().)
  */
 DLLEXPORT tjhandle tjInitCompress(void);
 
 
 /**
- * Compress an RGB, grayscale, or CMYK image into a JPEG image.
+ * Compress a packed-pixel RGB, grayscale, or CMYK image into a JPEG image.
  *
  * @param handle a handle to a TurboJPEG compressor or transformer instance
  *
- * @param srcBuf pointer to an image buffer containing RGB, grayscale, or
- * CMYK pixels to be compressed
+ * @param srcBuf pointer to a buffer containing a packed-pixel RGB, grayscale,
+ * or CMYK source image to be compressed
  *
  * @param width width (in pixels) of the source image
  *
- * @param pitch bytes per line in the source image.  Normally, this should be
- * <tt>width * #tjPixelSize[pixelFormat]</tt> if the image is unpadded, or
- * <tt>#TJPAD(width * #tjPixelSize[pixelFormat])</tt> if each line of the image
- * is padded to the nearest 32-bit boundary, as is the case for Windows
- * bitmaps.  You can also be clever and use this parameter to skip lines, etc.
+ * @param pitch bytes per row in the source image.  Normally this should be
+ * <tt>width * #tjPixelSize[pixelFormat]</tt>, if the image is unpadded, or
+ * <tt>#TJPAD(width * #tjPixelSize[pixelFormat])</tt> if each row of the image
+ * is padded to the nearest multiple of 4 bytes, as is the case for Windows
+ * bitmaps.  You can also be clever and use this parameter to skip rows, etc.
  * Setting this parameter to 0 is the equivalent of setting it to
  * <tt>width * #tjPixelSize[pixelFormat]</tt>.
  *
@@ -714,29 +718,28 @@ DLLEXPORT tjhandle tjInitCompress(void);
  * @param pixelFormat pixel format of the source image (see @ref TJPF
  * "Pixel formats".)
  *
- * @param jpegBuf address of a pointer to an image buffer that will receive the
- * JPEG image.  TurboJPEG has the ability to reallocate the JPEG buffer
- * to accommodate the size of the JPEG image.  Thus, you can choose to:
+ * @param jpegBuf address of a pointer to a byte buffer that will receive the
+ * JPEG image.  TurboJPEG has the ability to reallocate the JPEG buffer to
+ * accommodate the size of the JPEG image.  Thus, you can choose to:
  * -# pre-allocate the JPEG buffer with an arbitrary size using #tjAlloc() and
  * let TurboJPEG grow the buffer as needed,
- * -# set <tt>*jpegBuf</tt> to NULL to tell TurboJPEG to allocate the buffer
- * for you, or
+ * -# set `*jpegBuf` to NULL to tell TurboJPEG to allocate the buffer for you,
+ * or
  * -# pre-allocate the buffer to a "worst case" size determined by calling
  * #tjBufSize().  This should ensure that the buffer never has to be
- * re-allocated (setting #TJFLAG_NOREALLOC guarantees that it won't be.)
+ * re-allocated.  (Setting #TJFLAG_NOREALLOC guarantees that it won't be.)
  * .
- * If you choose option 1, <tt>*jpegSize</tt> should be set to the size of your
+ * If you choose option 1, then `*jpegSize` should be set to the size of your
  * pre-allocated buffer.  In any case, unless you have set #TJFLAG_NOREALLOC,
- * you should always check <tt>*jpegBuf</tt> upon return from this function, as
- * it may have changed.
+ * you should always check `*jpegBuf` upon return from this function, as it may
+ * have changed.
  *
  * @param jpegSize pointer to an unsigned long variable that holds the size of
- * the JPEG image buffer.  If <tt>*jpegBuf</tt> points to a pre-allocated
- * buffer, then <tt>*jpegSize</tt> should be set to the size of the buffer.
- * Upon return, <tt>*jpegSize</tt> will contain the size of the JPEG image (in
- * bytes.)  If <tt>*jpegBuf</tt> points to a JPEG image buffer that is being
- * reused from a previous call to one of the JPEG compression functions, then
- * <tt>*jpegSize</tt> is ignored.
+ * the JPEG buffer.  If `*jpegBuf` points to a pre-allocated buffer, then
+ * `*jpegSize` should be set to the size of the buffer.  Upon return,
+ * `*jpegSize` will contain the size of the JPEG image (in bytes.)  If
+ * `*jpegBuf` points to a JPEG buffer that is being reused from a previous call
+ * to one of the JPEG compression functions, then `*jpegSize` is ignored.
  *
  * @param jpegSubsamp the level of chrominance subsampling to be used when
  * generating the JPEG image (see @ref TJSAMP
@@ -750,7 +753,7 @@ DLLEXPORT tjhandle tjInitCompress(void);
  *
  * @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()
  * and #tjGetErrorCode().)
-*/
+ */
 DLLEXPORT int tjCompress2(tjhandle handle, const unsigned char *srcBuf,
                           int width, int pitch, int height, int pixelFormat,
                           unsigned char **jpegBuf, unsigned long *jpegSize,
@@ -758,55 +761,55 @@ DLLEXPORT int tjCompress2(tjhandle handle, const unsigned char *srcBuf,
 
 
 /**
- * Compress a YUV planar image into a JPEG image.
+ * Compress a unified planar YUV image into a JPEG image.
  *
  * @param handle a handle to a TurboJPEG compressor or transformer instance
  *
- * @param srcBuf pointer to an image buffer containing a YUV planar image to be
- * compressed.  The size of this buffer should match the value returned by
- * #tjBufSizeYUV2() for the given image width, height, padding, and level of
- * chrominance subsampling.  The Y, U (Cb), and V (Cr) image planes should be
- * stored sequentially in the source buffer (refer to @ref YUVnotes
- * "YUV Image Format Notes".)
+ * @param srcBuf pointer to a buffer containing a unified planar YUV source
+ * image to be compressed.  The size of this buffer should match the value
+ * returned by #tjBufSizeYUV2() for the given image width, height, row
+ * alignment, and level of chrominance subsampling.  The Y, U (Cb), and V (Cr)
+ * image planes should be stored sequentially in the buffer.  (Refer to
+ * @ref YUVnotes "YUV Image Format Notes".)
  *
  * @param width width (in pixels) of the source image.  If the width is not an
  * even multiple of the MCU block width (see #tjMCUWidth), then an intermediate
- * buffer copy will be performed within TurboJPEG.
+ * buffer copy will be performed.
  *
- * @param pad the line padding used in the source image.  For instance, if each
- * line in each plane of the YUV image is padded to the nearest multiple of 4
- * bytes, then <tt>pad</tt> should be set to 4.
+ * @param align row alignment (in bytes) of the source image (must be a power
+ * of 2.)  Setting this parameter to n indicates that each row in each plane of
+ * the source image is padded to the nearest multiple of n bytes
+ * (1 = unpadded.)
  *
  * @param height height (in pixels) of the source image.  If the height is not
  * an even multiple of the MCU block height (see #tjMCUHeight), then an
- * intermediate buffer copy will be performed within TurboJPEG.
+ * intermediate buffer copy will be performed.
  *
- * @param subsamp the level of chrominance subsampling used in the source
- * image (see @ref TJSAMP "Chrominance subsampling options".)
+ * @param subsamp the level of chrominance subsampling used in the source image
+ * (see @ref TJSAMP "Chrominance subsampling options".)
  *
- * @param jpegBuf address of a pointer to an image buffer that will receive the
+ * @param jpegBuf address of a pointer to a byte buffer that will receive the
  * JPEG image.  TurboJPEG has the ability to reallocate the JPEG buffer to
  * accommodate the size of the JPEG image.  Thus, you can choose to:
  * -# pre-allocate the JPEG buffer with an arbitrary size using #tjAlloc() and
  * let TurboJPEG grow the buffer as needed,
- * -# set <tt>*jpegBuf</tt> to NULL to tell TurboJPEG to allocate the buffer
- * for you, or
+ * -# set `*jpegBuf` to NULL to tell TurboJPEG to allocate the buffer for you,
+ * or
  * -# pre-allocate the buffer to a "worst case" size determined by calling
  * #tjBufSize().  This should ensure that the buffer never has to be
- * re-allocated (setting #TJFLAG_NOREALLOC guarantees that it won't be.)
+ * re-allocated.  (Setting #TJFLAG_NOREALLOC guarantees that it won't be.)
  * .
- * If you choose option 1, <tt>*jpegSize</tt> should be set to the size of your
+ * If you choose option 1, then `*jpegSize` should be set to the size of your
  * pre-allocated buffer.  In any case, unless you have set #TJFLAG_NOREALLOC,
- * you should always check <tt>*jpegBuf</tt> upon return from this function, as
- * it may have changed.
+ * you should always check `*jpegBuf` upon return from this function, as it may
+ * have changed.
  *
  * @param jpegSize pointer to an unsigned long variable that holds the size of
- * the JPEG image buffer.  If <tt>*jpegBuf</tt> points to a pre-allocated
- * buffer, then <tt>*jpegSize</tt> should be set to the size of the buffer.
- * Upon return, <tt>*jpegSize</tt> will contain the size of the JPEG image (in
- * bytes.)  If <tt>*jpegBuf</tt> points to a JPEG image buffer that is being
- * reused from a previous call to one of the JPEG compression functions, then
- * <tt>*jpegSize</tt> is ignored.
+ * the JPEG buffer.  If `*jpegBuf` points to a pre-allocated buffer, then
+ * `*jpegSize` should be set to the size of the buffer.  Upon return,
+ * `*jpegSize` will contain the size of the JPEG image (in bytes.)  If
+ * `*jpegBuf` points to a JPEG buffer that is being reused from a previous call
+ * to one of the JPEG compression functions, then `*jpegSize` is ignored.
  *
  * @param jpegQual the image quality of the generated JPEG image (1 = worst,
  * 100 = best)
@@ -816,9 +819,9 @@ DLLEXPORT int tjCompress2(tjhandle handle, const unsigned char *srcBuf,
  *
  * @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()
  * and #tjGetErrorCode().)
-*/
+ */
 DLLEXPORT int tjCompressFromYUV(tjhandle handle, const unsigned char *srcBuf,
-                                int width, int pad, int height, int subsamp,
+                                int width, int align, int height, int subsamp,
                                 unsigned char **jpegBuf,
                                 unsigned long *jpegSize, int jpegQual,
                                 int flags);
@@ -831,55 +834,54 @@ DLLEXPORT int tjCompressFromYUV(tjhandle handle, const unsigned char *srcBuf,
  *
  * @param srcPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes
  * (or just a Y plane, if compressing a grayscale image) that contain a YUV
- * image to be compressed.  These planes can be contiguous or non-contiguous in
- * memory.  The size of each plane should match the value returned by
- * #tjPlaneSizeYUV() for the given image width, height, strides, and level of
- * chrominance subsampling.  Refer to @ref YUVnotes "YUV Image Format Notes"
- * for more details.
+ * source image to be compressed.  These planes can be contiguous or
+ * non-contiguous in memory.  The size of each plane should match the value
+ * returned by #tjPlaneSizeYUV() for the given image width, height, strides,
+ * and level of chrominance subsampling.  Refer to @ref YUVnotes
+ * "YUV Image Format Notes" for more details.
  *
  * @param width width (in pixels) of the source image.  If the width is not an
  * even multiple of the MCU block width (see #tjMCUWidth), then an intermediate
- * buffer copy will be performed within TurboJPEG.
+ * buffer copy will be performed.
  *
  * @param strides an array of integers, each specifying the number of bytes per
- * line in the corresponding plane of the YUV source image.  Setting the stride
+ * row in the corresponding plane of the YUV source image.  Setting the stride
  * for any plane to 0 is the same as setting it to the plane width (see
- * @ref YUVnotes "YUV Image Format Notes".)  If <tt>strides</tt> is NULL, then
- * the strides for all planes will be set to their respective plane widths.
- * You can adjust the strides in order to specify an arbitrary amount of line
+ * @ref YUVnotes "YUV Image Format Notes".)  If `strides` is NULL, then the
+ * strides for all planes will be set to their respective plane widths.  You
+ * can adjust the strides in order to specify an arbitrary amount of row
  * padding in each plane or to create a JPEG image from a subregion of a larger
- * YUV planar image.
+ * planar YUV image.
  *
  * @param height height (in pixels) of the source image.  If the height is not
  * an even multiple of the MCU block height (see #tjMCUHeight), then an
- * intermediate buffer copy will be performed within TurboJPEG.
+ * intermediate buffer copy will be performed.
  *
- * @param subsamp the level of chrominance subsampling used in the source
- * image (see @ref TJSAMP "Chrominance subsampling options".)
+ * @param subsamp the level of chrominance subsampling used in the source image
+ * (see @ref TJSAMP "Chrominance subsampling options".)
  *
- * @param jpegBuf address of a pointer to an image buffer that will receive the
+ * @param jpegBuf address of a pointer to a byte buffer that will receive the
  * JPEG image.  TurboJPEG has the ability to reallocate the JPEG buffer to
  * accommodate the size of the JPEG image.  Thus, you can choose to:
  * -# pre-allocate the JPEG buffer with an arbitrary size using #tjAlloc() and
  * let TurboJPEG grow the buffer as needed,
- * -# set <tt>*jpegBuf</tt> to NULL to tell TurboJPEG to allocate the buffer
- * for you, or
+ * -# set `*jpegBuf` to NULL to tell TurboJPEG to allocate the buffer for you,
+ * or
  * -# pre-allocate the buffer to a "worst case" size determined by calling
  * #tjBufSize().  This should ensure that the buffer never has to be
- * re-allocated (setting #TJFLAG_NOREALLOC guarantees that it won't be.)
+ * re-allocated.  (Setting #TJFLAG_NOREALLOC guarantees that it won't be.)
  * .
- * If you choose option 1, <tt>*jpegSize</tt> should be set to the size of your
+ * If you choose option 1, then `*jpegSize` should be set to the size of your
  * pre-allocated buffer.  In any case, unless you have set #TJFLAG_NOREALLOC,
- * you should always check <tt>*jpegBuf</tt> upon return from this function, as
- * it may have changed.
+ * you should always check `*jpegBuf` upon return from this function, as it may
+ * have changed.
  *
  * @param jpegSize pointer to an unsigned long variable that holds the size of
- * the JPEG image buffer.  If <tt>*jpegBuf</tt> points to a pre-allocated
- * buffer, then <tt>*jpegSize</tt> should be set to the size of the buffer.
- * Upon return, <tt>*jpegSize</tt> will contain the size of the JPEG image (in
- * bytes.)  If <tt>*jpegBuf</tt> points to a JPEG image buffer that is being
- * reused from a previous call to one of the JPEG compression functions, then
- * <tt>*jpegSize</tt> is ignored.
+ * the JPEG buffer.  If `*jpegBuf` points to a pre-allocated buffer, then
+ * `*jpegSize` should be set to the size of the buffer.  Upon return,
+ * `*jpegSize` will contain the size of the JPEG image (in bytes.)  If
+ * `*jpegBuf` points to a JPEG buffer that is being reused from a previous call
+ * to one of the JPEG compression functions, then `*jpegSize` is ignored.
  *
  * @param jpegQual the image quality of the generated JPEG image (1 = worst,
  * 100 = best)
@@ -889,7 +891,7 @@ DLLEXPORT int tjCompressFromYUV(tjhandle handle, const unsigned char *srcBuf,
  *
  * @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()
  * and #tjGetErrorCode().)
-*/
+ */
 DLLEXPORT int tjCompressFromYUVPlanes(tjhandle handle,
                                       const unsigned char **srcPlanes,
                                       int width, const int *strides,
@@ -903,11 +905,11 @@ DLLEXPORT int tjCompressFromYUVPlanes(tjhandle handle,
  * The maximum size of the buffer (in bytes) required to hold a JPEG image with
  * the given parameters.  The number of bytes returned by this function is
  * larger than the size of the uncompressed source image.  The reason for this
- * is that the JPEG format uses 16-bit coefficients, and it is thus possible
- * for a very high-quality JPEG image with very high-frequency content to
- * expand rather than compress when converted to the JPEG format.  Such images
- * represent a very rare corner case, but since there is no way to predict the
- * size of a JPEG image prior to compression, the corner case has to be
+ * is that the JPEG format uses 16-bit coefficients, so it is possible for a
+ * very high-quality source image with very high-frequency content to expand
+ * rather than compress when converted to the JPEG format.  Such images
+ * represent very rare corner cases, but since there is no way to predict the
+ * size of a JPEG image prior to compression, the corner cases have to be
  * handled.
  *
  * @param width width (in pixels) of the image
@@ -925,23 +927,24 @@ DLLEXPORT unsigned long tjBufSize(int width, int height, int jpegSubsamp);
 
 
 /**
- * The size of the buffer (in bytes) required to hold a YUV planar image with
- * the given parameters.
+ * The size of the buffer (in bytes) required to hold a unified planar YUV
+ * image with the given parameters.
  *
  * @param width width (in pixels) of the image
  *
- * @param pad the width of each line in each plane of the image is padded to
- * the nearest multiple of this number of bytes (must be a power of 2.)
+ * @param align row alignment (in bytes) of the image (must be a power of 2.)
+ * Setting this parameter to n specifies that each row in each plane of the
+ * image will be padded to the nearest multiple of n bytes (1 = unpadded.)
  *
  * @param height height (in pixels) of the image
  *
  * @param subsamp level of chrominance subsampling in the image (see
  * @ref TJSAMP "Chrominance subsampling options".)
  *
- * @return the size of the buffer (in bytes) required to hold the image, or
- * -1 if the arguments are out of bounds.
+ * @return the size of the buffer (in bytes) required to hold the image, or -1
+ * if the arguments are out of bounds.
  */
-DLLEXPORT unsigned long tjBufSizeYUV2(int width, int pad, int height,
+DLLEXPORT unsigned long tjBufSizeYUV2(int width, int align, int height,
                                       int subsamp);
 
 
@@ -954,7 +957,7 @@ DLLEXPORT unsigned long tjBufSizeYUV2(int width, int pad, int height,
  * @param width width (in pixels) of the YUV image.  NOTE: this is the width of
  * the whole image, not the plane width.
  *
- * @param stride bytes per line in the image plane.  Setting this to 0 is the
+ * @param stride bytes per row in the image plane.  Setting this to 0 is the
  * equivalent of setting it to the plane width.
  *
  * @param height height (in pixels) of the YUV image.  NOTE: this is the height
@@ -1005,23 +1008,23 @@ DLLEXPORT int tjPlaneHeight(int componentID, int height, int subsamp);
 
 
 /**
- * Encode an RGB or grayscale image into a YUV planar image.  This function
- * uses the accelerated color conversion routines in the underlying
- * codec but does not execute any of the other steps in the JPEG compression
- * process.
+ * Encode a packed-pixel RGB or grayscale image into a unified planar YUV
+ * image.  This function performs color conversion (which is accelerated in the
+ * libjpeg-turbo implementation) but does not execute any of the other steps in
+ * the JPEG compression process.
  *
  * @param handle a handle to a TurboJPEG compressor or transformer instance
  *
- * @param srcBuf pointer to an image buffer containing RGB or grayscale pixels
- * to be encoded
+ * @param srcBuf pointer to a buffer containing a packed-pixel RGB or grayscale
+ * source image to be encoded
  *
  * @param width width (in pixels) of the source image
  *
- * @param pitch bytes per line in the source image.  Normally, this should be
- * <tt>width * #tjPixelSize[pixelFormat]</tt> if the image is unpadded, or
- * <tt>#TJPAD(width * #tjPixelSize[pixelFormat])</tt> if each line of the image
- * is padded to the nearest 32-bit boundary, as is the case for Windows
- * bitmaps.  You can also be clever and use this parameter to skip lines, etc.
+ * @param pitch bytes per row in the source image.  Normally this should be
+ * <tt>width * #tjPixelSize[pixelFormat]</tt>, if the image is unpadded, or
+ * <tt>#TJPAD(width * #tjPixelSize[pixelFormat])</tt> if each row of the image
+ * is padded to the nearest multiple of 4 bytes, as is the case for Windows
+ * bitmaps.  You can also be clever and use this parameter to skip rows, etc.
  * Setting this parameter to 0 is the equivalent of setting it to
  * <tt>width * #tjPixelSize[pixelFormat]</tt>.
  *
@@ -1030,53 +1033,54 @@ DLLEXPORT int tjPlaneHeight(int componentID, int height, int subsamp);
  * @param pixelFormat pixel format of the source image (see @ref TJPF
  * "Pixel formats".)
  *
- * @param dstBuf pointer to an image buffer that will receive the YUV image.
- * Use #tjBufSizeYUV2() to determine the appropriate size for this buffer based
- * on the image width, height, padding, and level of chrominance subsampling.
- * The Y, U (Cb), and V (Cr) image planes will be stored sequentially in the
- * buffer (refer to @ref YUVnotes "YUV Image Format Notes".)
+ * @param dstBuf pointer to a buffer that will receive the unified planar YUV
+ * image.  Use #tjBufSizeYUV2() to determine the appropriate size for this
+ * buffer based on the image width, height, row alignment, and level of
+ * chrominance subsampling.  The Y, U (Cb), and V (Cr) image planes will be
+ * stored sequentially in the buffer.  (Refer to @ref YUVnotes
+ * "YUV Image Format Notes".)
  *
- * @param pad the width of each line in each plane of the YUV image will be
- * padded to the nearest multiple of this number of bytes (must be a power of
- * 2.)  To generate images suitable for X Video, <tt>pad</tt> should be set to
- * 4.
+ * @param align row alignment (in bytes) of the YUV image (must be a power of
+ * 2.)  Setting this parameter to n will cause each row in each plane of the
+ * YUV image to be padded to the nearest multiple of n bytes (1 = unpadded.)
+ * To generate images suitable for X Video, `align` should be set to 4.
  *
  * @param subsamp the level of chrominance subsampling to be used when
  * generating the YUV image (see @ref TJSAMP
  * "Chrominance subsampling options".)  To generate images suitable for X
- * Video, <tt>subsamp</tt> should be set to @ref TJSAMP_420.  This produces an
- * image compatible with the I420 (AKA "YUV420P") format.
+ * Video, `subsamp` should be set to @ref TJSAMP_420.  This produces an image
+ * compatible with the I420 (AKA "YUV420P") format.
  *
  * @param flags the bitwise OR of one or more of the @ref TJFLAG_ACCURATEDCT
  * "flags"
  *
  * @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()
  * and #tjGetErrorCode().)
-*/
+ */
 DLLEXPORT int tjEncodeYUV3(tjhandle handle, const unsigned char *srcBuf,
                            int width, int pitch, int height, int pixelFormat,
-                           unsigned char *dstBuf, int pad, int subsamp,
+                           unsigned char *dstBuf, int align, int subsamp,
                            int flags);
 
 
 /**
- * Encode an RGB or grayscale image into separate Y, U (Cb), and V (Cr) image
- * planes.  This function uses the accelerated color conversion routines in the
- * underlying codec but does not execute any of the other steps in the JPEG
- * compression process.
+ * Encode a packed-pixel RGB or grayscale image into separate Y, U (Cb), and
+ * V (Cr) image planes.  This function performs color conversion (which is
+ * accelerated in the libjpeg-turbo implementation) but does not execute any of
+ * the other steps in the JPEG compression process.
  *
  * @param handle a handle to a TurboJPEG compressor or transformer instance
  *
- * @param srcBuf pointer to an image buffer containing RGB or grayscale pixels
- * to be encoded
+ * @param srcBuf pointer to a buffer containing a packed-pixel RGB or grayscale
+ * source image to be encoded
  *
  * @param width width (in pixels) of the source image
  *
- * @param pitch bytes per line in the source image.  Normally, this should be
- * <tt>width * #tjPixelSize[pixelFormat]</tt> if the image is unpadded, or
- * <tt>#TJPAD(width * #tjPixelSize[pixelFormat])</tt> if each line of the image
- * is padded to the nearest 32-bit boundary, as is the case for Windows
- * bitmaps.  You can also be clever and use this parameter to skip lines, etc.
+ * @param pitch bytes per row in the source image.  Normally this should be
+ * <tt>width * #tjPixelSize[pixelFormat]</tt>, if the image is unpadded, or
+ * <tt>#TJPAD(width * #tjPixelSize[pixelFormat])</tt> if each row of the image
+ * is padded to the nearest multiple of 4 bytes, as is the case for Windows
+ * bitmaps.  You can also be clever and use this parameter to skip rows, etc.
  * Setting this parameter to 0 is the equivalent of setting it to
  * <tt>width * #tjPixelSize[pixelFormat]</tt>.
  *
@@ -1093,26 +1097,26 @@ DLLEXPORT int tjEncodeYUV3(tjhandle handle, const unsigned char *srcBuf,
  * Refer to @ref YUVnotes "YUV Image Format Notes" for more details.
  *
  * @param strides an array of integers, each specifying the number of bytes per
- * line in the corresponding plane of the output image.  Setting the stride for
- * any plane to 0 is the same as setting it to the plane width (see
- * @ref YUVnotes "YUV Image Format Notes".)  If <tt>strides</tt> is NULL, then
- * the strides for all planes will be set to their respective plane widths.
- * You can adjust the strides in order to add an arbitrary amount of line
- * padding to each plane or to encode an RGB or grayscale image into a
- * subregion of a larger YUV planar image.
+ * row in the corresponding plane of the YUV image.  Setting the stride for any
+ * plane to 0 is the same as setting it to the plane width (see @ref YUVnotes
+ * "YUV Image Format Notes".)  If `strides` is NULL, then the strides for all
+ * planes will be set to their respective plane widths.  You can adjust the
+ * strides in order to add an arbitrary amount of row padding to each plane or
+ * to encode an RGB or grayscale image into a subregion of a larger planar YUV
+ * image.
  *
  * @param subsamp the level of chrominance subsampling to be used when
  * generating the YUV image (see @ref TJSAMP
  * "Chrominance subsampling options".)  To generate images suitable for X
- * Video, <tt>subsamp</tt> should be set to @ref TJSAMP_420.  This produces an
- * image compatible with the I420 (AKA "YUV420P") format.
+ * Video, `subsamp` should be set to @ref TJSAMP_420.  This produces an image
+ * compatible with the I420 (AKA "YUV420P") format.
  *
  * @param flags the bitwise OR of one or more of the @ref TJFLAG_ACCURATEDCT
  * "flags"
  *
  * @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()
  * and #tjGetErrorCode().)
-*/
+ */
 DLLEXPORT int tjEncodeYUVPlanes(tjhandle handle, const unsigned char *srcBuf,
                                 int width, int pitch, int height,
                                 int pixelFormat, unsigned char **dstPlanes,
@@ -1122,9 +1126,9 @@ DLLEXPORT int tjEncodeYUVPlanes(tjhandle handle, const unsigned char *srcBuf,
 /**
  * Create a TurboJPEG decompressor instance.
  *
- * @return a handle to the newly-created instance, or NULL if an error
- * occurred (see #tjGetErrorStr2().)
-*/
+ * @return a handle to the newly-created instance, or NULL if an error occurred
+ * (see #tjGetErrorStr2().)
+ */
 DLLEXPORT tjhandle tjInitDecompress(void);
 
 
@@ -1134,7 +1138,7 @@ DLLEXPORT tjhandle tjInitDecompress(void);
  *
  * @param handle a handle to a TurboJPEG decompressor or transformer instance
  *
- * @param jpegBuf pointer to a buffer containing a JPEG image or an
+ * @param jpegBuf pointer to a byte buffer containing a JPEG image or an
  * "abbreviated table specification" (AKA "tables-only") datastream.  Passing a
  * tables-only datastream to this function primes the decompressor with
  * quantization and Huffman tables that can be used when decompressing
@@ -1145,26 +1149,26 @@ DLLEXPORT tjhandle tjInitDecompress(void);
  * @param jpegSize size of the JPEG image or tables-only datastream (in bytes)
  *
  * @param width pointer to an integer variable that will receive the width (in
- * pixels) of the JPEG image.  If <tt>jpegBuf</tt> points to a tables-only
- * datastream, then <tt>width</tt> is ignored.
+ * pixels) of the JPEG image.  If `jpegBuf` points to a tables-only datastream,
+ * then `width` is ignored.
  *
  * @param height pointer to an integer variable that will receive the height
- * (in pixels) of the JPEG image.  If <tt>jpegBuf</tt> points to a tables-only
- * datastream, then <tt>height</tt> is ignored.
+ * (in pixels) of the JPEG image.  If `jpegBuf` points to a tables-only
+ * datastream, then `height` is ignored.
  *
  * @param jpegSubsamp pointer to an integer variable that will receive the
  * level of chrominance subsampling used when the JPEG image was compressed
- * (see @ref TJSAMP "Chrominance subsampling options".)  If <tt>jpegBuf</tt>
- * points to a tables-only datastream, then <tt>jpegSubsamp</tt> is ignored.
+ * (see @ref TJSAMP "Chrominance subsampling options".)  If `jpegBuf` points to
+ * a tables-only datastream, then `jpegSubsamp` is ignored.
  *
  * @param jpegColorspace pointer to an integer variable that will receive one
  * of the JPEG colorspace constants, indicating the colorspace of the JPEG
- * image (see @ref TJCS "JPEG colorspaces".)  If <tt>jpegBuf</tt>
- * points to a tables-only datastream, then <tt>jpegColorspace</tt> is ignored.
+ * image (see @ref TJCS "JPEG colorspaces".)  If `jpegBuf` points to a
+ * tables-only datastream, then `jpegColorspace` is ignored.
  *
  * @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()
  * and #tjGetErrorCode().)
-*/
+ */
 DLLEXPORT int tjDecompressHeader3(tjhandle handle,
                                   const unsigned char *jpegBuf,
                                   unsigned long jpegSize, int *width,
@@ -1173,58 +1177,60 @@ DLLEXPORT int tjDecompressHeader3(tjhandle handle,
 
 
 /**
- * Returns a list of fractional scaling factors that the JPEG decompressor in
- * this implementation of TurboJPEG supports.
+ * Returns a list of fractional scaling factors that the JPEG decompressor
+ * supports.
  *
- * @param numscalingfactors pointer to an integer variable that will receive
+ * @param numScalingFactors pointer to an integer variable that will receive
  * the number of elements in the list
  *
  * @return a pointer to a list of fractional scaling factors, or NULL if an
  * error is encountered (see #tjGetErrorStr2().)
-*/
-DLLEXPORT tjscalingfactor *tjGetScalingFactors(int *numscalingfactors);
+ */
+DLLEXPORT tjscalingfactor *tjGetScalingFactors(int *numScalingFactors);
 
 
 /**
- * Decompress a JPEG image to an RGB, grayscale, or CMYK image.
+ * Decompress a JPEG image into a packed-pixel RGB, grayscale, or CMYK image.
  *
  * @param handle a handle to a TurboJPEG decompressor or transformer instance
  *
- * @param jpegBuf pointer to a buffer containing the JPEG image to decompress
+ * @param jpegBuf pointer to a byte buffer containing the JPEG image to
+ * decompress
  *
  * @param jpegSize size of the JPEG image (in bytes)
  *
- * @param dstBuf pointer to an image buffer that will receive the decompressed
- * image.  This buffer should normally be <tt>pitch * scaledHeight</tt> bytes
- * in size, where <tt>scaledHeight</tt> can be determined by calling
- * #TJSCALED() with the JPEG image height and one of the scaling factors
- * returned by #tjGetScalingFactors().  The <tt>dstBuf</tt> pointer may also be
- * used to decompress into a specific region of a larger buffer.
+ * @param dstBuf pointer to a buffer that will receive the packed-pixel
+ * decompressed image.  This buffer should normally be `pitch * scaledHeight`
+ * bytes in size, where `scaledHeight` can be determined by calling #TJSCALED()
+ * with the JPEG image height and one of the scaling factors returned by
+ * #tjGetScalingFactors().  The `dstBuf` pointer may also be used to decompress
+ * into a specific region of a larger buffer.
  *
  * @param width desired width (in pixels) of the destination image.  If this is
  * different than the width of the JPEG image being decompressed, then
  * TurboJPEG will use scaling in the JPEG decompressor to generate the largest
- * possible image that will fit within the desired width.  If <tt>width</tt> is
- * set to 0, then only the height will be considered when determining the
- * scaled image size.
- *
- * @param pitch bytes per line in the destination image.  Normally, this is
- * <tt>scaledWidth * #tjPixelSize[pixelFormat]</tt> if the decompressed image
- * is unpadded, else <tt>#TJPAD(scaledWidth * #tjPixelSize[pixelFormat])</tt>
- * if each line of the decompressed image is padded to the nearest 32-bit
- * boundary, as is the case for Windows bitmaps.  (NOTE: <tt>scaledWidth</tt>
- * can be determined by calling #TJSCALED() with the JPEG image width and one
- * of the scaling factors returned by #tjGetScalingFactors().)  You can also be
- * clever and use the pitch parameter to skip lines, etc.  Setting this
- * parameter to 0 is the equivalent of setting it to
+ * possible image that will fit within the desired width.  If `width` is set to
+ * 0, then only the height will be considered when determining the scaled image
+ * size.
+ *
+ * @param pitch bytes per row in the destination image.  Normally this should
+ * be set to <tt>scaledWidth * #tjPixelSize[pixelFormat]</tt>, if the
+ * destination image should be unpadded, or
+ * <tt>#TJPAD(scaledWidth * #tjPixelSize[pixelFormat])</tt> if each row of the
+ * destination image should be padded to the nearest multiple of 4 bytes, as is
+ * the case for Windows bitmaps.  (NOTE: `scaledWidth` can be determined by
+ * calling #TJSCALED() with the JPEG image width and one of the scaling factors
+ * returned by #tjGetScalingFactors().)  You can also be clever and use the
+ * pitch parameter to skip rows, etc.  Setting this parameter to 0 is the
+ * equivalent of setting it to
  * <tt>scaledWidth * #tjPixelSize[pixelFormat]</tt>.
  *
  * @param height desired height (in pixels) of the destination image.  If this
  * is different than the height of the JPEG image being decompressed, then
  * TurboJPEG will use scaling in the JPEG decompressor to generate the largest
- * possible image that will fit within the desired height.  If <tt>height</tt>
- * is set to 0, then only the width will be considered when determining the
- * scaled image size.
+ * possible image that will fit within the desired height.  If `height` is set
+ * to 0, then only the width will be considered when determining the scaled
+ * image size.
  *
  * @param pixelFormat pixel format of the destination image (see @ref
  * TJPF "Pixel formats".)
@@ -1242,44 +1248,45 @@ DLLEXPORT int tjDecompress2(tjhandle handle, const unsigned char *jpegBuf,
 
 
 /**
- * Decompress a JPEG image to a YUV planar image.  This function performs JPEG
- * decompression but leaves out the color conversion step, so a planar YUV
- * image is generated instead of an RGB image.
+ * Decompress a JPEG image into a unified planar YUV image.  This function
+ * performs JPEG decompression but leaves out the color conversion step, so a
+ * planar YUV image is generated instead of a packed-pixel image.
  *
  * @param handle a handle to a TurboJPEG decompressor or transformer instance
  *
- * @param jpegBuf pointer to a buffer containing the JPEG image to decompress
+ * @param jpegBuf pointer to a byte buffer containing the JPEG image to
+ * decompress
  *
  * @param jpegSize size of the JPEG image (in bytes)
  *
- * @param dstBuf pointer to an image buffer that will receive the YUV image.
- * Use #tjBufSizeYUV2() to determine the appropriate size for this buffer based
- * on the image width, height, padding, and level of subsampling.  The Y,
- * U (Cb), and V (Cr) image planes will be stored sequentially in the buffer
- * (refer to @ref YUVnotes "YUV Image Format Notes".)
+ * @param dstBuf pointer to a buffer that will receive the unified planar YUV
+ * decompressed image.  Use #tjBufSizeYUV2() to determine the appropriate size
+ * for this buffer based on the scaled image width, scaled image height, row
+ * alignment, and level of chrominance subsampling.  The Y, U (Cb), and V (Cr)
+ * image planes will be stored sequentially in the buffer.  (Refer to
+ * @ref YUVnotes "YUV Image Format Notes".)
  *
  * @param width desired width (in pixels) of the YUV image.  If this is
  * different than the width of the JPEG image being decompressed, then
  * TurboJPEG will use scaling in the JPEG decompressor to generate the largest
- * possible image that will fit within the desired width.  If <tt>width</tt> is
- * set to 0, then only the height will be considered when determining the
- * scaled image size.  If the scaled width is not an even multiple of the MCU
- * block width (see #tjMCUWidth), then an intermediate buffer copy will be
- * performed within TurboJPEG.
+ * possible image that will fit within the desired width.  If `width` is set to
+ * 0, then only the height will be considered when determining the scaled image
+ * size.  If the scaled width is not an even multiple of the MCU block width
+ * (see #tjMCUWidth), then an intermediate buffer copy will be performed.
  *
- * @param pad the width of each line in each plane of the YUV image will be
- * padded to the nearest multiple of this number of bytes (must be a power of
- * 2.)  To generate images suitable for X Video, <tt>pad</tt> should be set to
- * 4.
+ * @param align row alignment (in bytes) of the YUV image (must be a power of
+ * 2.)  Setting this parameter to n will cause each row in each plane of the
+ * YUV image to be padded to the nearest multiple of n bytes (1 = unpadded.)
+ * To generate images suitable for X Video, `align` should be set to 4.
  *
  * @param height desired height (in pixels) of the YUV image.  If this is
  * different than the height of the JPEG image being decompressed, then
  * TurboJPEG will use scaling in the JPEG decompressor to generate the largest
- * possible image that will fit within the desired height.  If <tt>height</tt>
- * is set to 0, then only the width will be considered when determining the
- * scaled image size.  If the scaled height is not an even multiple of the MCU
- * block height (see #tjMCUHeight), then an intermediate buffer copy will be
- * performed within TurboJPEG.
+ * possible image that will fit within the desired height.  If `height` is set
+ * to 0, then only the width will be considered when determining the scaled
+ * image size.  If the scaled height is not an even multiple of the MCU block
+ * height (see #tjMCUHeight), then an intermediate buffer copy will be
+ * performed.
  *
  * @param flags the bitwise OR of one or more of the @ref TJFLAG_ACCURATEDCT
  * "flags"
@@ -1289,54 +1296,55 @@ DLLEXPORT int tjDecompress2(tjhandle handle, const unsigned char *jpegBuf,
  */
 DLLEXPORT int tjDecompressToYUV2(tjhandle handle, const unsigned char *jpegBuf,
                                  unsigned long jpegSize, unsigned char *dstBuf,
-                                 int width, int pad, int height, int flags);
+                                 int width, int align, int height, int flags);
 
 
 /**
  * Decompress a JPEG image into separate Y, U (Cb), and V (Cr) image
  * planes.  This function performs JPEG decompression but leaves out the color
- * conversion step, so a planar YUV image is generated instead of an RGB image.
+ * conversion step, so a planar YUV image is generated instead of a
+ * packed-pixel image.
  *
  * @param handle a handle to a TurboJPEG decompressor or transformer instance
  *
- * @param jpegBuf pointer to a buffer containing the JPEG image to decompress
+ * @param jpegBuf pointer to a byte buffer containing the JPEG image to
+ * decompress
  *
  * @param jpegSize size of the JPEG image (in bytes)
  *
  * @param dstPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes
  * (or just a Y plane, if decompressing a grayscale image) that will receive
- * the YUV image.  These planes can be contiguous or non-contiguous in memory.
- * Use #tjPlaneSizeYUV() to determine the appropriate size for each plane based
- * on the scaled image width, scaled image height, strides, and level of
- * chrominance subsampling.  Refer to @ref YUVnotes "YUV Image Format Notes"
- * for more details.
+ * the decompressed image.  These planes can be contiguous or non-contiguous in
+ * memory.  Use #tjPlaneSizeYUV() to determine the appropriate size for each
+ * plane based on the scaled image width, scaled image height, strides, and
+ * level of chrominance subsampling.  Refer to @ref YUVnotes
+ * "YUV Image Format Notes" for more details.
  *
  * @param width desired width (in pixels) of the YUV image.  If this is
  * different than the width of the JPEG image being decompressed, then
  * TurboJPEG will use scaling in the JPEG decompressor to generate the largest
- * possible image that will fit within the desired width.  If <tt>width</tt> is
- * set to 0, then only the height will be considered when determining the
- * scaled image size.  If the scaled width is not an even multiple of the MCU
- * block width (see #tjMCUWidth), then an intermediate buffer copy will be
- * performed within TurboJPEG.
+ * possible image that will fit within the desired width.  If `width` is set to
+ * 0, then only the height will be considered when determining the scaled image
+ * size.  If the scaled width is not an even multiple of the MCU block width
+ * (see #tjMCUWidth), then an intermediate buffer copy will be performed.
  *
  * @param strides an array of integers, each specifying the number of bytes per
- * line in the corresponding plane of the output image.  Setting the stride for
- * any plane to 0 is the same as setting it to the scaled plane width (see
- * @ref YUVnotes "YUV Image Format Notes".)  If <tt>strides</tt> is NULL, then
- * the strides for all planes will be set to their respective scaled plane
- * widths.  You can adjust the strides in order to add an arbitrary amount of
- * line padding to each plane or to decompress the JPEG image into a subregion
- * of a larger YUV planar image.
+ * row in the corresponding plane of the YUV image.  Setting the stride for any
+ * plane to 0 is the same as setting it to the scaled plane width (see
+ * @ref YUVnotes "YUV Image Format Notes".)  If `strides` is NULL, then the
+ * strides for all planes will be set to their respective scaled plane widths.
+ * You can adjust the strides in order to add an arbitrary amount of row
+ * padding to each plane or to decompress the JPEG image into a subregion of a
+ * larger planar YUV image.
  *
  * @param height desired height (in pixels) of the YUV image.  If this is
  * different than the height of the JPEG image being decompressed, then
  * TurboJPEG will use scaling in the JPEG decompressor to generate the largest
- * possible image that will fit within the desired height.  If <tt>height</tt>
- * is set to 0, then only the width will be considered when determining the
- * scaled image size.  If the scaled height is not an even multiple of the MCU
- * block height (see #tjMCUHeight), then an intermediate buffer copy will be
- * performed within TurboJPEG.
+ * possible image that will fit within the desired height.  If `height` is set
+ * to 0, then only the width will be considered when determining the scaled
+ * image size.  If the scaled height is not an even multiple of the MCU block
+ * height (see #tjMCUHeight), then an intermediate buffer copy will be
+ * performed.
  *
  * @param flags the bitwise OR of one or more of the @ref TJFLAG_ACCURATEDCT
  * "flags"
@@ -1352,40 +1360,42 @@ DLLEXPORT int tjDecompressToYUVPlanes(tjhandle handle,
 
 
 /**
- * Decode a YUV planar image into an RGB or grayscale image.  This function
- * uses the accelerated color conversion routines in the underlying
- * codec but does not execute any of the other steps in the JPEG decompression
- * process.
+ * Decode a unified planar YUV image into a packed-pixel RGB or grayscale
+ * image.  This function performs color conversion (which is accelerated in the
+ * libjpeg-turbo implementation) but does not execute any of the other steps in
+ * the JPEG decompression process.
  *
  * @param handle a handle to a TurboJPEG decompressor or transformer instance
  *
- * @param srcBuf pointer to an image buffer containing a YUV planar image to be
- * decoded.  The size of this buffer should match the value returned by
- * #tjBufSizeYUV2() for the given image width, height, padding, and level of
- * chrominance subsampling.  The Y, U (Cb), and V (Cr) image planes should be
- * stored sequentially in the source buffer (refer to @ref YUVnotes
- * "YUV Image Format Notes".)
+ * @param srcBuf pointer to a buffer containing a unified planar YUV source
+ * image to be decoded.  The size of this buffer should match the value
+ * returned by #tjBufSizeYUV2() for the given image width, height, row
+ * alignment, and level of chrominance subsampling.  The Y, U (Cb), and V (Cr)
+ * image planes should be stored sequentially in the source buffer.  (Refer to
+ * @ref YUVnotes "YUV Image Format Notes".)
  *
- * @param pad Use this parameter to specify that the width of each line in each
- * plane of the YUV source image is padded to the nearest multiple of this
- * number of bytes (must be a power of 2.)
+ * @param align row alignment (in bytes) of the YUV source image (must be a
+ * power of 2.)  Setting this parameter to n indicates that each row in each
+ * plane of the YUV source image is padded to the nearest multiple of n bytes
+ * (1 = unpadded.)
  *
  * @param subsamp the level of chrominance subsampling used in the YUV source
  * image (see @ref TJSAMP "Chrominance subsampling options".)
  *
- * @param dstBuf pointer to an image buffer that will receive the decoded
- * image.  This buffer should normally be <tt>pitch * height</tt> bytes in
- * size, but the <tt>dstBuf</tt> pointer can also be used to decode into a
- * specific region of a larger buffer.
+ * @param dstBuf pointer to a buffer that will receive the packed-pixel decoded
+ * image.  This buffer should normally be `pitch * height` bytes in size, but
+ * the `dstBuf` pointer can also be used to decode into a specific region of a
+ * larger buffer.
  *
  * @param width width (in pixels) of the source and destination images
  *
- * @param pitch bytes per line in the destination image.  Normally, this should
- * be <tt>width * #tjPixelSize[pixelFormat]</tt> if the destination image is
- * unpadded, or <tt>#TJPAD(width * #tjPixelSize[pixelFormat])</tt> if each line
- * of the destination image should be padded to the nearest 32-bit boundary, as
- * is the case for Windows bitmaps.  You can also be clever and use the pitch
- * parameter to skip lines, etc.  Setting this parameter to 0 is the equivalent
+ * @param pitch bytes per row in the destination image.  Normally this should
+ * be set to <tt>width * #tjPixelSize[pixelFormat]</tt>, if the destination
+ * image should be unpadded, or
+ * <tt>#TJPAD(width * #tjPixelSize[pixelFormat])</tt> if each row of the
+ * destination image should be padded to the nearest multiple of 4 bytes, as is
+ * the case for Windows bitmaps.  You can also be clever and use the pitch
+ * parameter to skip rows, etc.  Setting this parameter to 0 is the equivalent
  * of setting it to <tt>width * #tjPixelSize[pixelFormat]</tt>.
  *
  * @param height height (in pixels) of the source and destination images
@@ -1400,16 +1410,16 @@ DLLEXPORT int tjDecompressToYUVPlanes(tjhandle handle,
  * and #tjGetErrorCode().)
  */
 DLLEXPORT int tjDecodeYUV(tjhandle handle, const unsigned char *srcBuf,
-                          int pad, int subsamp, unsigned char *dstBuf,
+                          int align, int subsamp, unsigned char *dstBuf,
                           int width, int pitch, int height, int pixelFormat,
                           int flags);
 
 
 /**
- * Decode a set of Y, U (Cb), and V (Cr) image planes into an RGB or grayscale
- * image.  This function uses the accelerated color conversion routines in the
- * underlying codec but does not execute any of the other steps in the JPEG
- * decompression process.
+ * Decode a set of Y, U (Cb), and V (Cr) image planes into a packed-pixel RGB
+ * or grayscale image.  This function performs color conversion (which is
+ * accelerated in the libjpeg-turbo implementation) but does not execute any of
+ * the other steps in the JPEG decompression process.
  *
  * @param handle a handle to a TurboJPEG decompressor or transformer instance
  *
@@ -1422,29 +1432,30 @@ DLLEXPORT int tjDecodeYUV(tjhandle handle, const unsigned char *srcBuf,
  * details.
  *
  * @param strides an array of integers, each specifying the number of bytes per
- * line in the corresponding plane of the YUV source image.  Setting the stride
+ * row in the corresponding plane of the YUV source image.  Setting the stride
  * for any plane to 0 is the same as setting it to the plane width (see
- * @ref YUVnotes "YUV Image Format Notes".)  If <tt>strides</tt> is NULL, then
- * the strides for all planes will be set to their respective plane widths.
- * You can adjust the strides in order to specify an arbitrary amount of line
- * padding in each plane or to decode a subregion of a larger YUV planar image.
+ * @ref YUVnotes "YUV Image Format Notes".)  If `strides` is NULL, then the
+ * strides for all planes will be set to their respective plane widths.  You
+ * can adjust the strides in order to specify an arbitrary amount of row
+ * padding in each plane or to decode a subregion of a larger planar YUV image.
  *
  * @param subsamp the level of chrominance subsampling used in the YUV source
  * image (see @ref TJSAMP "Chrominance subsampling options".)
  *
- * @param dstBuf pointer to an image buffer that will receive the decoded
- * image.  This buffer should normally be <tt>pitch * height</tt> bytes in
- * size, but the <tt>dstBuf</tt> pointer can also be used to decode into a
- * specific region of a larger buffer.
+ * @param dstBuf pointer to a buffer that will receive the packed-pixel decoded
+ * image.  This buffer should normally be `pitch * height` bytes in size, but
+ * the `dstBuf` pointer can also be used to decode into a specific region of a
+ * larger buffer.
  *
  * @param width width (in pixels) of the source and destination images
  *
- * @param pitch bytes per line in the destination image.  Normally, this should
- * be <tt>width * #tjPixelSize[pixelFormat]</tt> if the destination image is
- * unpadded, or <tt>#TJPAD(width * #tjPixelSize[pixelFormat])</tt> if each line
- * of the destination image should be padded to the nearest 32-bit boundary, as
- * is the case for Windows bitmaps.  You can also be clever and use the pitch
- * parameter to skip lines, etc.  Setting this parameter to 0 is the equivalent
+ * @param pitch bytes per row in the destination image.  Normally this should
+ * be set to <tt>width * #tjPixelSize[pixelFormat]</tt>, if the destination
+ * image should be unpadded, or
+ * <tt>#TJPAD(width * #tjPixelSize[pixelFormat])</tt> if each row of the
+ * destination image should be padded to the nearest multiple of 4 bytes, as is
+ * the case for Windows bitmaps.  You can also be clever and use the pitch
+ * parameter to skip rows, etc.  Setting this parameter to 0 is the equivalent
  * of setting it to <tt>width * #tjPixelSize[pixelFormat]</tt>.
  *
  * @param height height (in pixels) of the source and destination images
@@ -1483,50 +1494,51 @@ DLLEXPORT tjhandle tjInitTransform(void);
  * transform requires reading and performing Huffman decoding on all of the
  * coefficients in the source image, regardless of the size of the destination
  * image.  Thus, this function provides a means of generating multiple
- * transformed images from the same source or  applying multiple
- * transformations simultaneously, in order to eliminate the need to read the
- * source coefficients multiple times.
+ * transformed images from the same source or applying multiple transformations
+ * simultaneously, in order to eliminate the need to read the source
+ * coefficients multiple times.
  *
  * @param handle a handle to a TurboJPEG transformer instance
  *
- * @param jpegBuf pointer to a buffer containing the JPEG source image to
+ * @param jpegBuf pointer to a byte buffer containing the JPEG source image to
  * transform
  *
  * @param jpegSize size of the JPEG source image (in bytes)
  *
  * @param n the number of transformed JPEG images to generate
  *
- * @param dstBufs pointer to an array of n image buffers.  <tt>dstBufs[i]</tt>
- * will receive a JPEG image that has been transformed using the parameters in
- * <tt>transforms[i]</tt>.  TurboJPEG has the ability to reallocate the JPEG
- * buffer to accommodate the size of the JPEG image.  Thus, you can choose to:
- * -# pre-allocate the JPEG buffer with an arbitrary size using #tjAlloc() and
- * let TurboJPEG grow the buffer as needed,
- * -# set <tt>dstBufs[i]</tt> to NULL to tell TurboJPEG to allocate the buffer
- * for you, or
+ * @param dstBufs pointer to an array of n byte buffers.  `dstBufs[i]` will
+ * receive a JPEG image that has been transformed using the parameters in
+ * `transforms[i]`.  TurboJPEG has the ability to reallocate the JPEG
+ * destination buffer to accommodate the size of the transformed JPEG image.
+ * Thus, you can choose to:
+ * -# pre-allocate the JPEG destination buffer with an arbitrary size using
+ * #tjAlloc() and let TurboJPEG grow the buffer as needed,
+ * -# set `dstBufs[i]` to NULL to tell TurboJPEG to allocate the buffer for
+ * you, or
  * -# pre-allocate the buffer to a "worst case" size determined by calling
  * #tjBufSize() with the transformed or cropped width and height.  Under normal
  * circumstances, this should ensure that the buffer never has to be
- * re-allocated (setting #TJFLAG_NOREALLOC guarantees that it won't be.)  Note,
- * however, that there are some rare cases (such as transforming images with a
- * large amount of embedded EXIF or ICC profile data) in which the output image
- * will be larger than the worst-case size, and #TJFLAG_NOREALLOC cannot be
- * used in those cases.
+ * re-allocated.  (Setting #TJFLAG_NOREALLOC guarantees that it won't be.)
+ * Note, however, that there are some rare cases (such as transforming images
+ * with a large amount of embedded EXIF or ICC profile data) in which the
+ * transformed JPEG image will be larger than the worst-case size, and
+ * #TJFLAG_NOREALLOC cannot be used in those cases.
  * .
- * If you choose option 1, <tt>dstSizes[i]</tt> should be set to the size of
- * your pre-allocated buffer.  In any case, unless you have set
- * #TJFLAG_NOREALLOC, you should always check <tt>dstBufs[i]</tt> upon return
- * from this function, as it may have changed.
+ * If you choose option 1, then `dstSizes[i]` should be set to the size of your
+ * pre-allocated buffer.  In any case, unless you have set #TJFLAG_NOREALLOC,
+ * you should always check `dstBufs[i]` upon return from this function, as it
+ * may have changed.
  *
  * @param dstSizes pointer to an array of n unsigned long variables that will
  * receive the actual sizes (in bytes) of each transformed JPEG image.  If
- * <tt>dstBufs[i]</tt> points to a pre-allocated buffer, then
- * <tt>dstSizes[i]</tt> should be set to the size of the buffer.  Upon return,
- * <tt>dstSizes[i]</tt> will contain the size of the JPEG image (in bytes.)
+ * `dstBufs[i]` points to a pre-allocated buffer, then `dstSizes[i]` should be
+ * set to the size of the buffer.  Upon return, `dstSizes[i]` will contain the
+ * size of the transformed JPEG image (in bytes.)
  *
  * @param transforms pointer to an array of n #tjtransform structures, each of
  * which specifies the transform parameters and/or cropping region for the
- * corresponding transformed output image.
+ * corresponding transformed JPEG image.
  *
  * @param flags the bitwise OR of one or more of the @ref TJFLAG_ACCURATEDCT
  * "flags"
@@ -1552,10 +1564,10 @@ DLLEXPORT int tjDestroy(tjhandle handle);
 
 
 /**
- * Allocate an image buffer for use with TurboJPEG.  You should always use
- * this function to allocate the JPEG destination buffer(s) for the compression
- * and transform functions unless you are disabling automatic buffer
- * (re)allocation (by setting #TJFLAG_NOREALLOC.)
+ * Allocate a byte buffer for use with TurboJPEG.  You should always use this
+ * function to allocate the JPEG destination buffer(s) for the compression and
+ * transform functions unless you are disabling automatic buffer (re)allocation
+ * (by setting #TJFLAG_NOREALLOC.)
  *
  * @param bytes the number of bytes to allocate
  *
@@ -1568,44 +1580,43 @@ DLLEXPORT unsigned char *tjAlloc(int bytes);
 
 
 /**
- * Load an uncompressed image from disk into memory.
+ * Load a packed-pixel image from disk into memory.
  *
- * @param filename name of a file containing an uncompressed image in Windows
+ * @param filename name of a file containing a packed-pixel image in Windows
  * BMP or PBMPLUS (PPM/PGM) format
  *
  * @param width pointer to an integer variable that will receive the width (in
- * pixels) of the uncompressed image
+ * pixels) of the packed-pixel image
  *
- * @param align row alignment of the image buffer to be returned (must be a
- * power of 2.)  For instance, setting this parameter to 4 will cause all rows
- * in the image buffer to be padded to the nearest 32-bit boundary, and setting
- * this parameter to 1 will cause all rows in the image buffer to be unpadded.
+ * @param align row alignment of the packed-pixel buffer to be returned (must
+ * be a power of 2.)  Setting this parameter to n will cause all rows in the
+ * buffer to be padded to the nearest multiple of n bytes (1 = unpadded.)
  *
  * @param height pointer to an integer variable that will receive the height
- * (in pixels) of the uncompressed image
+ * (in pixels) of the packed-pixel image
  *
  * @param pixelFormat pointer to an integer variable that specifies or will
- * receive the pixel format of the uncompressed image buffer.  The behavior of
- * #tjLoadImage() will vary depending on the value of <tt>*pixelFormat</tt>
- * passed to the function:
- * - @ref TJPF_UNKNOWN : The uncompressed image buffer returned by the function
- * will use the most optimal pixel format for the file type, and
- * <tt>*pixelFormat</tt> will contain the ID of this pixel format upon
- * successful return from the function.
- * - @ref TJPF_GRAY : Only PGM files and 8-bit BMP files with a grayscale
- * colormap can be loaded.
+ * receive the pixel format of the packed-pixel buffer.  The behavior of
+ * #tjLoadImage() will vary depending on the value of `*pixelFormat` passed to
+ * the function:
+ * - @ref TJPF_UNKNOWN : The packed-pixel buffer returned by this function will
+ * use the most optimal pixel format for the file type, and `*pixelFormat` will
+ * contain the ID of that pixel format upon successful return from this
+ * function.
+ * - @ref TJPF_GRAY : Only PGM files and 8-bit-per-pixel BMP files with a
+ * grayscale colormap can be loaded.
  * - @ref TJPF_CMYK : The RGB or grayscale pixels stored in the file will be
  * converted using a quick & dirty algorithm that is suitable only for testing
- * purposes (proper conversion between CMYK and other formats requires a color
- * management system.)
- * - Other @ref TJPF "pixel formats" : The uncompressed image buffer will use
- * the specified pixel format, and pixel format conversion will be performed if
+ * purposes.  (Proper conversion between CMYK and other formats requires a
+ * color management system.)
+ * - Other @ref TJPF "pixel formats" : The packed-pixel buffer will use the
+ * specified pixel format, and pixel format conversion will be performed if
  * necessary.
  *
  * @param flags the bitwise OR of one or more of the @ref TJFLAG_BOTTOMUP
  * "flags".
  *
- * @return a pointer to a newly-allocated buffer containing the uncompressed
+ * @return a pointer to a newly-allocated buffer containing the packed-pixel
  * image, converted to the chosen pixel format and with the chosen row
  * alignment, or NULL if an error occurred (see #tjGetErrorStr2().)  This
  * buffer should be freed using #tjFree().
@@ -1616,31 +1627,31 @@ DLLEXPORT unsigned char *tjLoadImage(const char *filename, int *width,
 
 
 /**
- * Save an uncompressed image from memory to disk.
+ * Save a packed-pixel image from memory to disk.
  *
- * @param filename name of a file to which to save the uncompressed image.
- * The image will be stored in Windows BMP or PBMPLUS (PPM/PGM) format,
- * depending on the file extension.
+ * @param filename name of a file to which to save the packed-pixel image.  The
+ * image will be stored in Windows BMP or PBMPLUS (PPM/PGM) format, depending
+ * on the file extension.
  *
- * @param buffer pointer to an image buffer containing RGB, grayscale, or
- * CMYK pixels to be saved
+ * @param buffer pointer to a buffer containing a packed-pixel RGB, grayscale,
+ * or CMYK image to be saved
  *
- * @param width width (in pixels) of the uncompressed image
+ * @param width width (in pixels) of the packed-pixel image
  *
- * @param pitch bytes per line in the image buffer.  Setting this parameter to
- * 0 is the equivalent of setting it to
+ * @param pitch bytes per row in the packed-pixel image.  Setting this
+ * parameter to 0 is the equivalent of setting it to
  * <tt>width * #tjPixelSize[pixelFormat]</tt>.
  *
- * @param height height (in pixels) of the uncompressed image
+ * @param height height (in pixels) of the packed-pixel image
  *
- * @param pixelFormat pixel format of the image buffer (see @ref TJPF
+ * @param pixelFormat pixel format of the packed-pixel image (see @ref TJPF
  * "Pixel formats".)  If this parameter is set to @ref TJPF_GRAY, then the
- * image will be stored in PGM or 8-bit (indexed color) BMP format.  Otherwise,
- * the image will be stored in PPM or 24-bit BMP format.  If this parameter
- * is set to @ref TJPF_CMYK, then the CMYK pixels will be converted to RGB
- * using a quick & dirty algorithm that is suitable only for testing (proper
- * conversion between CMYK and other formats requires a color management
- * system.)
+ * image will be stored in PGM or 8-bit-per-pixel (indexed color) BMP format.
+ * Otherwise, the image will be stored in PPM or 24-bit-per-pixel BMP format.
+ * If this parameter is set to @ref TJPF_CMYK, then the CMYK pixels will be
+ * converted to RGB using a quick & dirty algorithm that is suitable only for
+ * testing purposes.  (Proper conversion between CMYK and other formats
+ * requires a color management system.)
  *
  * @param flags the bitwise OR of one or more of the @ref TJFLAG_BOTTOMUP
  * "flags".
@@ -1653,8 +1664,8 @@ DLLEXPORT int tjSaveImage(const char *filename, unsigned char *buffer,
 
 
 /**
- * Free an image buffer previously allocated by TurboJPEG.  You should always
- * use this function to free JPEG destination buffer(s) that were automatically
+ * Free a byte buffer previously allocated by TurboJPEG.  You should always use
+ * this function to free JPEG destination buffer(s) that were automatically
  * (re)allocated by the compression and transform functions or that were
  * manually allocated using #tjAlloc().
  *
@@ -1692,14 +1703,10 @@ DLLEXPORT char *tjGetErrorStr2(tjhandle handle);
 DLLEXPORT int tjGetErrorCode(tjhandle handle);
 
 
-/* Deprecated functions and macros */
-#define TJFLAG_FORCEMMX  8
-#define TJFLAG_FORCESSE  16
-#define TJFLAG_FORCESSE2  32
-#define TJFLAG_FORCESSE3  128
+/* Backward compatibility functions and macros (nothing to see here) */
 
+/* TurboJPEG 1.0+ */
 
-/* Backward compatibility functions and macros (nothing to see here) */
 #define NUMSUBOPT  TJ_NUMSAMP
 #define TJ_444  TJSAMP_444
 #define TJ_422  TJSAMP_422
@@ -1715,46 +1722,55 @@ DLLEXPORT int tjGetErrorCode(tjhandle handle);
 #define TJ_ALPHAFIRST  64
 #define TJ_FORCESSE3  TJFLAG_FORCESSE3
 #define TJ_FASTUPSAMPLE  TJFLAG_FASTUPSAMPLE
-#define TJ_YUV  512
 
 DLLEXPORT unsigned long TJBUFSIZE(int width, int height);
 
-DLLEXPORT unsigned long TJBUFSIZEYUV(int width, int height, int jpegSubsamp);
-
-DLLEXPORT unsigned long tjBufSizeYUV(int width, int height, int subsamp);
-
 DLLEXPORT int tjCompress(tjhandle handle, unsigned char *srcBuf, int width,
                          int pitch, int height, int pixelSize,
                          unsigned char *dstBuf, unsigned long *compressedSize,
                          int jpegSubsamp, int jpegQual, int flags);
 
-DLLEXPORT int tjEncodeYUV(tjhandle handle, unsigned char *srcBuf, int width,
-                          int pitch, int height, int pixelSize,
-                          unsigned char *dstBuf, int subsamp, int flags);
-
-DLLEXPORT int tjEncodeYUV2(tjhandle handle, unsigned char *srcBuf, int width,
-                           int pitch, int height, int pixelFormat,
-                           unsigned char *dstBuf, int subsamp, int flags);
+DLLEXPORT int tjDecompress(tjhandle handle, unsigned char *jpegBuf,
+                           unsigned long jpegSize, unsigned char *dstBuf,
+                           int width, int pitch, int height, int pixelSize,
+                           int flags);
 
 DLLEXPORT int tjDecompressHeader(tjhandle handle, unsigned char *jpegBuf,
                                  unsigned long jpegSize, int *width,
                                  int *height);
 
+DLLEXPORT char *tjGetErrorStr(void);
+
+/* TurboJPEG 1.1+ */
+
+#define TJ_YUV  512
+
+DLLEXPORT unsigned long TJBUFSIZEYUV(int width, int height, int jpegSubsamp);
+
 DLLEXPORT int tjDecompressHeader2(tjhandle handle, unsigned char *jpegBuf,
                                   unsigned long jpegSize, int *width,
                                   int *height, int *jpegSubsamp);
 
-DLLEXPORT int tjDecompress(tjhandle handle, unsigned char *jpegBuf,
-                           unsigned long jpegSize, unsigned char *dstBuf,
-                           int width, int pitch, int height, int pixelSize,
-                           int flags);
-
 DLLEXPORT int tjDecompressToYUV(tjhandle handle, unsigned char *jpegBuf,
                                 unsigned long jpegSize, unsigned char *dstBuf,
                                 int flags);
 
-DLLEXPORT char *tjGetErrorStr(void);
+DLLEXPORT int tjEncodeYUV(tjhandle handle, unsigned char *srcBuf, int width,
+                          int pitch, int height, int pixelSize,
+                          unsigned char *dstBuf, int subsamp, int flags);
 
+/* TurboJPEG 1.2+ */
+
+#define TJFLAG_FORCEMMX  8
+#define TJFLAG_FORCESSE  16
+#define TJFLAG_FORCESSE2  32
+#define TJFLAG_FORCESSE3  128
+
+DLLEXPORT unsigned long tjBufSizeYUV(int width, int height, int subsamp);
+
+DLLEXPORT int tjEncodeYUV2(tjhandle handle, unsigned char *srcBuf, int width,
+                           int pitch, int height, int pixelFormat,
+                           unsigned char *dstBuf, int subsamp, int flags);
 
 /**
  * @}
diff --git a/win/jpeg.rc.in b/win/jpeg.rc.in
index fca72b7..650fbe9 100644
--- a/win/jpeg.rc.in
+++ b/win/jpeg.rc.in
@@ -24,7 +24,7 @@ BEGIN
             VALUE "ProductVersion", "@VERSION@"
             VALUE "ProductName", "@CMAKE_PROJECT_NAME@"
             VALUE "InternalName", "jpeg@SO_MAJOR_VERSION@"
-            VALUE "LegalCopyright", "Copyright \xA9 @COPYRIGHT_YEAR@ The libjpeg-turbo Project and many others"
+            VALUE "LegalCopyright", L"Copyright \xA9 @COPYRIGHT_YEAR@ The libjpeg-turbo Project and many others"
             VALUE "OriginalFilename", "jpeg@SO_MAJOR_VERSION@.dll"
         END
     END
diff --git a/win/turbojpeg.rc.in b/win/turbojpeg.rc.in
index cc7ab3a..c6cfc2d 100644
--- a/win/turbojpeg.rc.in
+++ b/win/turbojpeg.rc.in
@@ -24,7 +24,7 @@ BEGIN
             VALUE "ProductVersion", "@VERSION@"
             VALUE "ProductName", "@CMAKE_PROJECT_NAME@"
             VALUE "InternalName", "turbojpeg"
-            VALUE "LegalCopyright", "Copyright \xA9 @COPYRIGHT_YEAR@ The libjpeg-turbo Project and many others"
+            VALUE "LegalCopyright", L"Copyright \xA9 @COPYRIGHT_YEAR@ The libjpeg-turbo Project and many others"
             VALUE "OriginalFilename", "turbojpeg.dll"
         END
     END
diff --git a/wizard.txt b/wizard.txt
index c57fe38..0e155f9 100644
--- a/wizard.txt
+++ b/wizard.txt
@@ -149,7 +149,15 @@ the script represents a progressive or sequential file, by observing whether
 Ss and Se values other than 0 and 63 appear.  (The -progressive switch is
 not needed to specify this; in fact, it is ignored when -scans appears.)
 The scan script must meet the JPEG restrictions on progression sequences.
-(cjpeg checks that the spec's requirements are obeyed.)
+(cjpeg checks that the spec's requirements are obeyed.)  More specifically:
+
+    * An AC scan cannot include coefficients from more than one component.
+
+    * An AC scan for a particular component must be preceded by a DC scan
+      that includes the same component.
+
+    * Only the first AC scan that includes a particular coefficient for a
+      particular component can include more than one bit from that coefficient.
 
 Scan script files are free format, in that arbitrary whitespace can appear
 between numbers and around punctuation.  Also, comments can be included: a
-- 
2.25.1

