From f386f8e5bdba56ff630ab433af0d7440d4cb1f33 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=E9=BB=8E=E5=BF=97=E8=8D=A3?= <lizhirong>
Date: Thu, 7 Mar 2024 16:46:06 +0800
Subject: [PATCH] support spacemit plugin

---
 ext/meson.build                               |    1 +
 ext/spacemit/meson.build                      |    2 +
 .../spacemitcodec/gstspacemitallocator.c      |  450 ++++++
 .../spacemitcodec/gstspacemitallocator.h      |  129 ++
 .../spacemitcodec/gstspacemitbufferpool.c     |  344 ++++
 .../spacemitcodec/gstspacemitbufferpool.h     |   72 +
 ext/spacemit/spacemitcodec/gstspacemitdec.c   | 1371 ++++++++++++++++
 ext/spacemit/spacemitcodec/gstspacemitdec.h   |   98 ++
 .../spacemitcodec/gstspacemitdec_bak.c        | 1394 +++++++++++++++++
 ext/spacemit/spacemitcodec/gstspacemitenc.c   |  862 ++++++++++
 ext/spacemit/spacemitcodec/gstspacemitenc.h   |  105 ++
 .../spacemitcodec/gstspacemitenc_bak.c        | 1022 ++++++++++++
 .../spacemitcodec/gstspacemitplugin.c         |   29 +
 .../spacemitcodec/gstspmdmabufallocator.c     |  310 ++++
 .../spacemitcodec/gstspmdmabufallocator.h     |  123 ++
 ext/spacemit/spacemitcodec/meson.build        |   22 +
 ext/spacemit/spacemitsrc/gstspacemitsrc.c     |  807 ++++++++++
 ext/spacemit/spacemitsrc/gstspacemitsrc.h     |   99 ++
 ext/spacemit/spacemitsrc/gstspmsrcallocator.c |  143 ++
 ext/spacemit/spacemitsrc/gstspmsrcallocator.h |  131 ++
 ext/spacemit/spacemitsrc/meson.build          |   19 +
 meson_options.txt                             |    1 +
 22 files changed, 7534 insertions(+)
 create mode 100755 ext/spacemit/meson.build
 create mode 100755 ext/spacemit/spacemitcodec/gstspacemitallocator.c
 create mode 100755 ext/spacemit/spacemitcodec/gstspacemitallocator.h
 create mode 100755 ext/spacemit/spacemitcodec/gstspacemitbufferpool.c
 create mode 100755 ext/spacemit/spacemitcodec/gstspacemitbufferpool.h
 create mode 100755 ext/spacemit/spacemitcodec/gstspacemitdec.c
 create mode 100755 ext/spacemit/spacemitcodec/gstspacemitdec.h
 create mode 100755 ext/spacemit/spacemitcodec/gstspacemitdec_bak.c
 create mode 100755 ext/spacemit/spacemitcodec/gstspacemitenc.c
 create mode 100755 ext/spacemit/spacemitcodec/gstspacemitenc.h
 create mode 100755 ext/spacemit/spacemitcodec/gstspacemitenc_bak.c
 create mode 100755 ext/spacemit/spacemitcodec/gstspacemitplugin.c
 create mode 100755 ext/spacemit/spacemitcodec/gstspmdmabufallocator.c
 create mode 100755 ext/spacemit/spacemitcodec/gstspmdmabufallocator.h
 create mode 100755 ext/spacemit/spacemitcodec/meson.build
 create mode 100755 ext/spacemit/spacemitsrc/gstspacemitsrc.c
 create mode 100755 ext/spacemit/spacemitsrc/gstspacemitsrc.h
 create mode 100755 ext/spacemit/spacemitsrc/gstspmsrcallocator.c
 create mode 100755 ext/spacemit/spacemitsrc/gstspmsrcallocator.h
 create mode 100755 ext/spacemit/spacemitsrc/meson.build

diff --git a/ext/meson.build b/ext/meson.build
index 17195f8..12838d3 100644
--- a/ext/meson.build
+++ b/ext/meson.build
@@ -73,3 +73,4 @@ subdir('wpe')
 subdir('x265')
 subdir('zxing')
 subdir('zbar')
+subdir('spacemit')
diff --git a/ext/spacemit/meson.build b/ext/spacemit/meson.build
new file mode 100755
index 0000000..32e7164
--- /dev/null
+++ b/ext/spacemit/meson.build
@@ -0,0 +1,2 @@
+subdir('spacemitcodec')
+subdir('spacemitsrc')
\ No newline at end of file
diff --git a/ext/spacemit/spacemitcodec/gstspacemitallocator.c b/ext/spacemit/spacemitcodec/gstspacemitallocator.c
new file mode 100755
index 0000000..abb2b84
--- /dev/null
+++ b/ext/spacemit/spacemitcodec/gstspacemitallocator.c
@@ -0,0 +1,450 @@
+/* GStreamer
+ *
+ * Copyright (C) 2016 Igalia
+ *
+ * Authors:
+ *  Víctor Manuel Jáquez Leal <vjaquez@igalia.com>
+ *  Javier Martin <javiermartin@by.com.es>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "gstspacemitallocator.h"
+
+#define GST_CAT_DEFAULT spacemitallocator_debug_category
+GST_DEBUG_CATEGORY_STATIC (GST_CAT_DEFAULT);
+
+#define GST_SPACEMIT_MEMORY_TYPE "SpaceMitMemory"
+
+#define parent_class gst_spacemit_allocator_parent_class
+
+G_DEFINE_TYPE_WITH_CODE (GstSpaceMitAllocator, gst_spacemit_allocator,
+    GST_TYPE_ALLOCATOR,
+    GST_DEBUG_CATEGORY_INIT (GST_CAT_DEFAULT, "spacemitallocator", 0,
+    "SPACEMIT allocator"));
+
+GQuark
+gst_spm_dmabuf_memory_quark (void)
+{
+  static GQuark quark = 0;
+
+  if (quark == 0)
+    quark = g_quark_from_static_string ("GstSpmDmabufMemory");
+
+  return quark;
+}
+GQuark
+gst_spacemit_allocator_quark (void)
+{
+  static GQuark quark = 0;
+
+  if (quark == 0)
+    quark = g_quark_from_static_string ("GstSpaceMitAllocator");
+
+  return quark;
+}
+
+gboolean
+gst_is_spacemit_memory (GstMemory * base_mem)
+{
+  return gst_memory_is_type (base_mem, GST_SPACEMIT_MEMORY_TYPE);
+}
+
+static void
+gst_spacemit_allocator_free (GstAllocator * allocator, GstMemory * base_mem)
+{
+//  GstSpaceMitAllocator *alloc = GST_SPACEMIT_ALLOCATOR (allocator);
+  GstSpaceMitMemory *mem = (GstSpaceMitMemory *) base_mem;
+  GST_DEBUG ("ZRong ------------------- spacemit free mem");
+
+  g_warn_if_fail (!mem->acquired);
+
+  if (mem->foreign_mem)
+    gst_memory_unref (mem->foreign_mem);
+  else
+     GST_ERROR ("ZRong err ------------------- spacemit free");
+
+//  g_slice_free (GstSpaceMitMemory, mem);
+
+//  GST_ALLOCATOR_CLASS (parent_class)->free (allocator, mem);
+}
+
+static void
+gst_unref_spacemit_mem (gpointer key, gpointer value, gpointer user_data)
+{
+  GstMemory *base_mem = (GstMemory *)value;
+  GstSpaceMitMemory *mem;
+
+  if (GST_IS_SPACEMIT_ALLOCATOR (base_mem->allocator))
+    mem = (GstSpaceMitMemory *) base_mem;
+  else
+    mem = gst_mini_object_get_qdata (GST_MINI_OBJECT (base_mem),
+        GST_SPM_DMABUF_MEMORY_QUARK);
+
+  if (value) {
+    GST_DEBUG ("allocator finalize, mem:%p, base_mem:%p, %d", mem, base_mem, base_mem->mini_object.refcount);
+    gst_memory_unref(base_mem);
+  } else {
+    GST_ERROR ("allocator finalize err, base_mem:%p, %d", base_mem, base_mem->mini_object.refcount);
+  }
+  g_slice_free (GstSpaceMitMemory, mem);
+}
+
+static void
+gst_spacemit_allocator_finalize (GObject * obj)
+{
+  GstSpaceMitAllocator *alloc = GST_SPACEMIT_ALLOCATOR (obj);
+  GST_DEBUG_OBJECT (alloc, "ZRong ------------------- spacemit allocator finalize");
+
+  G_OBJECT_CLASS (parent_class)->finalize (obj);
+}
+/* installed as the GstMiniObject::dispose function of the acquired GstMemory */
+static gboolean
+gst_spacemit_allocator_memory_dispose (GstMemory * base_mem)
+{
+  GstSpaceMitMemory *mem;
+  GstSpaceMitAllocator *allocator;
+  gint fd = -1;
+
+  if (GST_IS_SPACEMIT_ALLOCATOR (base_mem->allocator)) {
+    mem = (GstSpaceMitMemory *) base_mem;
+    allocator = (GstSpaceMitAllocator *)base_mem->allocator;
+    fd = -1;
+  } else {
+    mem = gst_mini_object_get_qdata (GST_MINI_OBJECT (base_mem),
+        GST_SPM_DMABUF_MEMORY_QUARK);
+    allocator = gst_mini_object_get_qdata (GST_MINI_OBJECT (base_mem),
+        GST_SPACEMIT_ALLOCATOR_QUARK);
+    fd = gst_fd_memory_get_fd(base_mem);
+  }
+
+  base_mem->size = mem->memsize;
+
+  if (mem->acquired) 
+  {
+    VDEC_ReturnOutputFrame(mem->ctx, FRAME_GetBaseData(mem->mppframe));
+    FRAME_Destory(mem->mppframe);
+    mem->ctx = NULL;
+    mem->mppframe = NULL;
+
+    /* keep the memory alive */
+    gst_memory_ref (base_mem);
+    GST_DEBUG ("memory dispose success, mem %p fd:(%d, %d), id:%d, base_mem:%p, ref:%d",
+        mem, mem->fd, fd, mem->mppframe_id, base_mem, base_mem->mini_object.refcount);
+
+    mem->acquired = FALSE;
+
+    return FALSE;
+  }
+  GST_DEBUG ("memory dispose222 success, mem %p fd:(%d, %d), id:%d, base_mem:%p, ref:%d",
+      mem, mem->fd, fd, mem->mppframe_id, base_mem, base_mem->mini_object.refcount);
+
+  return TRUE;
+}
+
+static GstSpaceMitMemory *
+gst_spacemit_memory_new (GstSpaceMitAllocator * allocator, gsize maxsize,
+    GstMemoryFlags flags, GstMemory * parent, gssize offset, gssize size)
+{
+  GstSpaceMitMemory *mem;
+  gint align;
+
+  /* GStreamer uses a bitmask for the alignment while
+   * OMX uses the alignment itself. So we have to convert
+   * here */
+  align = 0;
+
+  if (size == -1) {
+    size = maxsize - offset;
+  }
+
+  mem = g_slice_new0 (GstSpaceMitMemory);
+  gst_memory_init (GST_MEMORY_CAST (mem), flags, (GstAllocator *) allocator,
+      parent, maxsize, align, offset, size);
+
+  mem->memsize = size;
+  mem->acquired = FALSE;
+
+  return mem;
+}
+
+static inline void
+install_mem_dispose (GstMemory * base_mem)
+{
+  GST_MINI_OBJECT_CAST (base_mem)->dispose =
+      (GstMiniObjectDisposeFunction) gst_spacemit_allocator_memory_dispose;
+}
+
+GstMemory *
+gst_spacemit_allocator_alloc (GstSpaceMitAllocator * allocator, gsize size)
+{
+  GstMemory *ret_mem;
+  GstSpaceMitMemory *mem;
+  guint8 *data;
+
+  GST_DEBUG_OBJECT (allocator, "allocator alloc paras, size: %d", size);
+
+  if (allocator->mode == GST_SPM_MEMORY_TYPE_SYSTEM) {
+    mem = gst_spacemit_memory_new (allocator, size, 0, NULL, 0, size);
+    install_mem_dispose (GST_MEMORY_CAST (mem));
+  } else {
+    mem = g_slice_new0 (GstSpaceMitMemory);
+    mem->memsize = size;
+    mem->acquired = FALSE;
+    mem->fd = allocator->dmabuf_fd;
+
+    mem->foreign_mem =
+        gst_fd_allocator_alloc (allocator->foreign_allocator, allocator->dmabuf_fd, size, GST_FD_MEMORY_FLAG_DONT_CLOSE);
+    gst_mini_object_set_qdata (GST_MINI_OBJECT (mem->foreign_mem),
+        GST_SPM_DMABUF_MEMORY_QUARK, mem, NULL);
+    gst_mini_object_set_qdata (GST_MINI_OBJECT (mem->foreign_mem),
+        GST_SPACEMIT_ALLOCATOR_QUARK, allocator, NULL);
+    install_mem_dispose (mem->foreign_mem);
+  }
+
+  ret_mem = mem->foreign_mem ? mem->foreign_mem : (GstMemory *) mem;
+
+  GST_DEBUG_OBJECT (allocator, "allocator success alloc mem:%p, return mem:%p", mem, ret_mem);
+
+  return ret_mem;
+}
+
+GstFlowReturn
+gst_spacemit_allocator_acquire (GstAllocator * base_allocator, GstMemory ** memory)
+{
+  GstMemory *base_mem;
+  GstSpaceMitMemory *mem;
+  GstSpaceMitAllocator *allocator = GST_SPACEMIT_ALLOCATOR (base_allocator);
+
+  base_mem = (GstMemory *) g_hash_table_lookup (allocator->memories, GINT_TO_POINTER(allocator->mppframe_id));
+  if (!base_mem) {
+    base_mem = gst_spacemit_allocator_alloc (allocator, allocator->info.size);
+    GST_DEBUG_OBJECT (allocator, "insert id%d fd%d to memories hash", allocator->mppframe_id, allocator->dmabuf_fd);
+    g_hash_table_insert(allocator->memories, GINT_TO_POINTER(allocator->mppframe_id), base_mem);
+  }
+  if (GST_IS_SPACEMIT_ALLOCATOR (base_mem->allocator))
+    mem = (GstSpaceMitMemory *) base_mem;
+  else
+    mem = gst_mini_object_get_qdata (GST_MINI_OBJECT (base_mem),
+        GST_SPM_DMABUF_MEMORY_QUARK);
+  mem->acquired = TRUE;
+  mem->mppframe_id = allocator->mppframe_id;
+  *memory = base_mem;
+
+  GST_DEBUG_OBJECT (allocator, "acquire mem %p size:%d, fd:%d, id:%d, base_mem:%p", mem, (*memory)->size, mem->fd, mem->mppframe_id, base_mem);
+  return GST_FLOW_OK;
+}
+
+gboolean
+gst_spacemit_allocator_configure(GstAllocator * base_allocator, GstVideoInfo * info,  gboolean use_dmabuf)
+{
+  GstSpaceMitAllocator *allocator = GST_SPACEMIT_ALLOCATOR (base_allocator);
+  if (!info) {
+    GST_ERROR_OBJECT (allocator, "error, get a NULL info to allocator!");
+    return FALSE;
+  }
+  allocator->info = *info;
+
+  if (use_dmabuf) {
+    allocator->foreign_allocator = gst_dmabuf_allocator_new ();
+    allocator->mode = GST_SPM_MEMORY_TYPE_DMABUF;
+    GST_DEBUG_OBJECT (allocator, "create a dmabuf allocator!");
+  } else {
+    allocator->mode = GST_SPM_MEMORY_TYPE_SYSTEM;
+  }
+
+  allocator->memories = g_hash_table_new (g_direct_hash, g_direct_equal);
+  allocator->mppframe_id = -1;
+  allocator->active = FALSE;
+  allocator->mem_back = TRUE;
+  g_mutex_init (&allocator->lock);
+
+  return TRUE;
+}
+
+static void
+gst_check_mem_status (gpointer key, gpointer value, gpointer user_data)
+{
+  GstMemory *base_mem = (GstMemory *)value;
+  GstSpaceMitAllocator *allocator = (GstSpaceMitAllocator *)user_data;
+  GstSpaceMitMemory *mem;
+
+  if (GST_IS_SPACEMIT_ALLOCATOR (base_mem->allocator))
+    mem = (GstSpaceMitMemory *) base_mem;
+  else
+    mem = gst_mini_object_get_qdata (GST_MINI_OBJECT (base_mem),
+        GST_SPM_DMABUF_MEMORY_QUARK);
+
+  if (mem->acquired == TRUE) {
+    GST_DEBUG_OBJECT (allocator, "check, mem%d had acquired, mem:%p, base_mem:%p, ref:%d",
+        mem->mppframe_id, mem, base_mem, base_mem->mini_object.refcount);
+    allocator->mem_back = FALSE;
+  }
+  GST_DEBUG_OBJECT (allocator, "check mem status: %d, %d, %d", mem->mppframe_id, mem->acquired, allocator->mem_back);
+
+}
+
+gboolean
+gst_spacemit_allocator_wait_inactive (GstAllocator * base_allocator)
+{
+  GstSpaceMitAllocator *allocator = GST_SPACEMIT_ALLOCATOR (base_allocator);
+
+  while (TRUE) {
+    allocator->mem_back = TRUE;
+    g_hash_table_foreach (allocator->memories, gst_check_mem_status, allocator);
+
+    GST_DEBUG_OBJECT (allocator, "alloctor check mem all back is: %d", allocator->mem_back);
+    break;
+    if (allocator->mem_back) {
+      break;
+    } else {
+      GST_DEBUG_OBJECT (allocator, "wait for spacemit mem inactive");
+      g_usleep(5 * 1000);
+    }
+  }
+}
+
+void gst_spacemitdec_mem_hash_reinit (GstAllocator * base_allocator)
+{
+  GstSpaceMitAllocator *allocator = GST_SPACEMIT_ALLOCATOR (base_allocator);
+
+  g_hash_table_foreach (allocator->memories, gst_unref_spacemit_mem, NULL);
+  g_hash_table_remove_all (allocator->memories);
+}
+
+gboolean
+gst_spacemit_allocator_set_active (GstSpaceMitAllocator * allocator, gboolean active)
+{
+  gboolean changed = FALSE;
+
+  g_mutex_lock (&allocator->lock);
+
+  if (allocator->active != active)
+    changed = TRUE;
+
+  GST_DEBUG_OBJECT (allocator, "allocator set active/deactice paras, cur:%d, set:%d", allocator->active, active);
+
+  if (changed) {
+    if (active) {
+
+    } else {
+      gst_spacemit_allocator_wait_inactive(allocator);
+      g_hash_table_foreach (allocator->memories, gst_unref_spacemit_mem, NULL);
+      g_hash_table_remove_all (allocator->memories);
+      if (allocator->foreign_allocator) {
+        GST_DEBUG_OBJECT (allocator, "ZRong ------------------- allocator unref(%d %d) (%d %d)",
+            GST_OBJECT_REFCOUNT_VALUE(allocator->foreign_allocator), GST_OBJECT_REFCOUNT(allocator->foreign_allocator),
+            GST_OBJECT_REFCOUNT_VALUE(allocator), GST_OBJECT_REFCOUNT(allocator));
+        g_object_unref (allocator->foreign_allocator);
+        allocator->foreign_allocator = NULL;
+      }
+    }
+  }
+
+  allocator->active = active;
+  g_mutex_unlock (&allocator->lock);
+  GST_DEBUG_OBJECT (allocator, "allocator set active/deactice finish");
+
+  return changed;
+}
+
+GstAllocator *
+gst_spacemit_allocator_new (void)
+{
+  GstSpaceMitAllocator *allocator;
+
+  allocator = g_object_new (GST_TYPE_SPACEMIT_ALLOCATOR, NULL);
+
+  allocator->id = 666;
+
+  return GST_ALLOCATOR_CAST (allocator);
+}
+
+static gpointer
+gst_spacemit_memory_map (GstMemory * base_mem, gsize maxsize, GstMapFlags flags)
+{
+  GstSpaceMitMemory *mem = (GstSpaceMitMemory *) base_mem;
+  GST_DEBUG ("ZRong ------------------- af memory_map (%d, %d)", maxsize, mem->mppframe_id);
+
+  return FRAME_GetDataPointer(mem->mppframe, 0);
+}
+static void
+gst_spacemit_memory_unmap (GstMemory * base_mem)
+{
+}
+
+void
+gst_spacemit_allocator_get_info (GstAllocator * base_allocator, gint32 id, gint32 fd)
+{
+  GstSpaceMitAllocator *allocator = GST_SPACEMIT_ALLOCATOR (base_allocator);
+
+  if (id < 0)
+    GST_ERROR_OBJECT (allocator, "error, get a invaild id: %d !", id);
+
+  if (fd < 0 && allocator->mode == GST_SPM_MEMORY_TYPE_DMABUF) {
+    GST_ERROR_OBJECT (allocator, "error, get a invaild fd: %d in dmabuf mode!", fd);
+  }
+
+  allocator->mppframe_id = id;
+  allocator->dmabuf_fd = fd;
+}
+void
+gst_spacemit_set_mem (GstMemory * base_mem, MppFrame *mppframe, MppVdecCtx *ctx)
+{
+  GstSpaceMitMemory *mem;
+
+  if (GST_IS_SPACEMIT_ALLOCATOR (base_mem->allocator))
+    mem = (GstSpaceMitMemory *) base_mem;
+  else
+    mem = gst_mini_object_get_qdata (GST_MINI_OBJECT (base_mem),
+        GST_SPM_DMABUF_MEMORY_QUARK);
+
+  mem->mppframe = mppframe;
+  mem->ctx = ctx;
+}
+
+static void
+gst_spacemit_allocator_class_init (GstSpaceMitAllocatorClass * klass)
+{
+  GObjectClass *gobject_class;
+  GstAllocatorClass *allocator_class;
+
+  allocator_class = GST_ALLOCATOR_CLASS (klass);
+  gobject_class = G_OBJECT_CLASS (klass);
+
+  allocator_class->alloc = NULL;
+  allocator_class->free = gst_spacemit_allocator_free;
+
+  gobject_class->finalize = gst_spacemit_allocator_finalize;
+}
+
+static void
+gst_spacemit_allocator_init (GstSpaceMitAllocator * allocator)
+{
+  GstAllocator *alloc = GST_ALLOCATOR_CAST (allocator);
+
+  alloc->mem_type = GST_SPACEMIT_MEMORY_TYPE;
+  alloc->mem_map = gst_spacemit_memory_map;
+  alloc->mem_unmap = gst_spacemit_memory_unmap;
+
+  GST_OBJECT_FLAG_SET (allocator, GST_ALLOCATOR_FLAG_CUSTOM_ALLOC);
+}
+
diff --git a/ext/spacemit/spacemitcodec/gstspacemitallocator.h b/ext/spacemit/spacemitcodec/gstspacemitallocator.h
new file mode 100755
index 0000000..b4a0b9f
--- /dev/null
+++ b/ext/spacemit/spacemitcodec/gstspacemitallocator.h
@@ -0,0 +1,129 @@
+/* GStreamer
+ *
+ * Copyright (C) 2016 Igalia
+ *
+ * Authors:
+ *  Víctor Manuel Jáquez Leal <vjaquez@igalia.com>
+ *  Javier Martin <javiermartin@by.com.es>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ *
+ */
+
+#ifndef __GST_SPACEMIT_ALLOCATOR_H__
+#define __GST_SPACEMIT_ALLOCATOR_H__
+
+#include <gst/gst.h>
+#include <gst/video/video.h>
+#include <vdec.h>
+#include <gst/allocators/gstdmabuf.h>
+
+G_BEGIN_DECLS
+
+/* ---------------------------------------------------------------------*/
+/* GstSpmSystemoMemory                                                  */
+/* ---------------------------------------------------------------------*/
+
+#define GST_TYPE_SPACEMIT_ALLOCATOR	\
+   (gst_spacemit_allocator_get_type())
+#define GST_IS_SPACEMIT_ALLOCATOR(obj)				\
+   (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_SPACEMIT_ALLOCATOR))
+#define GST_IS_SPACEMIT_ALLOCATOR_CLASS(klass)			\
+   (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_SPACEMIT_ALLOCATOR))
+#define GST_SPACEMIT_ALLOCATOR_GET_CLASS(obj)			\
+   (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_SPACEMIT_ALLOCATOR, GstSpaceMitAllocatorClass))
+#define GST_SPACEMIT_ALLOCATOR(obj)				\
+   (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_SPACEMIT_ALLOCATOR, GstSpaceMitAllocator))
+#define GST_SPACEMIT_ALLOCATOR_CLASS(klass)			\
+   (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_SPACEMIT_ALLOCATOR, GstSpaceMitAllocatorClass))
+
+typedef struct _GstSpaceMitAllocator GstSpaceMitAllocator;
+typedef struct _GstSpaceMitAllocatorClass GstSpaceMitAllocatorClass;
+typedef struct _GstSpaceMitMemory GstSpaceMitMemory;
+
+typedef enum _GstSpmMemoryType
+{
+  GST_SPM_MEMORY_TYPE_SYSTEM,
+  GST_SPM_MEMORY_TYPE_DMABUF,
+} GstSpmMemoryType;
+
+struct _GstSpaceMitMemory
+{
+  GstMemory parent;
+
+  gboolean acquired;
+  MppFrame *mppframe;
+  gpointer ptr;
+
+  MppVdecCtx *ctx;
+  guint32 memsize;
+  gint32 mppframe_id;
+  GstMemory *foreign_mem;
+
+  guint32 fd;
+  /* the original dispose function of foreign_mem */
+  GstMiniObjectDisposeFunction foreign_dispose;
+};
+
+struct _GstSpaceMitAllocator
+{
+  GstAllocator parent;
+  gboolean active;
+  GMutex lock;
+
+  GHashTable *memories;
+  gint32 mppframe_id;
+  gint32 dmabuf_fd;
+  guint32 id;
+  GstVideoInfo info;
+  GstAllocator *foreign_allocator;
+  GstSpmMemoryType mode;
+  gboolean mem_back;
+};
+
+struct _GstSpaceMitAllocatorClass {
+  GstAllocatorClass parent_class;
+};
+GQuark gst_spm_dmabuf_memory_quark (void);
+GQuark gst_spacemit_allocator_quark (void);
+
+#define GST_SPM_DMABUF_MEMORY_QUARK gst_spm_dmabuf_memory_quark ()
+#define GST_SPACEMIT_ALLOCATOR_QUARK gst_spacemit_allocator_quark ()
+
+gboolean gst_is_spacemit_memory (GstMemory *mem);
+GstAllocator *
+gst_spacemit_allocator_new (void);
+GstMemory *
+gst_spacemit_allocator_alloc (GstSpaceMitAllocator * allocator, gsize size);
+GstFlowReturn
+gst_spacemit_allocator_acquire (GstAllocator * base_allocator, GstMemory ** memory);
+gboolean
+gst_spacemit_allocator_configure(GstAllocator * base_allocator, GstVideoInfo * info,  gboolean use_dmabuf);
+gboolean
+gst_spacemit_allocator_set_active (GstSpaceMitAllocator * allocator, gboolean active);
+
+void
+gst_spacemit_allocator_get_info (GstAllocator * base_allocator, gint32 id, gint32 fd);
+void
+gst_spacemit_set_mem (GstMemory * base_mem, MppFrame *mppframe, MppVdecCtx *ctx);
+gboolean
+gst_spacemit_allocator_wait_inactive (GstAllocator * base_allocator);
+
+GType gst_spacemit_allocator_get_type (void) G_GNUC_CONST;
+
+G_END_DECLS
+
+#endif /* __GST_SPACEMIT_ALLOCATOR_H__ */
diff --git a/ext/spacemit/spacemitcodec/gstspacemitbufferpool.c b/ext/spacemit/spacemitcodec/gstspacemitbufferpool.c
new file mode 100755
index 0000000..cd186ab
--- /dev/null
+++ b/ext/spacemit/spacemitcodec/gstspacemitbufferpool.c
@@ -0,0 +1,344 @@
+/* GStreamer
+ * Copyright (C) <2005> Julien Moutte <julien@moutte.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+/* Debugging category */
+#include <gst/gstinfo.h>
+#include "gstspacemitbufferpool.h"
+#include "gstspacemitallocator.h"
+
+/* Helper functions */
+#include <gst/video/video.h>
+#include <gst/video/gstvideometa.h>
+#include <gst/video/gstvideopool.h>
+#include <gst/gstbufferpool.h>
+
+#define GST_CAT_DEFAULT gst_spacemitbufferpool_debug_category
+GST_DEBUG_CATEGORY_STATIC (GST_CAT_DEFAULT);
+
+/* bufferpool */
+static void gst_spacemit_buffer_pool_finalize (GObject * object);
+#define gst_spacemit_buffer_pool_parent_class parent_class
+
+G_DEFINE_TYPE_WITH_CODE (GstSpaceMitBufferPool, gst_spacemit_buffer_pool,
+    GST_TYPE_BUFFER_POOL,
+    GST_DEBUG_CATEGORY_INIT (GST_CAT_DEFAULT, "SpaceMitbufferpool", 0,
+        "spacemit buffer pool"));
+
+static gboolean
+gst_spacemit_buffer_pool_start (GstBufferPool * base_pool)
+{
+  GstSpaceMitBufferPool *pool = GST_SPACEMIT_BUFFER_POOL (base_pool);
+  gboolean ret;
+
+  GST_DEBUG ("ZRong  ------------------------af pool start.(%d)", ret);
+
+  gst_spacemit_allocator_set_active (pool->allocator, TRUE);
+
+  ret = GST_BUFFER_POOL_CLASS (gst_spacemit_buffer_pool_parent_class)->start (base_pool);
+
+  return ret;
+}
+
+static gboolean
+gst_spacemit_buffer_pool_stop (GstBufferPool * base_pool)
+{
+  GstSpaceMitBufferPool *pool = GST_SPACEMIT_BUFFER_POOL_CAST (base_pool);
+
+  GST_DEBUG_OBJECT (pool, "deactivating spacemit allocator");
+  gst_spacemit_allocator_set_active (pool->allocator, FALSE);
+
+  if (pool->caps)
+    gst_caps_unref (pool->caps);
+  pool->caps = NULL;
+
+//  pool->add_videometa = FALSE;
+//  pool->deactivated = TRUE;
+
+  return GST_BUFFER_POOL_CLASS (parent_class)->stop (base_pool);
+}
+
+static const gchar **
+gst_spacemit_buffer_pool_get_options (GstBufferPool * base_pool)
+{
+  static const gchar *options[] = { GST_BUFFER_POOL_OPTION_VIDEO_META,
+    NULL
+  };
+  return options;
+}
+
+static inline GstSpmMemoryType
+_spm_get_memory_type (GstStructure * config)
+{
+  gboolean video, dmabuf;
+
+  dmabuf = gst_buffer_pool_config_has_option (config,
+      GST_BUFFER_POOL_OPTION_SPM_USE_DMABUF);
+
+  if (dmabuf)
+    return GST_SPM_MEMORY_TYPE_DMABUF;
+  else
+    return GST_SPM_MEMORY_TYPE_SYSTEM;
+}
+
+static gboolean
+gst_spacemit_buffer_pool_set_config (GstBufferPool * base_pool, GstStructure * config)
+{
+  GstSpaceMitBufferPool *pool = GST_SPACEMIT_BUFFER_POOL_CAST (base_pool);
+  GstVideoInfo info;
+  GstCaps *caps;
+  guint size, min_buffers, max_buffers;
+  GstAllocator *allocator;
+  GstAllocationParams params;
+  GstStructure *fake_config;
+  gboolean ret;
+
+  GST_DEBUG ("ZRong -------------------- in spacemit bufferpool set_config");
+
+  if (!gst_buffer_pool_config_get_params (config, &caps, &size, &min_buffers,
+          &max_buffers))
+    goto wrong_config;
+
+  if (caps == NULL)
+    goto no_caps;
+
+  /* now parse the caps from the config */
+  if (!gst_video_info_from_caps (&info, caps))
+    goto wrong_caps;
+
+  if (!gst_buffer_pool_config_get_allocator (config, &allocator, &params))
+    goto wrong_config;
+
+  /* enable metadata based on config of the pool */
+  pool->add_videometa =
+      gst_buffer_pool_config_has_option (config,
+      GST_BUFFER_POOL_OPTION_VIDEO_META);
+
+  if (pool->caps)
+    gst_caps_unref (pool->caps);
+  pool->caps = gst_caps_ref (caps);
+
+  gst_buffer_pool_config_set_params (config, caps, size, min_buffers, max_buffers);
+  pool->memory_type = _spm_get_memory_type (config);
+
+  /* give a fake config to the parent default_set_config() with size == 0
+   * this prevents default_release_buffer() from free'ing the buffers, since
+   * we release them with no memory */
+  fake_config = gst_structure_copy (config);
+  gst_buffer_pool_config_set_params (fake_config, caps, 0, min_buffers, max_buffers);
+
+  if (pool->allocator)
+    gst_object_unref (pool->allocator);
+
+  pool->allocator = gst_object_ref (allocator);
+  pool->info = info;
+  pool->params = params;
+
+  ret = GST_BUFFER_POOL_CLASS (parent_class)->set_config (base_pool, fake_config);
+  gst_structure_free (fake_config);
+
+  return ret;
+
+/* ERRORS */
+wrong_config:
+  {
+    GST_WARNING_OBJECT (pool, "invalid config");
+    return FALSE;
+  }
+no_caps:
+  {
+    GST_WARNING_OBJECT (pool, "no caps in config");
+    return FALSE;
+  }
+
+wrong_caps:
+  {
+    GST_WARNING_OBJECT (pool,
+        "failed getting geometry from caps %" GST_PTR_FORMAT, caps);
+    return FALSE;
+  }
+}
+static void
+gst_spacemit_buffer_pool_reset_buffer (GstBufferPool * base_pool, GstBuffer * buffer)
+{
+  GstSpaceMitBufferPool *pool = GST_SPACEMIT_BUFFER_POOL_CAST (base_pool);
+  guint n;
+  guint size;
+
+  n = gst_buffer_n_memory (buffer);
+  size = gst_buffer_get_size (buffer);
+
+  GST_DEBUG ("ZRong omx ------------------------ reset buffer.(%d)", size);
+
+  if (G_UNLIKELY (n != 1)) {
+    GST_ERROR_OBJECT (pool, "Released buffer does not have 1 memory... "
+        "(n = %u) something went terribly wrong", n);
+  }
+
+  /* rip the memory out of the buffer;
+   * we like to keep them separate in this pool.
+   * if this was the last ref count of the memory, it will be returned
+   * to the allocator, otherwise it will be returned later */
+  gst_buffer_remove_all_memory (buffer);
+
+  /* reset before removing the TAG_MEMORY flag so that the parent impl
+   * doesn't try to restore the original buffer size */
+  GST_BUFFER_POOL_CLASS (parent_class)->reset_buffer
+      (base_pool, buffer);
+  n = gst_buffer_n_memory (buffer);
+  size = gst_buffer_get_size (buffer);
+
+  GST_DEBUG ("ZRong omx ------------------------ reset buffer.(%d %d)", n, size);
+
+  /* pretend nothing happened to the memory to avoid discarding the buffer */
+  GST_MINI_OBJECT_FLAG_UNSET (buffer, GST_BUFFER_FLAG_TAG_MEMORY);
+}
+
+static GstFlowReturn
+gst_spacemit_buffer_pool_alloc_buffer (GstBufferPool * base_pool, GstBuffer ** buffer,
+    GstBufferPoolAcquireParams * params)
+{
+  GstSpaceMitBufferPool *pool = GST_SPACEMIT_BUFFER_POOL_CAST (base_pool);
+  GstVideoInfo *info;
+  GstBuffer *buf;
+  GstMemory *mem;
+
+  info = &pool->info;
+  GST_DEBUG_OBJECT (pool, "ZRong -------------------- in spacemit bufferpool alloc (%d)", info->size);
+  buf = gst_buffer_new ();
+
+  if (pool->add_videometa) {
+    GST_DEBUG_OBJECT (pool, "adding GstVideoMeta");
+    GstVideoMeta *meta;
+
+    meta = gst_buffer_add_video_meta_full (buf, GST_VIDEO_FRAME_FLAG_NONE,
+        GST_VIDEO_INFO_FORMAT (info),
+        GST_VIDEO_INFO_WIDTH (info), GST_VIDEO_INFO_HEIGHT (info),
+        GST_VIDEO_INFO_N_PLANES (info), info->offset, info->stride);
+    //gst_video_meta_set_alignment (meta, 0);
+  }
+
+  *buffer = buf;
+  GST_DEBUG ("ZRong -------------------- out spacemit bufferpool alloc");
+
+  return GST_FLOW_OK;
+}
+static GstFlowReturn
+gst_spacemit_buffer_pool_acquire_buffer (GstBufferPool * base_pool,
+    GstBuffer ** buffer, GstBufferPoolAcquireParams * params)
+{
+  GstFlowReturn ret;
+  GstSpaceMitBufferPool *pool = GST_SPACEMIT_BUFFER_POOL (base_pool);
+  GstMemory *mem;
+
+  GST_DEBUG ("ZRong -------------------- in acquire_buffer");
+
+  ret = GST_BUFFER_POOL_CLASS (parent_class)->acquire_buffer
+      (base_pool, buffer, params);
+  if (ret != GST_FLOW_OK)
+    return ret;
+
+//  if (pool->memory_type == GST_SPM_MEMORY_TYPE_SYSTEM)
+  GST_DEBUG ("ZRong ----------- in acquire_buffer, bf allocator_acquire");
+
+    ret = gst_spacemit_allocator_acquire (pool->allocator, &mem);
+//  else
+//    ret = gst_spm_dmabuf_allocator_acquire (pool->allocator, &mem);
+
+  if (ret != GST_FLOW_OK)
+    return ret;
+
+  gst_buffer_append_memory (*buffer, mem);
+
+  return ret;
+}
+
+static void
+gst_spacemit_buffer_pool_release_buffer (GstBufferPool * base_pool, GstBuffer * buffer)
+{
+  guint n;
+  gsize size, len;
+
+  n = gst_buffer_n_memory (buffer);
+  len = n;
+  size = gst_buffer_get_size (buffer);
+  GST_DEBUG ("ZRong ------------------------ release buffer.(%d, %d, %d)", n, len, size);
+
+  GST_BUFFER_POOL_CLASS (parent_class)->release_buffer(base_pool, buffer);
+}
+GstBufferPool *
+gst_spacemit_buffer_pool_new (void)
+{
+  GstSpaceMitBufferPool *pool;
+  
+  pool = g_object_new (GST_TYPE_SPACEMIT_BUFFER_POOL, NULL);
+
+  GST_DEBUG_OBJECT (pool, "ZRong new spacemit buffer pool %p", pool);
+  
+  return GST_BUFFER_POOL (pool);
+}
+
+static void
+gst_spacemit_buffer_pool_finalize (GObject * object)
+{
+  GstSpaceMitBufferPool *pool = GST_SPACEMIT_BUFFER_POOL (object);
+  GST_DEBUG ("ZRong  ------------------------af pool finalize.");
+
+  if (pool->allocator) {
+    GST_DEBUG ("ZRong ------------------- af pool finalize (%d %d)",
+        GST_OBJECT_REFCOUNT_VALUE(pool->allocator), GST_OBJECT_REFCOUNT(pool->allocator));
+
+    gst_object_unref (pool->allocator);
+  }
+  pool->allocator = NULL;
+
+  if (pool->caps)
+    gst_caps_unref (pool->caps);
+  pool->caps = NULL;
+
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+static void
+gst_spacemit_buffer_pool_class_init (GstSpaceMitBufferPoolClass * klass)
+{
+  GObjectClass *gobject_class = (GObjectClass *) klass;
+  GstBufferPoolClass *gstbufferpool_class = (GstBufferPoolClass *) klass;
+
+  gobject_class->finalize = gst_spacemit_buffer_pool_finalize;
+
+  gstbufferpool_class->start = gst_spacemit_buffer_pool_start;
+  gstbufferpool_class->stop = gst_spacemit_buffer_pool_stop;
+  gstbufferpool_class->get_options = gst_spacemit_buffer_pool_get_options;
+  gstbufferpool_class->set_config = gst_spacemit_buffer_pool_set_config;
+  gstbufferpool_class->alloc_buffer = gst_spacemit_buffer_pool_alloc_buffer;
+  gstbufferpool_class->reset_buffer = gst_spacemit_buffer_pool_reset_buffer;
+
+  gstbufferpool_class->acquire_buffer = gst_spacemit_buffer_pool_acquire_buffer;
+  gstbufferpool_class->release_buffer = gst_spacemit_buffer_pool_release_buffer;
+}
+
+static void
+gst_spacemit_buffer_pool_init (GstSpaceMitBufferPool * pool)
+{
+}
+
diff --git a/ext/spacemit/spacemitcodec/gstspacemitbufferpool.h b/ext/spacemit/spacemitcodec/gstspacemitbufferpool.h
new file mode 100755
index 0000000..1b40b68
--- /dev/null
+++ b/ext/spacemit/spacemitcodec/gstspacemitbufferpool.h
@@ -0,0 +1,72 @@
+/* GStreamer
+ * Copyright (C) <2005> Julien Moutte <julien@moutte.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef __GST_SPACEMITPOOL_H__
+#define __GST_SPACEMITPOOL_H__
+
+#include <string.h>
+#include <math.h>
+#include <gst/gst.h>
+#include <gst/video/video.h>
+
+#include "gstspacemitallocator.h"
+
+G_BEGIN_DECLS
+
+typedef struct _GstSpaceMitBufferPool GstSpaceMitBufferPool;
+typedef struct _GstSpaceMitBufferPoolClass GstSpaceMitBufferPoolClass;
+
+/* buffer pool functions */
+#define GST_TYPE_SPACEMIT_BUFFER_POOL      (gst_spacemit_buffer_pool_get_type())
+#define GST_IS_SPACEMIT_BUFFER_POOL(obj)   (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_SPACEMIT_BUFFER_POOL))
+#define GST_SPACEMIT_BUFFER_POOL(obj)      (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_SPACEMIT_BUFFER_POOL, GstSpaceMitBufferPool))
+#define GST_SPACEMIT_BUFFER_POOL_CAST(obj) ((GstSpaceMitBufferPool*)(obj))
+
+struct _GstSpaceMitBufferPool
+{
+  GstVideoBufferPool parent;
+
+  GstAllocator *allocator;
+
+  GstCaps *caps;
+  GstVideoInfo info;
+  GstVideoAlignment align;
+  guint    padded_width;
+  guint    padded_height;
+  gboolean add_videometa;
+  gboolean add_metavideo;
+  gboolean need_alignment;
+  GstAllocationParams params;
+
+  GstSpmMemoryType memory_type;
+};
+
+struct _GstSpaceMitBufferPoolClass
+{
+  GstVideoBufferPoolClass parent_class;
+};
+#define GST_BUFFER_POOL_OPTION_SPM_USE_DMABUF "GstBufferPoolOptionSpmUseDMABuf"
+
+GType gst_spacemit_buffer_pool_get_type (void);
+
+GstBufferPool * gst_spacemit_buffer_pool_new     (void);
+
+G_END_DECLS
+
+#endif /* __GST_SPACEMITPOOL_H__ */
diff --git a/ext/spacemit/spacemitcodec/gstspacemitdec.c b/ext/spacemit/spacemitcodec/gstspacemitdec.c
new file mode 100755
index 0000000..d053eff
--- /dev/null
+++ b/ext/spacemit/spacemitcodec/gstspacemitdec.c
@@ -0,0 +1,1371 @@
+/* GStreamer
+ * Copyright (C) 2022 FIXME <fixme@example.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Suite 500,
+ * Boston, MA 02110-1335, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+#include <string.h>
+#include <stdio.h>
+
+#include <gst/gst.h>
+#include <gst/video/video.h>
+#include <gst/video/gstvideodecoder.h>
+#include "gstspacemitdec.h"
+
+GST_DEBUG_CATEGORY_STATIC (gst_spacemitdec_debug_category);
+#define GST_CAT_DEFAULT gst_spacemitdec_debug_category
+
+#define EOS_FARME_NUM 3
+#define MAX_POLL_TIME 0xffffffff
+
+/* prototypes */
+static void gst_spacemitdec_set_property (GObject * object,
+    guint property_id, const GValue * value, GParamSpec * pspec);
+static void gst_spacemitdec_get_property (GObject * object,
+    guint property_id, GValue * value, GParamSpec * pspec);
+static void gst_spacemitdec_finalize (GObject * object);
+static gboolean gst_spacemitdec_close(GstVideoDecoder *decoder);
+static gboolean gst_spacemitdec_start(GstVideoDecoder *decoder);
+static gboolean gst_spacemitdec_stop(GstVideoDecoder *decoder);
+static gboolean gst_spacemitdec_set_format(GstVideoDecoder *decoder, GstVideoCodecState *state);
+static gboolean gst_spacemitdec_reset(GstVideoDecoder *decoder, gboolean hard);
+static gboolean gst_spacemitdec_flush(GstVideoDecoder * decoder);
+static GstFlowReturn gst_spacemitdec_finish(GstVideoDecoder *decoder);
+static GstFlowReturn gst_spacemitdec_handle_frame(GstVideoDecoder *decoder, GstVideoCodecFrame *frame);
+static gboolean gst_spacemitdec_decide_allocation(GstVideoDecoder *decoder, GstQuery *query);
+static GstStateChangeReturn gst_spacemitdec_dec_change_state (GstElement * element, GstStateChange transition);
+
+/* pad templates */
+static GstStaticPadTemplate gst_spacemitdec_sink_template =
+GST_STATIC_PAD_TEMPLATE ("sink",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS
+    ("video/x-h264, stream-format=(string)byte-stream, alignment=(string)au, "
+      "profile=(string){ constrained-baseline, baseline, main, high },"
+      "width=(int) [640,MAX], " "height=(int) [480,MAX]"
+      ";"
+      "video/x-h265,"
+      "stream-format = (string) byte-stream,"
+      "alignment = (string)au,"
+      "width=(int) [640,MAX], " "height=(int) [480,MAX]"
+      ";"
+      "video/mpeg,"
+      "mpegversion = (int) { 1, 2, 4 },"
+      "parsed = (boolean) true,"
+      "systemstream = (boolean) false"
+      ";"
+      "image/jpeg" ";" "video/x-vp8" ";" "video/x-vp9"
+      ));
+
+static GstStaticPadTemplate gst_spacemitdec_src_template =
+    GST_STATIC_PAD_TEMPLATE ("src",
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS (SPM_DEC_CAPS_MAKE ("{" SPM_DEC_FORMATS "}") ";")
+    );
+
+#define parent_class gst_spacemitdec_parent_class
+/* class initialization */
+G_DEFINE_TYPE(GstSpacemitDec, gst_spacemitdec, GST_TYPE_VIDEO_DECODER);
+enum
+{
+  PROP_0,
+  PROP_CODING_WIDTH,
+  PROP_CODING_HIGHT,
+  PROP_CLOSE_DMABUF,
+  PROP_CODE_TYPE,
+  PROP_CODE_YUV_FORMAT,
+  PROP_SAVE_DEC_IMAGE,
+  PROP_DOWNSCALE,
+  N_PROPERTIES
+};
+
+static gboolean
+_gst_caps_has_feature (const GstCaps * caps, const gchar * feature)
+{
+  guint i;
+
+  for (i = 0; i < gst_caps_get_size (caps); i++) {
+    GstCapsFeatures *const features = gst_caps_get_features (caps, i);
+    /* Skip ANY features, we need an exact match for correct evaluation */
+    if (gst_caps_features_is_any (features))
+      continue;
+    if (gst_caps_features_contains (features, feature))
+      return TRUE;
+  }
+
+  return FALSE;
+}
+
+static gboolean
+srcpad_can_dmabuf (GstSpacemitDec * thiz)
+{
+  gboolean ret = FALSE;
+  GstCaps *caps, *out_caps;
+  GstPad *srcpad;
+
+  srcpad = GST_VIDEO_DECODER_SRC_PAD (thiz);
+  caps = gst_pad_get_pad_template_caps (srcpad);
+
+  out_caps = gst_pad_peer_query_caps (srcpad, caps);
+  if (!out_caps)
+    goto done;
+
+  if (gst_caps_is_any (out_caps) || gst_caps_is_empty (out_caps)
+      || out_caps == caps)
+    goto done;
+
+  GST_DEBUG_OBJECT (thiz, "get src peer caps caps %" GST_PTR_FORMAT, out_caps);
+  if (_gst_caps_has_feature (out_caps, GST_CAPS_FEATURE_MEMORY_DMABUF))
+    ret = TRUE;
+
+done:
+  if (caps)
+    gst_caps_unref (caps);
+  if (out_caps)
+    gst_caps_unref (out_caps);
+  return ret;
+}
+
+static gboolean gst_spacemitdec_close(GstVideoDecoder * decoder)
+{
+  GstSpacemitDec *thiz = GST_SPACEMITDEC(decoder);
+
+  if (thiz->input_state)
+  {
+    gst_video_codec_state_unref (thiz->input_state);
+    thiz->input_state = NULL;
+  }
+  GST_DEBUG_OBJECT (decoder, "ZRong --------------- spacemitdec start close");
+  if (thiz->pool) {
+    gst_buffer_pool_set_active (thiz->pool, FALSE);
+//    gst_spacemit_allocator_wait_inactive (GST_SPACEMIT_BUFFER_POOL_CAST(spacemitdec->pool)->allocator);
+    gst_object_unref (thiz->pool);
+    thiz->pool = NULL;
+  }
+  GST_DEBUG_OBJECT (decoder, "ZRong --------------- spacemitdec start close222");
+
+//  FRAME_Destory(spacemitdec->mppframe);
+  PACKET_Destory (thiz->mpppacket);
+  VDEC_DestoryChannel (thiz->ctx);  
+
+  GST_DEBUG_OBJECT (decoder, "ZRong --------------- spacemitdec finish close");
+
+	return TRUE;
+}
+
+
+static void gst_spacemitdec_class_init(GstSpacemitDecClass * klass)
+{
+  GstVideoDecoderClass *video_decoder_class = GST_VIDEO_DECODER_CLASS (klass);
+  GstElementClass *element_class = GST_ELEMENT_CLASS (klass);
+  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
+
+  gst_element_class_add_static_pad_template(GST_ELEMENT_CLASS (klass), &gst_spacemitdec_sink_template);
+  gst_element_class_add_static_pad_template(GST_ELEMENT_CLASS (klass), &gst_spacemitdec_src_template);
+
+  gst_element_class_set_static_metadata(GST_ELEMENT_CLASS (klass),
+    "Spacemit video decoder", "Decoder/Video", "Spacemit video decoder",
+    "ZRong, zhirong.li@spacemit.com");
+
+  gobject_class->set_property = gst_spacemitdec_set_property;
+  gobject_class->get_property = gst_spacemitdec_get_property;
+  gobject_class->finalize = gst_spacemitdec_finalize;
+
+  video_decoder_class->close = GST_DEBUG_FUNCPTR(gst_spacemitdec_close);
+  video_decoder_class->start = GST_DEBUG_FUNCPTR(gst_spacemitdec_start);
+  video_decoder_class->stop = GST_DEBUG_FUNCPTR(gst_spacemitdec_stop);
+  video_decoder_class->set_format = GST_DEBUG_FUNCPTR(gst_spacemitdec_set_format);
+//  video_decoder_class->reset = GST_DEBUG_FUNCPTR(gst_spacemitdec_reset);
+  video_decoder_class->flush = GST_DEBUG_FUNCPTR (gst_spacemitdec_flush);
+  video_decoder_class->finish = GST_DEBUG_FUNCPTR(gst_spacemitdec_finish);
+  video_decoder_class->handle_frame = GST_DEBUG_FUNCPTR(gst_spacemitdec_handle_frame);
+  video_decoder_class->decide_allocation = GST_DEBUG_FUNCPTR(gst_spacemitdec_decide_allocation);
+
+//  element_class->change_state = GST_DEBUG_FUNCPTR (gst_spacemitdec_dec_change_state);
+
+  /* define properties */
+  g_object_class_install_property (gobject_class, PROP_CODE_TYPE,
+      g_param_spec_uint ("code-type", "code type",
+          "Codec selection to work",
+          CODEC_OPENH264, 1023, CODEC_SFOMX,
+          (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
+  g_object_class_install_property (gobject_class, PROP_DOWNSCALE,
+      g_param_spec_uint ("downscale", "downscale",
+          "downscale in 4k",
+          1, 3, 1,
+          (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
+  g_object_class_install_property (gobject_class, PROP_CODE_YUV_FORMAT,
+      g_param_spec_uint ("code-yuv-format", "code yuv format",
+          "Decode the generated yuv format",
+          PIXEL_FORMAT_UNKNOWN, PIXEL_FORMAT_MAX - 1, PIXEL_FORMAT_I420,
+          (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
+  g_object_class_install_property (gobject_class, PROP_CLOSE_DMABUF,
+      g_param_spec_boolean ("close-dmabuf", "close dmabuf",
+          "Close Dmabuf feature", FALSE,
+          (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
+
+  g_object_class_install_property (gobject_class, PROP_SAVE_DEC_IMAGE,
+      g_param_spec_boolean ("save-dec-images", "save dec images",
+          "save dec image to /tmp/", FALSE,
+          (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
+}
+
+static void gst_spacemitdec_init (GstSpacemitDec * thiz)
+{
+  GstVideoDecoder *decoder = GST_VIDEO_DECODER (thiz);
+
+  thiz->pool = NULL;
+  thiz->ctx = NULL;
+  thiz->width = 1280;
+  thiz->height = 720;
+  thiz->eCodecType = CODEC_V4L2_LINLONV5V7;
+  thiz->eCodingType = CODING_H264;
+  thiz->downscale = 1;
+  thiz->use_dmabuf = TRUE;
+  thiz->eOutputPixelFormat = PIXEL_FORMAT_NV12;
+  thiz->dec_nonblock = TRUE;
+  thiz->req_nonblock = TRUE;
+  thiz->wait_reschange = FALSE;
+  thiz->save_dec = FALSE;
+
+  gst_video_decoder_set_packetized (decoder, TRUE);
+  gst_video_decoder_set_needs_format (decoder, TRUE);
+}
+void
+gst_spacemitdec_set_property (GObject * object, guint property_id,
+    const GValue * value, GParamSpec * pspec)
+{
+  GstSpacemitDec *thiz = GST_SPACEMITDEC (object);
+
+  GST_DEBUG_OBJECT (thiz, "ZRong ------------------- set_property: %d", property_id);
+
+  switch (property_id) {
+    case PROP_CODE_TYPE:
+      thiz->eCodecType = g_value_get_uint (value);
+      break;
+    case PROP_CODE_YUV_FORMAT:
+      thiz->eOutputPixelFormat = g_value_get_uint (value);
+      break;
+    case PROP_CLOSE_DMABUF:
+      thiz->use_dmabuf = FALSE;
+      break;
+    case PROP_SAVE_DEC_IMAGE:
+      thiz->save_dec = g_value_get_boolean (value);
+      break;
+    case PROP_DOWNSCALE:
+      thiz->downscale = g_value_get_uint (value);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+      break;
+  }
+}
+
+void
+gst_spacemitdec_get_property (GObject * object, guint property_id,
+    GValue * value, GParamSpec * pspec)
+{
+  GstSpacemitDec *thiz = GST_SPACEMITDEC (object);
+
+  GST_DEBUG_OBJECT (thiz, "ZRong ------------------- get_property: %d", property_id);
+
+  switch (property_id) {
+    case PROP_CODE_TYPE:
+      g_value_set_uint (value, thiz->eCodecType);
+      break;
+    case PROP_CODE_YUV_FORMAT:
+      g_value_set_uint (value, thiz->eOutputPixelFormat);
+      break;
+    case PROP_CLOSE_DMABUF:
+      g_value_set_boolean (value, thiz->use_dmabuf);
+      break;
+    case PROP_SAVE_DEC_IMAGE:
+      g_value_set_boolean (value, thiz->save_dec);
+      break;
+    case PROP_DOWNSCALE:
+      g_value_set_uint (value, thiz->downscale);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+      break;
+  }
+}
+
+void
+gst_spacemitdec_finalize (GObject * object)
+{
+  GstSpacemitDec *thiz = GST_SPACEMITDEC (object);
+
+  GST_DEBUG_OBJECT (thiz, "finalize");
+
+  /* clean up object here */
+  if (thiz->input_state)
+    gst_video_codec_state_unref (thiz->input_state);
+  thiz->input_state = NULL;
+
+  G_OBJECT_CLASS (gst_spacemitdec_parent_class)->finalize (object);
+}
+
+static gboolean gst_spacemitdec_start (GstVideoDecoder * decoder)
+{
+	GstSpacemitDec *thiz = GST_SPACEMITDEC (decoder);
+  int ret = 0;
+
+  GST_DEBUG_OBJECT (thiz, "in start !");
+
+	if (thiz->ctx)
+	{
+		VDEC_DestoryChannel (thiz->ctx);
+		thiz->ctx = NULL;
+	}
+	thiz->ctx = VDEC_CreateChannel ();
+  thiz->ctx->eCodecType = thiz->eCodecType;
+
+	thiz->mpppacket = PACKET_Create ();
+	if (!thiz->mpppacket) {
+    GST_ERROR_OBJECT (thiz, "can not alloc for mpp structure, please check !");
+    return FALSE;
+  }
+
+  thiz->mppframe = NULL;
+  thiz->at_eos = FALSE;
+  thiz->downstream_flow_ret = GST_FLOW_OK;
+  thiz->cur_frame_number = -1;
+  thiz->initialized = FALSE;
+  if (thiz->save_dec)
+    thiz->fb = fopen("/tmp/spacemitdec_out.yuv", "wb+");
+  
+  GST_DEBUG_OBJECT (thiz, "finish start ! (%d)", thiz->save_dec);
+
+	return TRUE;
+}
+
+static gboolean gst_spacemitdec_stop(GstVideoDecoder * decoder)
+{
+	GstSpacemitDec *thiz = GST_SPACEMITDEC(decoder);
+  if (thiz->save_dec)
+    fclose(thiz->fb);
+
+    if (!(gst_pad_get_task_state ((decoder)->srcpad) == GST_TASK_STARTED)) {
+    GST_DEBUG_OBJECT (thiz, "ZRong --------------- spacemitdec finish stop");
+    return TRUE;
+  }
+
+  gst_pad_stop_task (decoder->srcpad);
+  GST_DEBUG_OBJECT (thiz, "ZRong --------------- spacemitdec finish stop222");
+
+	return TRUE;
+}
+static MppCodingType
+gst_change_mpp_ecoding_type (GstStructure * s)
+{
+  if (gst_structure_has_name (s, "video/x-h264"))
+    return CODING_H264;
+
+  if (gst_structure_has_name (s, "video/x-h265"))
+    return CODING_H265;
+
+  if (gst_structure_has_name (s, "image/jpeg"))
+    return CODING_MJPEG;
+
+  if (gst_structure_has_name (s, "video/x-vp8"))
+    return CODING_VP8;
+
+  if (gst_structure_has_name (s, "video/x-vp9"))
+    return CODING_VP9;
+
+  return CODING_UNKNOWN;
+}
+static gboolean
+gst_spacemitdec_init_decoder (GstSpacemitDec * thiz)
+{
+  GstStructure *structure;
+  gboolean ret = TRUE;
+
+  if (thiz->initialized)
+    return TRUE;
+
+  structure = gst_caps_get_structure (thiz->input_state->caps, 0);
+  thiz->eCodingType = gst_change_mpp_ecoding_type (structure);
+  if(thiz->eCodingType == CODING_UNKNOWN) {
+    GST_ERROR_OBJECT(thiz, "no support this eCodingType");
+    return FALSE;
+  }
+
+  if (thiz->ctx->eCodecType == CODEC_SFOMX ||
+      thiz->ctx->eCodecType == CODEC_OPENH264 ||
+      thiz->ctx->eCodecType == CODEC_FAKEDEC ||
+      thiz->ctx->eCodecType == CODEC_V4L2_LINLONV5V7) {
+    thiz->width = thiz->input_state->info.width;
+    thiz->height = thiz->input_state->info.height;
+    thiz->ctx->stVdecPara.eCodingType = thiz->eCodingType;
+    thiz->ctx->stVdecPara.nWidth = thiz->width;
+    thiz->ctx->stVdecPara.nHeight = thiz->height;
+    thiz->ctx->stVdecPara.eOutputPixelFormat = thiz->eOutputPixelFormat;
+    thiz->ctx->eCodecType = thiz->eCodecType; //set property
+    thiz->ctx->stVdecPara.nScale = thiz->downscale;
+    thiz->ctx->stVdecPara.nHorizonScaleDownRatio = 1;
+    thiz->ctx->stVdecPara.nVerticalScaleDownRatio = 1;
+    thiz->ctx->stVdecPara.nRotateDegree = 0;
+    thiz->ctx->stVdecPara.bThumbnailMode = 0;
+    thiz->ctx->stVdecPara.bIsInterlaced = MPP_FALSE;
+
+    thiz->ctx->stVdecPara.bInputBlockModeEnable = MPP_TRUE;
+    thiz->ctx->stVdecPara.bOutputBlockModeEnable = MPP_TRUE;
+    GST_DEBUG_OBJECT (thiz, "spacemitdec set eCodecType is %d, downscale:%u", thiz->ctx->eCodecType, thiz->downscale);
+
+    ret = VDEC_Init (thiz->ctx);
+    if (ret) {
+      GST_ERROR_OBJECT (thiz, "mpp VDEC_Init error, please check !");
+      return FALSE;
+    }
+
+    if (thiz->eCodecType == CODEC_V4L2_LINLONV5V7)
+      thiz->wait_reschange = TRUE;
+  } else {
+    GST_ERROR_OBJECT (thiz, "no supprot this eCodecType: %d", thiz->ctx->eCodecType);
+    return FALSE;
+  }
+
+  thiz->initialized = TRUE;
+  return TRUE;
+}
+
+static gboolean gst_spacemitdec_set_format(GstVideoDecoder * decoder, GstVideoCodecState * state)
+{
+	GstSpacemitDec *thiz = GST_SPACEMITDEC(decoder);
+  GstStructure *structure;
+  gboolean ret = TRUE;
+
+	GST_DEBUG_OBJECT(thiz, "input caps: %" GST_PTR_FORMAT, state->caps);
+
+	if(thiz->input_state)
+	{
+		gst_video_codec_state_unref(thiz->input_state);
+		thiz->input_state = NULL;
+	}
+
+	thiz->input_state = gst_video_codec_state_ref (state);
+  if (!gst_spacemitdec_init_decoder(thiz))
+    return FALSE;
+
+	GST_DEBUG_OBJECT (thiz, "@@@ ZRong ------------------------- set_format (%d, %d, %d), (%d, %d, %d)",
+    thiz->input_state->info.width, thiz->input_state->info.height, thiz->input_state->info.size,
+    state->info.width, state->info.height, state->info.size);
+  GST_DEBUG_OBJECT (thiz, "ZRong ----------------------- set format finish, %u, %s",
+    GST_VIDEO_INFO_FORMAT (&state->info), gst_video_format_to_string (GST_VIDEO_INFO_FORMAT (&state->info)));
+
+	return TRUE;
+}
+
+static gboolean gst_spacemitdec_reset(GstVideoDecoder * decoder, gboolean hard)
+{
+	GstSpacemitDec *thiz = GST_SPACEMITDEC(decoder);
+
+	GST_ERROR_OBJECT (thiz, "ZRong ------------------------- finish reset!");
+
+	return TRUE;
+}
+static gboolean
+gst_spacemitdec_flush (GstVideoDecoder * decoder)
+{
+	GstSpacemitDec *thiz = GST_SPACEMITDEC(decoder);
+
+  GST_DEBUG_OBJECT (thiz, "ZRong -------------------- flushing start, (%d)", thiz->downstream_flow_ret);
+
+  thiz->flushing = TRUE;
+
+  if (thiz->downstream_flow_ret == GST_FLOW_EOS) {
+    gst_spacemit_allocator_wait_inactive (GST_SPACEMIT_BUFFER_POOL_CAST(thiz->pool)->allocator);
+
+    if (thiz->eCodecType != CODEC_V4L2_LINLONV5V7)
+      VDEC_Flush(thiz->ctx);
+    else
+      VDEC_ResetChannel(thiz->ctx);
+  }
+
+  GST_VIDEO_DECODER_STREAM_UNLOCK (decoder);
+
+  /* Wait for task thread to pause */
+  GstTask *task = decoder->srcpad->task;
+  if (task) {
+    //GST_OBJECT_LOCK (task);
+    while (GST_TASK_STATE (task) == GST_TASK_STARTED) {
+      GST_DEBUG_OBJECT(thiz, "finish FLUSH test4");
+      g_usleep(400 * 1000);
+      //GST_TASK_WAIT (task);
+    }
+    GST_DEBUG_OBJECT(thiz, "finish FLUSH test5");
+    //GST_OBJECT_UNLOCK (task);
+    gst_pad_stop_task (decoder->srcpad);
+  }
+  GST_VIDEO_DECODER_STREAM_LOCK (decoder);
+
+  thiz->flushing = FALSE;
+  thiz->downstream_flow_ret = GST_FLOW_OK;
+  
+  GST_DEBUG_OBJECT (thiz, "ZRong -------------------- flushing stop");
+
+	return TRUE;
+}
+
+static int mpp_format_change_to_gst(MppPixelFormat eOutputPixelFormat)
+{
+  GstVideoFormat format;
+
+  switch(eOutputPixelFormat){
+    case PIXEL_FORMAT_I420:
+      format = GST_VIDEO_FORMAT_I420;
+      break;
+    case PIXEL_FORMAT_NV21:
+      format = GST_VIDEO_FORMAT_NV21;
+      break;
+    case PIXEL_FORMAT_NV12:
+      format = GST_VIDEO_FORMAT_NV12;
+      break;
+    default:
+      format = GST_VIDEO_FORMAT_UNKNOWN;
+      break;
+  }
+  return format;
+}
+
+static GstFlowReturn
+save_decoder_images_for_test (GstVideoDecoder * decoder, GstBuffer *outbuf)
+{
+  GstSpacemitDec *thiz = GST_SPACEMITDEC (decoder);
+
+  GstVideoCodecState *state;
+  GstVideoFrame video_frame;
+  gint dst_width[GST_VIDEO_MAX_PLANES] = { 0, };
+  gint dst_height[GST_VIDEO_MAX_PLANES] = { 0, };
+  guint p, h;
+  const guint8 *data;
+  guint8 *dst;
+  GstVideoFormat format;
+  GstVideoInfo *vinfo = NULL;
+
+  state = gst_video_decoder_get_output_state (decoder);
+  if (state == NULL) {
+    GST_ERROR_OBJECT (thiz, "err! get output state fail!");
+    return GST_FLOW_ERROR;
+  }
+
+  if (!gst_video_frame_map (&video_frame, &state->info, outbuf,
+          GST_MAP_WRITE)) {
+    GST_ERROR_OBJECT (thiz, "Cannot map output buffer!");
+    gst_video_codec_state_unref (state);
+    return GST_FLOW_ERROR;
+  }
+
+  format = mpp_format_change_to_gst(thiz->eOutputPixelFormat);
+
+  vinfo = &state->info;
+  dst_height[0] = GST_VIDEO_INFO_FIELD_HEIGHT (vinfo);
+
+  switch (format) {
+    case GST_VIDEO_FORMAT_I420:
+      dst_width[0] = GST_VIDEO_INFO_WIDTH (vinfo);
+      dst_width[1] = GST_VIDEO_INFO_WIDTH (vinfo) / 2;
+      dst_height[1] = GST_VIDEO_INFO_FIELD_HEIGHT (vinfo) / 2;
+      dst_width[2] = GST_VIDEO_INFO_WIDTH (vinfo) / 2;
+      dst_height[2] = GST_VIDEO_INFO_FIELD_HEIGHT (vinfo) / 2;
+      GST_DEBUG_OBJECT (thiz, "I420 format, size: %d, %d, %d, vinfo stride: %d, %d, %d, planes:%d",
+        dst_width[0], dst_width[1], dst_width[2],
+        GST_VIDEO_INFO_PLANE_STRIDE (vinfo, 0), GST_VIDEO_INFO_PLANE_STRIDE (vinfo, 1), GST_VIDEO_INFO_PLANE_STRIDE (vinfo, 2),
+        GST_VIDEO_INFO_N_PLANES (vinfo));
+      break;
+    case GST_VIDEO_FORMAT_NV12:
+    case GST_VIDEO_FORMAT_NV21:
+      dst_width[0] = GST_VIDEO_INFO_WIDTH (vinfo);
+      dst_width[1] = GST_VIDEO_INFO_WIDTH (vinfo);
+      dst_height[1] = GST_VIDEO_INFO_FIELD_HEIGHT (vinfo) / 2;
+      GST_DEBUG_OBJECT (thiz, "NV12/NV21 format, size:%d, %d", dst_width[0], dst_width[1]);
+      break;
+    default:
+      g_assert_not_reached ();
+      break;
+  }
+
+  for (p = 0; p < GST_VIDEO_INFO_N_PLANES (vinfo); p++) {
+    data = (U8*)FRAME_GetDataPointer(thiz->mppframe, p);
+//      dst = GST_VIDEO_FRAME_PLANE_DATA (&video_frame, p);
+
+    for (h = 0; h < dst_height[p]; h++) {
+      fwrite(data, 1, dst_width[p], thiz->fb);
+//        memcpy (dst, data, dst_width[p]);
+//        dst += GST_VIDEO_INFO_PLANE_STRIDE (vinfo, p);
+      data += dst_width[p];
+    }
+  }
+
+  gst_video_codec_state_unref (state);
+  gst_video_frame_unmap (&video_frame);
+
+  return GST_FLOW_OK;
+}
+
+static GstFlowReturn
+gst_spacemitdec_fill_output_buffer (GstVideoDecoder * decoder,
+    GstBuffer ** output_buffer)
+{
+  GstSpacemitDec *thiz = GST_SPACEMITDEC (decoder);
+  GstFlowReturn flow_status = GST_FLOW_OK;
+  GstBuffer *outbuf;
+  GstBufferPoolAcquireParams params = { 0, };
+  GstMemory *mem;
+  gint32 id = -1;
+  gint32 fd = -1;
+
+  id = FRAME_GetID(thiz->mppframe);
+  if (thiz->use_dmabuf) {
+    fd = FRAME_GetFD(thiz->mppframe, 0);
+    gst_spacemit_allocator_get_info (GST_SPACEMIT_BUFFER_POOL_CAST(thiz->pool)->allocator, id, fd);
+  } else {
+    gst_spacemit_allocator_get_info (GST_SPACEMIT_BUFFER_POOL_CAST(thiz->pool)->allocator, id, -1);
+  }
+  GST_DEBUG_OBJECT (thiz, "get mppframe id:%d fd:%d", id, fd);
+
+  flow_status = gst_buffer_pool_acquire_buffer (thiz->pool, &outbuf, &params);
+  if (flow_status != GST_FLOW_OK) {
+    GST_ERROR_OBJECT (thiz,
+        "can not acquire output buffer from pool: %" GST_PTR_FORMAT, thiz->pool);
+     goto done;
+  }
+
+  mem = gst_buffer_peek_memory (outbuf, 0);
+  gst_spacemit_set_mem (mem, thiz->mppframe, thiz->ctx);
+  *output_buffer = outbuf;
+  GST_DEBUG_OBJECT (thiz, "finish buffer %p fill, mem:%p", outbuf, mem);
+
+  if (thiz->save_dec)
+    flow_status = save_decoder_images_for_test (decoder, outbuf);
+
+done:
+  thiz->mppframe = NULL;
+  return flow_status;
+}
+
+static gint32 gst_spacemitdec_request_frame (GstSpacemitDec *thiz)
+{
+  MppFrame *mppframe = NULL;
+  gint32 ret;
+  static guint count = 0;
+
+  mppframe = FRAME_Create();
+  if (!mppframe) {
+    GST_ERROR_OBJECT (thiz, "can not alloc for mpp structure, please check!");
+    return FALSE;
+  }
+
+  do {
+    ret = VDEC_RequestOutputFrame (thiz->ctx, FRAME_GetBaseData(mppframe));
+    if (ret != MPP_CODER_NO_DATA) {
+      break;
+    } else {
+      if (count >= 2 && count < MAX_POLL_TIME) {
+        g_usleep(500);
+      } else if (count >= MAX_POLL_TIME) {
+        GST_ERROR_OBJECT (thiz, "try max times: %u, fail return(%d)", MAX_POLL_TIME, ret);
+        ret = MPP_POLL_FAILED;
+        break;
+      }
+    }
+    count++;
+  } while (thiz->req_nonblock);
+
+  count = 0;
+  thiz->mppframe = mppframe;
+
+  return ret;
+}
+
+static void
+gst_spacemitdec_loop (GstVideoDecoder * decoder)
+{
+  GstSpacemitDec *thiz = GST_SPACEMITDEC (decoder);
+  GstVideoCodecFrame * frame;
+  GstFlowReturn flow_status;
+  GstBuffer *outbuf = NULL;
+  int ret;
+
+  if (G_UNLIKELY(thiz->flushing))
+    goto flushing;
+
+  ret = gst_spacemitdec_request_frame (thiz);
+  if (ret == MPP_CODER_EOS) {
+    goto finish_work;
+  } else if (ret == MPP_POLL_FAILED) {
+    thiz->downstream_flow_ret = GST_FLOW_ERROR;
+    FRAME_Destory(thiz->mppframe);
+    goto done;
+  } else if (ret == MPP_RESOLUTION_CHANGED) {
+    if (thiz->width != thiz->ctx->stVdecPara.nWidth &&
+        thiz->height != thiz->ctx->stVdecPara.nHeight) {
+      GST_DEBUG_OBJECT (thiz, "resolution change from (%u, %u) to (%u, %u), need renegotiate",
+        thiz->width, thiz->height,
+        thiz->ctx->stVdecPara.nWidth, thiz->ctx->stVdecPara.nHeight);
+    } else {
+      GST_DEBUG_OBJECT (thiz, "resolution change from (%u, %u) to (%u, %u), size is same",
+        thiz->width, thiz->height,
+        thiz->ctx->stVdecPara.nWidth, thiz->ctx->stVdecPara.nHeight);
+      thiz->wait_reschange = FALSE;
+      FRAME_Destory(thiz->mppframe);
+      goto no_frame;
+    }
+  }
+
+  if (thiz->wait_reschange) {
+    VDEC_ReturnOutputFrame(thiz->ctx, FRAME_GetBaseData(thiz->mppframe));
+    FRAME_Destory(thiz->mppframe);
+    goto no_frame;
+  }
+
+  GST_DEBUG_OBJECT (thiz, "@@@ ZRong 555, %d", ret);
+
+  frame = gst_video_decoder_get_oldest_frame (decoder);
+  if (frame == NULL) {
+    GST_DEBUG_OBJECT (thiz, "@@@ ZRong 333, null");
+    flow_status = gst_spacemitdec_fill_output_buffer (decoder, &outbuf);
+    if (flow_status != GST_FLOW_OK)
+      goto fill_buffer_err;
+
+    GST_DEBUG_OBJECT (thiz, "zrong ----- push buf %p of size %" G_GSIZE_FORMAT ", "
+        "PTS %" GST_TIME_FORMAT ", dur %" GST_TIME_FORMAT, outbuf,
+        gst_buffer_get_size (outbuf),
+        GST_TIME_ARGS (GST_BUFFER_PTS (outbuf)),
+        GST_TIME_ARGS (GST_BUFFER_DURATION (outbuf)));
+    flow_status = gst_pad_push (GST_VIDEO_DECODER_SRC_PAD (decoder), outbuf);
+
+  } else {
+    GST_DEBUG_OBJECT (thiz, "get oldest frame %p, snd:%u, input buffer pts: %"  GST_TIME_FORMAT ", dts %" GST_TIME_FORMAT ", mppframe pts %" GST_TIME_FORMAT,
+        frame, frame->system_frame_number, GST_TIME_ARGS (GST_BUFFER_PTS (frame->input_buffer)),
+        GST_TIME_ARGS (GST_BUFFER_DTS (frame->input_buffer)), GST_TIME_ARGS (FRAME_GetPts(thiz->mppframe)));
+
+    //frame->pts = FRAME_GetPts(thiz->mppframe);
+    frame->pts = GST_CLOCK_TIME_NONE;
+    frame->dts = FRAME_GetPts(thiz->mppframe);
+    flow_status = gst_spacemitdec_fill_output_buffer (decoder, &frame->output_buffer);
+    if (flow_status != GST_FLOW_OK)
+      goto fill_buffer_err;
+
+    const gchar *user_clk_choice;
+
+    user_clk_choice = g_getenv ("GST_CLK_CHOICE");
+    if (user_clk_choice && g_strstr_len (user_clk_choice, 1, "Y")) {
+      frame->pts = GST_CLOCK_TIME_NONE;
+      frame->dts = GST_CLOCK_TIME_NONE;
+    }
+
+    GST_BUFFER_PTS (frame->output_buffer) = frame->pts;
+    GST_BUFFER_DTS (frame->output_buffer) = frame->dts;
+
+    GST_DEBUG_OBJECT (thiz, "finish frame %p, snd:%u, output buffer pts: %"  GST_TIME_FORMAT ", dts %" GST_TIME_FORMAT ", frame pts: %"  GST_TIME_FORMAT ", dts %" GST_TIME_FORMAT,
+        frame, frame->system_frame_number, GST_TIME_ARGS (GST_BUFFER_PTS (frame->output_buffer)),
+        GST_TIME_ARGS (GST_BUFFER_DTS (frame->output_buffer)), GST_TIME_ARGS (frame->pts),
+        GST_TIME_ARGS (frame->dts));
+    flow_status = gst_video_decoder_finish_frame(decoder, frame);
+  }
+
+  if (flow_status != GST_FLOW_OK)
+    goto sending_state;
+
+  thiz->downstream_flow_ret = flow_status;
+  
+done:
+  if (thiz->downstream_flow_ret != GST_FLOW_OK) {
+    GST_INFO_OBJECT (thiz,
+        "pause task in dec loop (%d)!", thiz->downstream_flow_ret);
+
+    gst_pad_pause_task (GST_VIDEO_DECODER_SRC_PAD (thiz));
+  }
+	return;
+
+flushing:
+{
+  thiz->downstream_flow_ret = GST_FLOW_FLUSHING;
+
+  while (1) {
+    frame = gst_video_decoder_get_oldest_frame (decoder);
+    if(frame == NULL)
+      break;
+    gst_video_decoder_release_frame (decoder, frame);
+  }
+  GST_INFO_OBJECT (thiz, "flushing spacemit decoder");
+
+  goto done;
+}
+
+no_frame:
+{
+  thiz->downstream_flow_ret = GST_FLOW_OK;
+  goto done;
+}
+
+fill_buffer_err:
+{
+  GST_ERROR_OBJECT (thiz,
+      "fill buffer err in dec loop, flow status: %d!", flow_status);
+  thiz->downstream_flow_ret = flow_status;
+  gst_video_codec_frame_unref (frame);
+  goto done;
+}
+
+finish_work:
+{
+  GST_DEBUG_OBJECT (thiz,
+      "get eos, finished work and paused task!");
+  thiz->downstream_flow_ret = GST_FLOW_EOS;
+  VDEC_ReturnOutputFrame(thiz->ctx, FRAME_GetBaseData(thiz->mppframe));
+  FRAME_Destory(thiz->mppframe);
+
+  goto done;
+
+}
+
+sending_state:
+{
+  thiz->downstream_flow_ret = flow_status;
+  if (flow_status == GST_FLOW_EOS) {
+    GST_DEBUG_OBJECT (thiz,
+        "get eos, finished work!");
+  } else if (flow_status == GST_FLOW_ERROR) {
+    GST_ERROR_OBJECT (thiz,
+        "send error and paused task!");
+  } else if (flow_status == GST_FLOW_FLUSHING) {
+    thiz->flushing = TRUE;
+    GST_DEBUG_OBJECT (thiz,
+        "get GST_FLOW_FLUSHING from finish frame!");
+
+    goto flushing;
+  } else {
+    GST_ERROR_OBJECT (thiz,
+        "get an unsupport flow status return after finish frame!");
+  }
+  goto done;
+}
+
+}
+static gboolean
+gst_spacemitdec_pool_set_active(GstVideoDecoder * decoder)
+{
+  GstSpacemitDec *thiz = GST_SPACEMITDEC (decoder);
+  GstVideoCodecState *state;
+  GstBufferPool *pool;
+  guint size, min, max, i;
+  GstStructure *config;
+  GstCaps *caps = NULL;
+  GstVideoInfo vinfo;
+
+  GST_ERROR_OBJECT (thiz, "@@@ ZRong ------------------------- start pool_set_active!");
+
+  pool = gst_video_decoder_get_buffer_pool (GST_VIDEO_DECODER (thiz));
+  if (pool) {
+    config = gst_buffer_pool_get_config (pool);
+    if (!gst_buffer_pool_config_get_params (config, &caps, NULL, &min, &max)) {
+      GST_ERROR_OBJECT (thiz, "can't get buffer pool params");
+      gst_structure_free (config);
+      return FALSE;
+    }
+    gst_structure_free (config);
+  }
+
+  if (caps) {
+    thiz->pool = gst_spacemit_buffer_pool_new ();
+    config = gst_buffer_pool_get_config (thiz->pool);
+    gst_buffer_pool_config_add_option (config,
+        GST_BUFFER_POOL_OPTION_VIDEO_META);
+
+    gst_video_info_init (&vinfo);
+    gst_video_info_from_caps (&vinfo, caps);
+    min = MAX (min, 8);
+
+    gst_buffer_pool_config_set_params (config, caps,
+        vinfo.size, min, max);
+    if (!gst_buffer_pool_set_config (thiz->pool, config)) {
+      GST_ERROR_OBJECT (thiz, "failed to set config on spacemit pool");
+      gst_object_unref (thiz->pool);
+      thiz->pool = NULL;
+      return FALSE;
+    }
+    if (!gst_buffer_pool_set_active (thiz->pool, TRUE)) {
+      GST_ERROR_OBJECT (thiz, "failed to activate spacemit pool");
+      gst_object_unref (thiz->pool);
+      thiz->pool = NULL;
+      return FALSE;
+    }
+    GST_DEBUG_OBJECT (thiz,
+        "use spacemit bufferpool: %" GST_PTR_FORMAT, thiz->pool);
+
+    pool = gst_video_decoder_get_buffer_pool (decoder);
+    if(!gst_buffer_pool_set_active (pool, FALSE))
+      GST_ERROR_OBJECT (thiz, "failed to set acitve false on pool %" GST_PTR_FORMAT, pool);
+    gst_object_unref (pool);
+    gst_caps_unref (caps);
+  } else {
+    GST_ERROR_OBJECT (thiz, "can't get pool caps params");
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
+static gboolean
+gst_spacemitdec_set_src_caps (GstSpacemitDec * thiz)
+{
+  GstVideoCodecState *output_state;
+  GstVideoInfo *vinfo;
+  GstVideoFormat format;
+  guint width, height;
+
+  width = thiz->ctx->stVdecPara.nWidth;
+  height = thiz->ctx->stVdecPara.nHeight;
+
+  format = mpp_format_change_to_gst(thiz->eOutputPixelFormat);
+  if (format == GST_VIDEO_FORMAT_UNKNOWN) {
+    GST_ERROR_OBJECT (thiz, "failed to find a valid video format");
+    return FALSE;
+  }
+
+  output_state =
+      gst_video_decoder_set_output_state (GST_VIDEO_DECODER (thiz),
+      format, width, height, thiz->input_state);
+  vinfo = &output_state->info;
+  output_state->caps = gst_video_info_to_caps (vinfo);
+
+  const gchar *user_dmabuf_choice;
+
+  user_dmabuf_choice = g_getenv ("GST_DMABUF_CHOICE");
+  if (user_dmabuf_choice && g_strstr_len (user_dmabuf_choice, 1, "N")) {
+    GST_DEBUG("GST_DMABUF_CHOICE is N, set use_dmabuf = false");
+    thiz->use_dmabuf = FALSE;
+  } else {
+    GST_DEBUG("GST_DMABUF_CHOICE is Y, set use_dmabuf = true");
+    thiz->use_dmabuf = TRUE;
+  }
+
+  if (thiz->use_dmabuf && srcpad_can_dmabuf (thiz)) {
+    gst_caps_set_features (output_state->caps, 0,
+        gst_caps_features_new (GST_CAPS_FEATURE_MEMORY_DMABUF, NULL));
+    GST_INFO_OBJECT (thiz, "set DMABUF feature to spacemitdec src cap %" GST_PTR_FORMAT, output_state->caps);
+  }
+
+  thiz->width = width;
+  thiz->height = height;
+
+  return TRUE;
+}
+
+static gint32 gst_spacemitdec_vdec_decode (GstSpacemitDec * thiz, GstMapInfo *map_info, gint64 pts)
+{
+  gint32 ret;
+  static guint count = 0;
+
+  if (map_info == NULL) {
+    PACKET_SetEos(thiz->mpppacket, TRUE);
+    PACKET_SetLength(thiz->mpppacket, 0);
+  } else {
+    PACKET_SetDataPointer(thiz->mpppacket, map_info->data);
+    PACKET_SetLength(thiz->mpppacket, map_info->size);
+    PACKET_SetEos(thiz->mpppacket, FALSE);
+    if (pts != GST_CLOCK_TIME_NONE)
+      PACKET_SetPts(thiz->mpppacket, pts);
+  }
+
+  do {
+    ret = VDEC_Decode(thiz->ctx, PACKET_GetBaseData(thiz->mpppacket));
+    if (ret != MPP_POLL_FAILED) {
+      break;
+    } else {
+      if (count >= 2 && count < MAX_POLL_TIME) {
+        g_usleep(500);
+      } else if (count >= MAX_POLL_TIME) {
+        GST_ERROR_OBJECT (thiz, "try max times: %u, fail return(%d)", MAX_POLL_TIME, ret);
+        ret = MPP_POLL_FAILED;
+        break;
+      }
+    }
+    count++;
+  } while (thiz->dec_nonblock);
+
+  count = 0;
+
+  return ret;
+}
+
+static GstFlowReturn
+gst_spacemitdec_handle_frame (GstVideoDecoder * decoder,
+    GstVideoCodecFrame * frame)
+{
+  GstSpacemitDec *thiz = GST_SPACEMITDEC (decoder);
+  GstMapInfo map_info;
+  GstFlowReturn flow_status;
+  guint actual_width, actual_height;
+  GstFlowReturn ret;
+
+  if (G_UNLIKELY (thiz->flushing))
+    goto flushing;
+
+  if (G_UNLIKELY(thiz->downstream_flow_ret != GST_FLOW_OK))
+    goto downstream_err;
+
+  if (G_LIKELY(frame)) {
+    thiz->cur_frame_number = frame->system_frame_number;
+    GST_DEBUG_OBJECT (thiz, "handle frame %p, snb:%u, input buffer pts: %"  GST_TIME_FORMAT ", dts %" GST_TIME_FORMAT,
+        frame, frame->system_frame_number, GST_TIME_ARGS (GST_BUFFER_PTS (frame->input_buffer)),
+        GST_TIME_ARGS (GST_BUFFER_DTS (frame->input_buffer)));
+
+    GST_VIDEO_DECODER_STREAM_UNLOCK (decoder);
+    if (!gst_buffer_map (frame->input_buffer, &map_info, GST_MAP_READ))
+      goto map_err;
+
+    ret = gst_spacemitdec_vdec_decode (thiz, &map_info, GST_BUFFER_DTS (frame->input_buffer));
+
+    gst_buffer_unmap (frame->input_buffer, &map_info);
+
+    GST_VIDEO_DECODER_STREAM_LOCK (decoder);
+
+    if (ret) {
+      GST_ERROR_OBJECT (thiz, "VDEC_Decode return error! (%d)", ret);
+      ret = gst_video_decoder_drop_frame (decoder, frame);
+      goto out;
+    }
+    gst_video_codec_frame_unref (frame);
+   } else {
+    GST_VIDEO_DECODER_STREAM_UNLOCK (decoder);
+    ret = gst_spacemitdec_vdec_decode (thiz, NULL, GST_CLOCK_TIME_NONE);
+    GST_DEBUG_OBJECT (thiz, "@@@ ZRong ------------------------- in handle else, %d!", ret);
+    thiz->cur_frame_number = -1;
+    ret = GST_FLOW_EOS;
+    GST_VIDEO_DECODER_STREAM_LOCK (decoder);
+
+    goto out;
+  }
+  actual_width = thiz->ctx->stVdecPara.nWidth;
+  actual_height = thiz->ctx->stVdecPara.nHeight;
+
+  if (!gst_pad_has_current_caps (GST_VIDEO_DECODER_SRC_PAD (thiz))
+      || actual_width != thiz->width
+      || actual_height != thiz->height) {
+
+    if (!gst_spacemitdec_set_src_caps (thiz))
+      goto not_negotiated_err;
+
+    GST_DEBUG_OBJECT (thiz, "@@@ ZRong ------------------------- bf negotiate, %d, %d, %d",
+      actual_width, actual_height, thiz->eOutputPixelFormat);
+
+    if (!gst_video_decoder_negotiate (decoder))
+      goto not_negotiated_err;
+
+    if (!gst_buffer_pool_set_active (thiz->pool, TRUE))
+      goto acitve_fail;
+  }
+
+  if (G_UNLIKELY (!gst_pad_get_task_state ((decoder)->srcpad) == GST_TASK_STARTED)) {
+    GST_DEBUG_OBJECT (thiz, "@@@ ZRong --------------------- start dec thread");
+    gst_pad_start_task (decoder->srcpad,
+        (GstTaskFunction) gst_spacemitdec_loop, decoder, NULL);
+  }
+
+  GST_DEBUG_OBJECT (thiz, "@@@ ZRong ------------------------ finish handle, %d", thiz->downstream_flow_ret);
+  ret = thiz->downstream_flow_ret;
+
+out:
+  if (thiz->downstream_flow_ret == GST_FLOW_FLUSHING)
+    ret = GST_FLOW_FLUSHING;
+  return ret;
+
+out_clked:
+  GST_VIDEO_DECODER_STREAM_LOCK (decoder);
+  return ret;
+
+not_negotiated_err:
+{
+  GST_ERROR_OBJECT (thiz,
+      "Failed to negotiate with downstream elements");
+  ret = GST_FLOW_NOT_NEGOTIATED;
+  goto out;
+}
+
+acitve_fail:
+{
+  GST_ERROR_OBJECT (thiz, "acitve spacemit pool fail!");
+  gst_object_unref (thiz->pool);
+  ret = GST_FLOW_ERROR;
+  goto out;
+}
+
+map_err:
+{
+  GST_ERROR_OBJECT (thiz, "Cannot map input buffer!");
+  gst_video_codec_frame_unref (frame);
+  ret = GST_FLOW_ERROR;
+  goto out_clked;
+}
+
+downstream_err:
+{
+  GST_ERROR_OBJECT (thiz, "Downstream returned %s",
+      gst_flow_get_name (thiz->downstream_flow_ret));
+  ret = thiz->downstream_flow_ret;
+  goto out;
+}
+flushing:
+{
+  GST_WARNING_OBJECT (thiz, "flushing");
+  ret = GST_FLOW_FLUSHING;
+  gst_video_decoder_release_frame (decoder, frame);
+  goto out;
+}
+}
+
+static GstFlowReturn gst_spacemitdec_finish(GstVideoDecoder * decoder)
+{
+  GstSpacemitDec *thiz = GST_SPACEMITDEC(decoder);
+  GstFlowReturn flow_status;
+
+  GST_DEBUG_OBJECT(thiz, "finish");
+
+  /* Decoder not negotiated yet */
+  if (thiz->width == 0)
+    return GST_FLOW_OK;
+  GST_DEBUG_OBJECT(thiz, "finish test1");
+
+  /* Drain all pending frames */
+  //while ((gst_spacemitdec_handle_frame (decoder, NULL)) == GST_FLOW_OK);
+  flow_status = gst_spacemitdec_handle_frame (decoder, NULL);
+  if (flow_status != GST_FLOW_EOS) {
+      GST_ERROR_OBJECT(thiz, "stream no in eos, after setting null packet! (%d)", flow_status);
+      return GST_FLOW_ERROR;
+  }
+
+  thiz->at_eos = TRUE;
+
+  GST_VIDEO_DECODER_STREAM_UNLOCK (decoder);
+
+  GST_DEBUG_OBJECT(thiz, "finish test222");
+  gst_spacemit_allocator_wait_inactive (GST_SPACEMIT_BUFFER_POOL_CAST(thiz->pool)->allocator);
+
+  /* Wait for task thread to pause */
+  GstTask *task = decoder->srcpad->task;
+  if (task) {
+    //GST_OBJECT_LOCK (task);
+    while (GST_TASK_STATE (task) == GST_TASK_STARTED) {
+      GST_DEBUG_OBJECT(thiz, "finish test4");
+      g_usleep(400 * 1000);
+      //GST_TASK_WAIT (task);
+    }
+    GST_DEBUG_OBJECT(thiz, "finish test5");
+    //GST_OBJECT_UNLOCK (task);
+  }
+  gst_pad_stop_task (decoder->srcpad);
+  GST_VIDEO_DECODER_STREAM_LOCK (decoder);
+
+  GST_DEBUG_OBJECT(thiz, "finish test2");
+
+  return GST_FLOW_OK;
+}
+
+static GstBufferPool *
+gst_spacemitdec_create_buffer_pool (GstSpacemitDec * thiz, GstVideoInfo * info,
+    guint num_buffers)
+{
+  GstBufferPool *pool = NULL;
+  GstAllocator *allocator = NULL;
+  GstStructure *config;
+  GstCaps *caps = NULL;
+  GstVideoAlignment align;
+
+  pool = gst_spacemit_buffer_pool_new ();
+  if (!pool)
+    goto error_no_pool;
+
+  allocator = gst_spacemit_allocator_new ();
+  if (!allocator)
+    goto error_no_allocator;
+
+  gst_spacemit_allocator_configure(allocator, info, thiz->use_dmabuf);
+
+  caps = gst_video_info_to_caps (info);
+
+  config = gst_buffer_pool_get_config (GST_BUFFER_POOL_CAST (pool));
+  gst_buffer_pool_config_set_params (config, caps,
+      GST_VIDEO_INFO_SIZE (info), num_buffers, num_buffers);
+  gst_buffer_pool_config_add_option (config, GST_BUFFER_POOL_OPTION_VIDEO_META);
+  gst_buffer_pool_config_add_option (config,
+      GST_BUFFER_POOL_OPTION_VIDEO_ALIGNMENT);
+  gst_caps_unref (caps);
+
+  if (thiz->use_dmabuf)
+    gst_buffer_pool_config_add_option (config,
+        GST_BUFFER_POOL_OPTION_SPM_USE_DMABUF);
+
+  gst_buffer_pool_config_set_video_alignment (config, &align);
+  gst_buffer_pool_config_set_allocator (config, allocator, NULL);
+  gst_object_unref (allocator);
+
+  if (!gst_buffer_pool_set_config (pool, config))
+    goto error_pool_config;
+
+  return pool;
+
+error_no_pool:
+  {
+    GST_ERROR_OBJECT (thiz, "failed to create spacemitdec bufferpool");
+    return NULL;
+  }
+error_no_allocator:
+  {
+    GST_ERROR_OBJECT (thiz, "failed to create allocator");
+    gst_object_unref (pool);
+    return NULL;
+  }
+error_pool_config:
+  {
+    GST_ERROR_OBJECT (thiz, "failed to set config");
+    gst_object_unref (pool);
+    gst_object_unref (allocator);
+    return NULL;
+  }
+}
+
+static gboolean gst_spacemitdec_decide_allocation(GstVideoDecoder * decoder, GstQuery * query)
+{
+	GstSpacemitDec *thiz = GST_SPACEMITDEC(decoder);
+  GstBufferPool *pool;
+  guint size, min, max, i;
+  GstStructure *pool_config;
+  GstCaps *caps = NULL;
+  GstVideoInfo vinfo;
+  GstVideoCodecState *output_state;
+
+  GST_DEBUG_OBJECT (thiz, "@@@ ZRong ------------------------- in decide_allocation!");
+
+  if (!GST_VIDEO_DECODER_CLASS(gst_spacemitdec_parent_class)->decide_allocation(decoder, query))
+    return FALSE;
+
+  /* Get the buffer pool config decided on by the base class. The base
+     class ensures that there will always be at least a 0th pool in
+     the query. */
+  gst_query_parse_nth_allocation_pool(query, 0, &pool, &size, &min, &max);
+  pool_config = gst_buffer_pool_get_config(pool);
+  gst_buffer_pool_config_get_params (pool_config, &caps, &size,
+      &min, &max);
+
+  GST_DEBUG_OBJECT (thiz, "get pool caps: %" GST_PTR_FORMAT, caps);
+  if (_gst_caps_has_feature (caps, GST_CAPS_FEATURE_MEMORY_DMABUF)) {
+    GST_INFO_OBJECT (thiz, "the spacemit decoder uses DMABuf memory");
+    thiz->use_dmabuf = TRUE;
+  } else {
+    thiz->use_dmabuf = FALSE;
+  }
+
+  /* Decoder always use its own pool. */
+  if (!thiz->pool) {
+    output_state = gst_video_decoder_get_output_state (GST_VIDEO_DECODER (thiz));
+
+    gst_clear_object (&thiz->pool);
+    GST_INFO_OBJECT (thiz, "create new spacemit bufferpool");
+    thiz->pool =
+      gst_spacemitdec_create_buffer_pool(thiz, &output_state->info, (4 > min) ? 4 : min);
+    gst_video_codec_state_unref (output_state);
+    if (!thiz->pool) {
+      GST_ERROR_OBJECT (thiz, "failed to create new pool");
+      goto failed_to_create_pool;
+    }
+  }
+  GST_DEBUG_OBJECT (thiz,
+      "upstream provides the pool is: %" GST_PTR_FORMAT, pool);
+
+  /* If downstream supports video meta and video alignment,
+   * we can replace with our own spacemit bufferpool and use it
+   */
+#if 0
+  if (gst_buffer_pool_has_option (pool,
+          GST_BUFFER_POOL_OPTION_VIDEO_META)) {
+    GstStructure *config;
+    GstAllocator *allocator;
+
+    /* Remove downstream's pool */
+    gst_structure_free (pool_config);
+    gst_object_unref (pool);
+
+    pool = gst_object_ref (spacemitdec->pool);
+    /* Set the allocator of new spacemitdec bufferpool */
+    config = gst_buffer_pool_get_config (GST_BUFFER_POOL_CAST (pool));
+
+    if (gst_buffer_pool_config_get_allocator (config, &allocator, NULL))
+      gst_query_set_nth_allocation_param (query, 0, allocator, NULL);
+    gst_structure_free (config);
+
+    gst_query_set_nth_allocation_pool (query, 0, pool, size, min,
+        max);
+  } else {
+    goto no_support;
+  }
+#endif
+  if (pool)
+    gst_object_unref (pool);
+
+	return TRUE;
+
+failed_to_create_pool:
+  GST_ERROR_OBJECT (thiz, "failed to set buffer pool config");
+  if (pool)
+    gst_object_unref (pool);
+  return FALSE;
+
+no_support:
+  GST_ERROR_OBJECT (thiz,
+      "error! upstream provides the strange pool: %" GST_PTR_FORMAT, pool);
+  if (pool)
+    gst_object_unref (pool);
+  return FALSE;
+}
+
+static GstStateChangeReturn
+gst_spacemitdec_dec_change_state (GstElement * element, GstStateChange transition)
+{
+  GstVideoDecoder *decoder = GST_VIDEO_DECODER (element);
+	GST_DEBUG("ZRong ------------------ in change state, %x", transition);
+
+  if (transition == GST_STATE_CHANGE_PAUSED_TO_READY) {
+    GST_VIDEO_DECODER_STREAM_LOCK (decoder);
+    if (!(gst_pad_get_task_state ((decoder)->srcpad) == GST_TASK_STARTED))
+      return TRUE;
+    
+    GST_DEBUG_OBJECT (decoder, "stopping decoding thread");
+    gst_pad_stop_task (decoder->srcpad);
+    GST_VIDEO_DECODER_STREAM_UNLOCK (decoder);
+  }
+
+  return GST_ELEMENT_CLASS (parent_class)->change_state (element, transition);
+}
+
+gboolean
+gst_spacemitdec_register (GstPlugin * plugin, guint rank)
+{
+  GST_DEBUG_CATEGORY_INIT (gst_spacemitdec_debug_category, "spacemitdec", 0,
+    "debug category for spacemitdec element");
+
+  return gst_element_register (plugin, "spacemitdec", rank,
+      GST_TYPE_SPACEMITDEC);
+}
diff --git a/ext/spacemit/spacemitcodec/gstspacemitdec.h b/ext/spacemit/spacemitcodec/gstspacemitdec.h
new file mode 100755
index 0000000..99cfd31
--- /dev/null
+++ b/ext/spacemit/spacemitcodec/gstspacemitdec.h
@@ -0,0 +1,98 @@
+/* GStreamer
+ * Copyright (C) 2022 FIXME <fixme@example.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _GST_SPACEMITDEC_H_
+#define _GST_SPACEMITDEC_H_
+
+#include <gst/video/video.h>
+#include <gst/video/gstvideodecoder.h>
+#include "gstspacemitallocator.h"
+#include "gstspacemitbufferpool.h"
+
+#include <vdec.h>
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_SPACEMITDEC          (gst_spacemitdec_get_type())
+#define GST_SPACEMITDEC(obj)          (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SPACEMITDEC,GstSpacemitDec))
+#define GST_SPACEMITDEC_CLASS(klass)  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SPACEMITDEC,GstSpacemitDecClass))
+#define GST_IS_SPACEMITDEC(obj)       (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SPACEMITDEC))
+#define GST_IS_SPACEMITDEC_CLASS(obj) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SPACEMITDEC))
+
+typedef struct _GstSpacemitDec GstSpacemitDec;
+typedef struct _GstSpacemitDecClass GstSpacemitDecClass;
+
+struct _GstSpacemitDec
+{
+  GstVideoDecoder base_spacemitdec;
+
+  MppVdecCtx *ctx;
+  MppVdecPara *para;
+  MppPacket *mpppacket;
+  MppFrame *mppframe;
+
+  guint width;
+  guint height;
+  guint eCodecType;
+  guint eCodingType;
+  MppPixelFormat eOutputPixelFormat;
+  guint downscale;
+
+  GstVideoCodecState *input_state;
+  GstFlowReturn downstream_flow_ret;
+  gboolean at_eos;
+  guint32 cur_frame_number;	/* ED */
+  GstVideoInfo out_info;
+  /* stop handling new frame when flushing */
+  gboolean flushing;
+  gboolean use_dmabuf;
+  gboolean initialized;
+  gboolean dec_nonblock;
+  gboolean req_nonblock;
+  gboolean save_dec;
+  gboolean wait_reschange;
+  GstBufferPool *pool;
+  FILE *fb;
+};
+
+struct _GstSpacemitDecClass
+{
+	GstVideoDecoderClass base_spacemitdec_class;
+};
+
+#ifndef GST_CAPS_FEATURE_MEMORY_DMABUF
+#define GST_CAPS_FEATURE_MEMORY_DMABUF "memory:DMABuf"
+#endif
+
+#define SPM_DEC_OUT_FORMATS "I420, NV21, NV12"
+#define SPM_DEC_FORMATS SPM_DEC_OUT_FORMATS
+//#define SPM_DEC_CAPS_MAKE(fmts) \
+//    GST_VIDEO_CAPS_MAKE (fmts) ";"
+#define SPM_DEC_CAPS_MAKE(fmts) \
+    GST_VIDEO_CAPS_MAKE (fmts) ";" \
+    GST_VIDEO_CAPS_MAKE_WITH_FEATURES (GST_CAPS_FEATURE_MEMORY_DMABUF, fmts)
+
+GType gst_spacemitdec_get_type(void);
+
+gboolean
+gst_spacemitdec_register (GstPlugin * plugin, guint rank);
+
+G_END_DECLS
+
+#endif
diff --git a/ext/spacemit/spacemitcodec/gstspacemitdec_bak.c b/ext/spacemit/spacemitcodec/gstspacemitdec_bak.c
new file mode 100755
index 0000000..f81ee21
--- /dev/null
+++ b/ext/spacemit/spacemitcodec/gstspacemitdec_bak.c
@@ -0,0 +1,1394 @@
+/* GStreamer
+ * Copyright (C) 2022 FIXME <fixme@example.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Suite 500,
+ * Boston, MA 02110-1335, USA.
+ */
+/**
+ * SECTION:element-gstvideoprocess
+ *
+ * The videoprocess element does FIXME stuff.
+ *
+ * <refsect2>
+ * <title>Example launch line</title>
+ * |[
+ * gst-launch-1.0 -v fakesrc ! videoprocess ! FIXME ! fakesink
+ * ]|
+ * FIXME Describe what the pipeline does.
+ * </refsect2>
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+#include <string.h>
+#include <stdio.h>
+
+#include <gst/gst.h>
+#include <gst/video/video.h>
+#include <gst/video/gstvideodecoder.h>
+#include "gstspacemitdec.h"
+
+//#define MULTI_THREAD_DOWNSTREAM_POOL_TEST
+//#define SINGLE_THREAD_DOWNSTREAM_POOL_TEST
+
+GST_DEBUG_CATEGORY_STATIC (gst_spacemitdec_debug_category);
+#define GST_CAT_DEFAULT gst_spacemitdec_debug_category
+
+/* prototypes */
+static void gst_spacemitdec_set_property (GObject * object,
+    guint property_id, const GValue * value, GParamSpec * pspec);
+static void gst_spacemitdec_get_property (GObject * object,
+    guint property_id, GValue * value, GParamSpec * pspec);
+static void gst_spacemitdec_finalize (GObject * object);
+static gboolean gst_spacemitdec_close(GstVideoDecoder *decoder);
+static gboolean gst_spacemitdec_start(GstVideoDecoder *decoder);
+static gboolean gst_spacemitdec_stop(GstVideoDecoder *decoder);
+static gboolean gst_spacemitdec_set_format(GstVideoDecoder *decoder, GstVideoCodecState *state);
+static gboolean gst_spacemitdec_reset(GstVideoDecoder *decoder, gboolean hard);
+static gboolean gst_spacemitdec_flush(GstVideoDecoder * decoder);
+static GstFlowReturn gst_spacemitdec_finish(GstVideoDecoder *decoder);
+static GstFlowReturn gst_spacemitdec_handle_frame(GstVideoDecoder *decoder, GstVideoCodecFrame *frame);
+static gboolean gst_spacemitdec_decide_allocation(GstVideoDecoder *decoder, GstQuery *query);
+static GstStateChangeReturn gst_spacemitdec_dec_change_state (GstElement * element, GstStateChange transition);
+
+/* pad templates */
+static GstStaticPadTemplate gst_spacemitdec_sink_template =
+GST_STATIC_PAD_TEMPLATE ("sink",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS
+    ("video/x-h264, stream-format=(string)byte-stream, alignment=(string)au, "
+      "profile=(string){ constrained-baseline, baseline, main, high },"
+      "width=(int) [640,MAX], " "height=(int) [480,MAX]"
+      ";"
+      "video/x-h265,"
+      "stream-format = (string) byte-stream,"
+      "alignment = (string)au,"
+      "width=(int) [640,MAX], " "height=(int) [480,MAX]"
+    ));
+
+static GstStaticPadTemplate gst_spacemitdec_src_template =
+    GST_STATIC_PAD_TEMPLATE ("src",
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS (SPM_DEC_CAPS_MAKE ("{" SPM_DEC_FORMATS "}") ";")
+    );
+
+#define parent_class gst_spacemitdec_parent_class
+/* class initialization */
+G_DEFINE_TYPE(GstSpacemitDec, gst_spacemitdec, GST_TYPE_VIDEO_DECODER);
+enum
+{
+  PROP_0,
+  PROP_CODING_WIDTH,
+  PROP_CODING_HIGHT,
+  PROP_CODING_TYPE,
+  PROP_CODE_TYPE,
+  PROP_CODE_YUV_FORMAT,
+  N_PROPERTIES
+};
+
+static gboolean
+_gst_caps_has_feature (const GstCaps * caps, const gchar * feature)
+{
+  guint i;
+
+  for (i = 0; i < gst_caps_get_size (caps); i++) {
+    GstCapsFeatures *const features = gst_caps_get_features (caps, i);
+    /* Skip ANY features, we need an exact match for correct evaluation */
+    if (gst_caps_features_is_any (features))
+      continue;
+    if (gst_caps_features_contains (features, feature))
+      return TRUE;
+  }
+
+  return FALSE;
+}
+
+static gboolean
+srcpad_can_dmabuf (GstSpacemitDec * thiz)
+{
+  gboolean ret = FALSE;
+  GstCaps *caps, *out_caps;
+  GstPad *srcpad;
+
+  srcpad = GST_VIDEO_DECODER_SRC_PAD (thiz);
+  caps = gst_pad_get_pad_template_caps (srcpad);
+
+  out_caps = gst_pad_peer_query_caps (srcpad, caps);
+  if (!out_caps)
+    goto done;
+
+  if (gst_caps_is_any (out_caps) || gst_caps_is_empty (out_caps)
+      || out_caps == caps)
+    goto done;
+
+  if (_gst_caps_has_feature (out_caps, GST_CAPS_FEATURE_MEMORY_DMABUF))
+    ret = TRUE;
+
+done:
+  if (caps)
+    gst_caps_unref (caps);
+  if (out_caps)
+    gst_caps_unref (out_caps);
+  return ret;
+}
+
+static gboolean gst_spacemitdec_close(GstVideoDecoder * decoder)
+{
+  GstSpacemitDec *thiz = GST_SPACEMITDEC(decoder);
+
+  if (thiz->input_state)
+  {
+    gst_video_codec_state_unref (thiz->input_state);
+    thiz->input_state = NULL;
+  }
+  GST_DEBUG_OBJECT (decoder, "ZRong --------------- spacemitdec start close");
+  if (thiz->pool) {
+    gst_buffer_pool_set_active (thiz->pool, FALSE);
+//    gst_spacemit_allocator_wait_inactive (GST_SPACEMIT_BUFFER_POOL_CAST(spacemitdec->pool)->allocator);
+    gst_object_unref (spacemitdec->pool);
+    thiz->pool = NULL;
+  }
+  GST_DEBUG_OBJECT (decoder, "ZRong --------------- spacemitdec start close222");
+
+//  FRAME_Destory(spacemitdec->mppframe);
+  PACKET_Destory (thiz->mpppacket);
+  VDEC_DestoryChannel (thiz->ctx);  
+
+  GST_DEBUG_OBJECT (decoder, "ZRong --------------- spacemitdec finish close");
+
+	return TRUE;
+}
+
+
+static void gst_spacemitdec_class_init(GstSpacemitDecClass * klass)
+{
+  GstVideoDecoderClass *video_decoder_class = GST_VIDEO_DECODER_CLASS (klass);
+  GstElementClass *element_class = GST_ELEMENT_CLASS (klass);
+  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
+
+  gst_element_class_add_static_pad_template(GST_ELEMENT_CLASS (klass), &gst_spacemitdec_sink_template);
+  gst_element_class_add_static_pad_template(GST_ELEMENT_CLASS (klass), &gst_spacemitdec_src_template);
+
+  gst_element_class_set_static_metadata(GST_ELEMENT_CLASS (klass),
+    "Spacemit video decoder", "Decoder/Video", "Spacemit video decoder",
+    "ZRong, zhirong.li@spacemit.com");
+
+  gobject_class->set_property = gst_spacemitdec_set_property;
+  gobject_class->get_property = gst_spacemitdec_get_property;
+  gobject_class->finalize = gst_spacemitdec_finalize;
+
+  video_decoder_class->close = GST_DEBUG_FUNCPTR(gst_spacemitdec_close);
+  video_decoder_class->start = GST_DEBUG_FUNCPTR(gst_spacemitdec_start);
+  video_decoder_class->stop = GST_DEBUG_FUNCPTR(gst_spacemitdec_stop);
+  video_decoder_class->set_format = GST_DEBUG_FUNCPTR(gst_spacemitdec_set_format);
+  video_decoder_class->reset = GST_DEBUG_FUNCPTR(gst_spacemitdec_reset);
+  video_decoder_class->flush = GST_DEBUG_FUNCPTR (gst_spacemitdec_flush);
+  video_decoder_class->finish = GST_DEBUG_FUNCPTR(gst_spacemitdec_finish);
+  video_decoder_class->handle_frame = GST_DEBUG_FUNCPTR(gst_spacemitdec_handle_frame);
+  video_decoder_class->decide_allocation = GST_DEBUG_FUNCPTR(gst_spacemitdec_decide_allocation);
+
+//  element_class->change_state = GST_DEBUG_FUNCPTR (gst_spacemitdec_dec_change_state);
+
+  /* define properties */
+  g_object_class_install_property (gobject_class, PROP_CODING_TYPE,
+      g_param_spec_uint ("coding-type", "coding type",
+          "Format to decode",
+          CODING_H264, CODING_FWHT, CODING_H264,
+          (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
+  g_object_class_install_property (gobject_class, PROP_CODE_TYPE,
+      g_param_spec_uint ("code-type", "code type",
+          "Codec selection to work",
+          CODEC_OPENH264, 1023, CODEC_SFOMX,
+          (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
+  g_object_class_install_property (gobject_class, PROP_CODING_WIDTH,
+      g_param_spec_uint ("coding-width", "coding width",
+          "image width to decode",
+          0, 3840, 1280,
+          (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
+  g_object_class_install_property (gobject_class, PROP_CODING_HIGHT,
+      g_param_spec_uint ("coding-hight", "coding hight",
+          "image hight to decode",
+          0, 2160, 720,
+          (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
+  g_object_class_install_property (gobject_class, PROP_CODE_YUV_FORMAT,
+      g_param_spec_uint ("code-yuv-format", "code yuv format",
+          "Decode the generated yuv format",
+          PIXEL_FORMAT_DEFAULT, PIXEL_FORMAT_UNKNOWN-1, PIXEL_FORMAT_I420,
+          (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
+
+}
+
+static void gst_spacemitdec_init (GstSpacemitDec * thiz)
+{
+  GstVideoDecoder *decoder = GST_VIDEO_DECODER (thiz);
+
+  thiz->pool = NULL;
+  thiz->ctx = NULL;
+  thiz->width = 1280;
+  thiz->height = 720;
+  thiz->eCodecType = CODEC_SFOMX;
+  thiz->eCodingType = CODING_H264;
+  thiz->eOutputPixelFormat = PIXEL_FORMAT_I420;
+
+  gst_video_decoder_set_packetized (decoder, TRUE);
+  gst_video_decoder_set_needs_format (decoder, TRUE);
+}
+void
+gst_spacemitdec_set_property (GObject * object, guint property_id,
+    const GValue * value, GParamSpec * pspec)
+{
+  GstSpacemitDec *thiz = GST_SPACEMITDEC (object);
+
+  GST_DEBUG_OBJECT (thiz, "ZRong ------------------- set_property: %d", property_id);
+
+  switch (property_id) {
+    case PROP_CODING_WIDTH:
+      thiz->width = g_value_get_uint (value);
+      break;
+    case PROP_CODING_HIGHT:
+      thiz->height = g_value_get_uint (value);
+      break;
+    case PROP_CODING_TYPE:
+      thiz->eCodingType = g_value_get_uint (value);
+      break;    
+    case PROP_CODE_TYPE:
+      thiz->eCodecType = g_value_get_uint (value);
+      break;
+    case PROP_CODE_YUV_FORMAT:
+      thiz->eOutputPixelFormat = g_value_get_uint (value);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+      break;
+  }
+}
+
+void
+gst_spacemitdec_get_property (GObject * object, guint property_id,
+    GValue * value, GParamSpec * pspec)
+{
+  GstSpacemitDec *thiz = GST_SPACEMITDEC (object);
+
+  GST_DEBUG_OBJECT (thiz, "ZRong ------------------- get_property: %d", property_id);
+
+  switch (property_id) {
+    case PROP_CODING_WIDTH:
+      g_value_set_uint (value, thiz->width);
+      break;
+    case PROP_CODING_HIGHT:
+      g_value_set_uint (value, thiz->height);
+      break;
+    case PROP_CODING_TYPE:
+      g_value_set_uint (value, thiz->eCodingType);
+      break;    
+    case PROP_CODE_TYPE:
+      g_value_set_uint (value, thiz->eCodecType);
+      break;
+    case PROP_CODE_YUV_FORMAT:
+      g_value_set_uint (value, thiz->eOutputPixelFormat);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+      break;
+  }
+}
+
+void
+gst_spacemitdec_finalize (GObject * object)
+{
+  GstSpacemitDec *thiz = GST_SPACEMITDEC (object);
+
+  GST_DEBUG_OBJECT (thiz, "finalize");
+
+  /* clean up object here */
+
+  if (thiz->input_state) {
+    gst_video_codec_state_unref (thiz->input_state);
+  }
+  thiz->input_state = NULL;
+
+  G_OBJECT_CLASS (gst_spacemitdec_parent_class)->finalize (object);
+}
+
+static FILE *fbbb1;
+static gboolean gst_spacemitdec_start (GstVideoDecoder * decoder)
+{
+	GstSpacemitDec *thiz = GST_SPACEMITDEC (decoder);
+  int ret = 0;
+
+  GST_ERROR_OBJECT (thiz, "ZRong ----------------- in start !");
+
+	if (thiz->ctx)
+	{
+		VDEC_DestoryChannel (thiz->ctx);
+		thiz->ctx = NULL;
+	}
+	thiz->ctx = VDEC_CreateChannel ();
+  thiz->ctx->eCodecType = thiz->eCodecType;
+
+	thiz->mpppacket = PACKET_Create ();
+	if (!thiz->mpppacket)
+    goto alloc_err;
+
+  thiz->mppframe = NULL;
+  thiz->at_eos = FALSE;
+  thiz->downstream_flow_ret = GST_FLOW_OK;
+  thiz->cur_frame_number = -1;
+  thiz->use_dmabuf = FALSE;
+  thiz->initialized = FALSE;
+
+  GST_ERROR_OBJECT (thiz, "ZRong ------------------------- finish start !");
+  fbbb1 = fopen("/tmp/out.yuv", "ab+");
+
+	return TRUE;
+
+alloc_err:
+  GST_ERROR_OBJECT (spacemitdec, "can not alloc for mpp structure, please check !");
+  return FALSE;
+
+init_err:
+  GST_ERROR_OBJECT (spacemitdec, "Mpp vdec init error, please check !");
+  return FALSE;
+
+}
+
+static gboolean gst_spacemitdec_stop(GstVideoDecoder *decoder)
+{
+	GstSpacemitDec *spacemitdec = GST_SPACEMITDEC(decoder);
+  GstSpaceMitAllocator * allocator;
+  fclose(fbbb1);
+
+#if 0
+	if (spacemitdec->input_state)
+	{
+		gst_video_codec_state_unref (spacemitdec->input_state);
+		spacemitdec->input_state = NULL;
+	}
+  GST_DEBUG_OBJECT (decoder, "ZRong --------------- spacemitdec start stop");
+
+//  FRAME_Destory(spacemitdec->mppframe);
+  PACKET_Destory (spacemitdec->mpppacket);
+  VDEC_DestoryChannel (spacemitdec->ctx);  
+
+  if (spacemitdec->pool) {
+//    gst_spacemit_allocator_wait_inactive (GST_SPACEMIT_BUFFER_POOL_CAST(spacemitdec->pool)->allocator);
+    gst_object_unref (spacemitdec->pool);
+    spacemitdec->pool = NULL;
+  }
+#endif
+  if (!(gst_pad_get_task_state ((decoder)->srcpad) == GST_TASK_STARTED)) {
+    GST_DEBUG_OBJECT (decoder, "ZRong --------------- spacemitdec finish stop");
+
+    return TRUE;
+  }
+
+  gst_pad_stop_task (decoder->srcpad);
+  GST_DEBUG_OBJECT (decoder, "ZRong --------------- spacemitdec finish stop222");
+
+	return TRUE;
+}
+static MppCodingType
+gst_spacemit_get_mpp_video_type (GstStructure * s)
+{
+  if (gst_structure_has_name (s, "video/x-h264"))
+    return CODING_H264;
+
+  if (gst_structure_has_name (s, "video/x-h265"))
+    return CODING_H265;
+
+  return CODING_UNKNOWN;
+}
+static gboolean
+gst_spacemitdec_init_decoder (GstSpacemitDec * thiz)
+{
+  GstStructure *structure;
+  gboolean ret = TRUE;
+
+  if (thiz->initialized)
+    return TRUE;
+
+  structure = gst_caps_get_structure (thiz->input_state->caps, 0);
+  thiz->eCodingType = gst_spacemit_get_mpp_video_type (structure);
+  if(thiz->eCodingType == CODING_UNKNOWN) {
+    GST_ERROR_OBJECT(thiz, "mpp no support this eCodingType");
+    return FALSE;
+  }
+
+  if (thiz->ctx->eCodecType == CODEC_SFOMX ||
+      thiz->ctx->eCodecType == CODEC_OPENH264 ||
+      thiz->ctx->eCodecType == CODEC_FAKEDEC) {
+    thiz->width = thiz->input_state->info.width;
+    thiz->height = thiz->input_state->info.height;
+    thiz->ctx->stVdecPara.eCodingType = thiz->eCodingType;
+    thiz->ctx->stVdecPara.nWidth = thiz->width;
+    thiz->ctx->stVdecPara.nHeight = thiz->height;
+    thiz->ctx->stVdecPara.eOutputPixelFormat = thiz->eOutputPixelFormat;
+    thiz->ctx->eCodecType = thiz->eCodecType;
+    thiz->ctx->stVdecPara.bInputBlockModeEnable = MPP_TRUE;
+    thiz->ctx->stVdecPara.bOutputBlockModeEnable = MPP_TRUE;
+    GST_DEBUG_OBJECT (thiz, "spacemitdec set eCodecType is %d", thiz->ctx->eCodecType);
+
+    ret = VDEC_Init (thiz->ctx);
+    if (ret) {
+      GST_ERROR_OBJECT (thiz, "Mpp vdec init error, please check !");
+      return FALSE;
+    }
+  } else {
+    GST_ERROR_OBJECT (thiz, "No supprot this type(%d) to handle frame", thiz->ctx->eCodecType);
+  }
+
+  thiz->initialized = TRUE;
+  return TRUE;
+}
+
+/* function: 
+ *    Tell subclasses to input stream data format
+ * called time:
+ *    When the upstream element sends GST_EVENT_CAPS,
+ *    call in gst_video_decoder_setcaps.
+ *    need to modify.................................
+ */
+static gboolean gst_spacemitdec_set_format(GstVideoDecoder *decoder, GstVideoCodecState *state)
+{
+	GstSpacemitDec *spacemitdec = GST_SPACEMITDEC(decoder);
+  GstStructure *structure;
+  gboolean ret = TRUE;
+
+	GST_DEBUG_OBJECT(spacemitdec, "input caps: %" GST_PTR_FORMAT, state->caps);
+
+	if(spacemitdec->input_state)
+	{
+		gst_video_codec_state_unref(spacemitdec->input_state);
+		spacemitdec->input_state = NULL;
+	}
+
+	spacemitdec->input_state = gst_video_codec_state_ref (state);
+  if (!gst_spacemitdec_init_decoder(spacemitdec))
+    return FALSE;
+
+	GST_DEBUG_OBJECT (spacemitdec, "@@@ ZRong ------------------------- finish set_format, %d, %d, %d,     %d, %d, %d,         %d, %d!",
+    spacemitdec->input_state->info.width, spacemitdec->input_state->info.height, spacemitdec->input_state->info.size,
+    state->info.width, state->info.height, state->info.size,
+    PACKET_GetBaseData(spacemitdec->mpppacket)->nWidth, PACKET_GetBaseData(spacemitdec->mpppacket)->nHeight);
+  GstVideoFormat fmt;
+  fmt = GST_VIDEO_INFO_FORMAT (&state->info);
+  GST_ERROR_OBJECT (spacemitdec, "ZRong ----------------------- set format finish, %u, %s", fmt, gst_video_format_to_string (fmt));
+
+	return TRUE;
+}
+
+static gboolean gst_spacemitdec_reset(GstVideoDecoder *decoder, gboolean hard)
+{
+	GstSpacemitDec *spacemitdec = GST_SPACEMITDEC(decoder);
+
+	GST_ERROR_OBJECT (spacemitdec, "ZRong ------------------------- finish reset!");
+
+	return TRUE;
+}
+static gboolean
+gst_spacemitdec_flush (GstVideoDecoder * decoder)
+{
+	GstSpacemitDec *spacemitdec = GST_SPACEMITDEC(decoder);
+
+  GST_DEBUG_OBJECT (spacemitdec, "ZRong -------------------- flushing decoder start, (%d)", spacemitdec->downstream_flow_ret);
+
+  spacemitdec->flushing = TRUE;
+
+  if (spacemitdec->downstream_flow_ret == GST_FLOW_EOS)
+    gst_spacemit_allocator_wait_inactive (GST_SPACEMIT_BUFFER_POOL_CAST(spacemitdec->pool)->allocator);
+
+  VDEC_Flush(spacemitdec->ctx);
+
+  GST_VIDEO_DECODER_STREAM_UNLOCK (decoder);
+
+  /* Wait for task thread to pause */
+  GstTask *task = decoder->srcpad->task;
+  if (task) {
+    //GST_OBJECT_LOCK (task);
+    while (GST_TASK_STATE (task) == GST_TASK_STARTED) {
+      GST_DEBUG_OBJECT(spacemitdec, "finish FLUSH test4");
+      g_usleep(400 * 1000);
+      //GST_TASK_WAIT (task);
+    }
+    GST_DEBUG_OBJECT(spacemitdec, "finish FLUSH test5");
+    //GST_OBJECT_UNLOCK (task);
+    gst_pad_stop_task (decoder->srcpad);
+  }
+  GST_VIDEO_DECODER_STREAM_LOCK (decoder);
+
+  spacemitdec->flushing = FALSE;
+  spacemitdec->downstream_flow_ret = GST_FLOW_OK;
+
+  GST_DEBUG_OBJECT (spacemitdec, "ZRong -------------------- flushing decoder stop");
+
+	return TRUE;
+}
+
+static int gst_mpp_format_change(MppPixelFormat eOutputPixelFormat)
+{
+  GstVideoFormat format;
+
+  switch(eOutputPixelFormat){
+    case PIXEL_FORMAT_I420:
+      format = GST_VIDEO_FORMAT_I420;
+      break;
+    case PIXEL_FORMAT_NV21:
+      format = GST_VIDEO_FORMAT_NV21;
+      break;
+    case PIXEL_FORMAT_NV12:
+      format = GST_VIDEO_FORMAT_NV12;
+      break;
+    default:
+      format = GST_VIDEO_FORMAT_UNKNOWN;
+      break;
+  }
+  return format;
+}
+
+static GstFlowReturn
+gst_spacemitdec_fill_output_buffer (GstVideoDecoder * decoder,
+    GstBuffer **output_buffer)
+{
+  GstSpacemitDec *spacemitdec = GST_SPACEMITDEC (decoder);
+  GstVideoInfo *vinfo = NULL;
+  GstVideoFormat format;
+  const guint8 *data;
+  guint8 *dst;
+  guint h;
+  gint dst_width[GST_VIDEO_MAX_PLANES] = { 0, };
+  gint dst_height[GST_VIDEO_MAX_PLANES] = { 0, };
+  guint p;
+  GstVideoFrame video_frame;
+  GstVideoCodecState *state;
+  GstFlowReturn flow_status = GST_FLOW_OK;
+  GstBuffer *outbuf;
+  GstBufferPoolAcquireParams params = { 0, };
+  GstMemory *mem;
+  GstSpaceMitMemory *spm_mem;
+  gint32 id;
+  gint32 fd;
+
+  id = FRAME_GetID(spacemitdec->mppframe);
+  if (spacemitdec->use_dmabuf) {
+    fd = FRAME_GetFD(spacemitdec->mppframe);
+    gst_spacemit_allocator_get_info (GST_SPACEMIT_BUFFER_POOL_CAST(spacemitdec->pool)->allocator, id, fd);
+    GST_DEBUG_OBJECT (spacemitdec, "@@@ ZRong get info (%d %d)", id, fd);
+
+  } else {
+    gst_spacemit_allocator_get_info (GST_SPACEMIT_BUFFER_POOL_CAST(spacemitdec->pool)->allocator, id, -1);
+  }
+
+  flow_status = gst_buffer_pool_acquire_buffer (spacemitdec->pool, &outbuf, &params);
+  if (flow_status != GST_FLOW_OK) {
+     goto alloc_err;
+  }
+
+#if !defined(MULTI_THREAD_DOWNSTREAM_POOL_TEST) && !defined(SINGLE_THREAD_DOWNSTREAM_POOL_TEST)
+  mem = gst_buffer_peek_memory (outbuf, 0);
+  gst_spacemit_set_mem (mem, spacemitdec->mppframe, spacemitdec->ctx);
+  GST_DEBUG_OBJECT (spacemitdec, "@@@ ZRong 444");
+  *output_buffer = outbuf;
+#else
+
+  if (gst_pad_get_task_state ((decoder)->srcpad) == GST_TASK_STARTED) {
+    flow_status = gst_buffer_pool_acquire_buffer (spacemitdec->pool, &outbuf, &params);
+    if (flow_status != GST_FLOW_OK)
+       goto alloc_err;
+    *output_buffer = outbuf; //mult thread, get outbuf from acquire
+    GST_DEBUG_OBJECT (spacemitdec, "@@@ ZRong AAAA ");
+  } else {
+    outbuf = *output_buffer; //single thread, get outbuf from outside
+    GST_DEBUG_OBJECT (spacemitdec, "@@@ ZRong BBBB ");
+  }
+
+  state = gst_video_decoder_get_output_state (decoder);
+  if (state == NULL)
+    goto negotiated_err;
+
+  if (!gst_video_frame_map (&video_frame, &state->info, outbuf,
+          GST_MAP_WRITE))
+    goto map_err;
+
+  format = gst_mpp_format_change(spacemitdec->eOutputPixelFormat);
+
+  vinfo = &state->info;
+  dst_height[0] = GST_VIDEO_INFO_FIELD_HEIGHT (vinfo);
+
+  switch (format) {
+    case GST_VIDEO_FORMAT_I420:
+      dst_width[0] = GST_VIDEO_INFO_WIDTH (vinfo);
+      dst_width[1] = GST_VIDEO_INFO_WIDTH (vinfo) / 2;
+      dst_height[1] = GST_VIDEO_INFO_FIELD_HEIGHT (vinfo) / 2;
+      dst_width[2] = GST_VIDEO_INFO_WIDTH (vinfo) / 2;
+      dst_height[2] = GST_VIDEO_INFO_FIELD_HEIGHT (vinfo) / 2;
+      GST_ERROR_OBJECT (spacemitdec, "ZRong ------------------ in I420 dec_fill_buffer,(%d, %d, %d) (%d, %d, %d)",
+        dst_width[0], dst_width[1], dst_width[2],
+        GST_VIDEO_INFO_PLANE_STRIDE (vinfo, 0), GST_VIDEO_INFO_PLANE_STRIDE (vinfo, 1), GST_VIDEO_INFO_PLANE_STRIDE (vinfo, 2));
+      GST_ERROR_OBJECT (spacemitdec, "ZRong ------------------ in I420 dec_fill_buffer,(%d, %d, %d) %d",
+        dst_height[0], dst_height[1], dst_height[2], GST_VIDEO_INFO_N_PLANES (vinfo));
+
+      break;
+    case GST_VIDEO_FORMAT_NV12:
+    case GST_VIDEO_FORMAT_NV21:
+      dst_width[0] = GST_VIDEO_INFO_WIDTH (vinfo);
+      dst_width[1] = GST_VIDEO_INFO_WIDTH (vinfo);
+      dst_height[1] = GST_VIDEO_INFO_FIELD_HEIGHT (vinfo) / 2;
+      GST_ERROR_OBJECT (spacemitdec, "ZRong ------------------ in NV12/NV21 dec_fill_buffer,(%d, %d) ",
+        dst_width[0], dst_width[1]);
+      GST_ERROR_OBJECT (spacemitdec, "ZRong ------------------ in NV12/NV21 dec_fill_buffer,(%d, %d,)",
+        dst_height[0], dst_height[1]);
+
+      break;
+    default:
+      g_assert_not_reached ();
+      break;
+  }
+
+  for (p = 0; p < GST_VIDEO_INFO_N_PLANES (vinfo); p++) {
+    data = (U8*)FRAME_GetDataPointer(spacemitdec->mppframe, p);
+    dst = GST_VIDEO_FRAME_PLANE_DATA (&video_frame, p);
+
+    for (h = 0; h < dst_height[p]; h++) {
+//    fwrite(data, 1, dst_width[p], fbbb1);
+      memcpy (dst, data, dst_width[p]);
+      dst += GST_VIDEO_INFO_PLANE_STRIDE (vinfo, p);
+      data += dst_width[p];
+    }
+  }
+
+	gst_video_codec_state_unref (state);
+	gst_video_frame_unmap (&video_frame);
+#endif
+
+done:
+  spacemitdec->mppframe = NULL;
+  return flow_status;
+
+alloc_err:
+{
+  GST_ERROR_OBJECT (spacemitdec,
+      "an output buffer could not be allocated");
+  goto done;
+}
+negotiated_err:
+{
+  GST_ERROR_OBJECT (spacemitdec,
+      "Not yet negotiate with downstream elements!");
+  flow_status = GST_FLOW_NOT_NEGOTIATED;
+  goto done;
+}
+map_err:
+{
+  GST_ERROR_OBJECT (spacemitdec, "Cannot map output buffer!");
+  gst_video_codec_state_unref (state);
+  flow_status = GST_FLOW_ERROR;
+  goto done;
+}
+
+}
+
+static void
+gst_st_mpp_dec_loop (GstVideoDecoder * decoder)
+{
+  GstSpacemitDec *spacemitdec = GST_SPACEMITDEC (decoder);
+  GstVideoCodecFrame * frame;
+  GstFlowReturn flow_status;
+  GstVideoFrame video_frame;
+  guint8 *p;
+  guint row_stride, component_width, component_height, row;
+  U8 *tmp_pdata[3];
+  int pnum, i, size[3];
+  int ret;
+  MppFrame *mppframe = NULL;
+
+  if (G_UNLIKELY(spacemitdec->flushing)) {
+    goto flushing;
+  }
+
+  ret = VDEC_RequestOutputFrame_2 (spacemitdec->ctx, (MppData **)&mppframe);
+  if (ret == MPP_CODER_EOS) {
+    goto finish_work;
+  } else if (ret == MPP_CODER_NO_DATA || mppframe == NULL) {
+    goto no_mppframe;
+  }
+
+  GST_DEBUG_OBJECT (spacemitdec, "@@@ ZRong 555, %d", ret);
+
+  spacemitdec->mppframe = mppframe;
+  frame = gst_video_decoder_get_oldest_frame (decoder);
+
+  if (frame == NULL) {
+    GstBuffer *outbuf = NULL;
+    GST_DEBUG_OBJECT (spacemitdec, "@@@ ZRong 333, null");
+    flow_status = gst_spacemitdec_fill_output_buffer (decoder, &outbuf);
+    if (flow_status != GST_FLOW_OK) {
+      goto fill_buffer_err;
+    }
+    GST_DEBUG_OBJECT (spacemitdec, "zrong ---------------- push buf of size %" G_GSIZE_FORMAT ", "
+        "PTS %" GST_TIME_FORMAT ", dur %" GST_TIME_FORMAT,
+        gst_buffer_get_size (outbuf),
+        GST_TIME_ARGS (GST_BUFFER_PTS (outbuf)),
+        GST_TIME_ARGS (GST_BUFFER_DURATION (outbuf)));
+    flow_status = gst_pad_push (GST_VIDEO_DECODER_SRC_PAD (decoder), outbuf);
+
+  } else {
+    GST_DEBUG_OBJECT (spacemitdec, "@@@ ZRong 333, %d", frame->ref_count);
+    flow_status = gst_spacemitdec_fill_output_buffer (decoder, &frame->output_buffer);
+    if (flow_status != GST_FLOW_OK) {
+      goto fill_buffer_err;
+    }
+    struct timeval tv1 = {0};
+    struct timeval tv2 = {0};
+    
+    gettimeofday(&tv1, NULL);
+
+    flow_status = gst_video_decoder_finish_frame(decoder, frame);
+    gettimeofday(&tv2, NULL);
+
+    GST_ERROR_OBJECT (spacemitdec, "ZRong -------------- spacemit handle %ld ",
+      tv2.tv_sec * 1000000 + tv2.tv_usec - (tv1.tv_sec * 1000000 + tv1.tv_usec));
+  }
+
+  if (flow_status != GST_FLOW_OK)
+    goto sending_state;
+
+  spacemitdec->downstream_flow_ret = flow_status;
+#ifdef MULTI_THREAD_DOWNSTREAM_POOL_TEST
+  VDEC_ReturnOutputFrame(spacemitdec->ctx, FRAME_GetBaseData(spacemitdec->mppframe));
+#endif
+
+done:
+  if (spacemitdec->downstream_flow_ret != GST_FLOW_OK) {
+    GST_INFO_OBJECT (spacemitdec,
+        "pause task in dec loop (%d)!", spacemitdec->downstream_flow_ret);
+
+    gst_pad_pause_task (GST_VIDEO_DECODER_SRC_PAD (spacemitdec));
+  }
+	return;
+
+flushing:
+{
+  spacemitdec->downstream_flow_ret = GST_FLOW_FLUSHING;
+
+  while (1) {
+    frame = gst_video_decoder_get_oldest_frame (decoder);
+    if(frame == NULL)
+      break;
+    gst_video_decoder_release_frame (decoder, frame);
+  }
+  GST_INFO_OBJECT (spacemitdec, "flushing spacemit decoder");
+
+  goto done;
+}
+
+no_mppframe:
+{
+  //GST_LOG_OBJECT (spacemitdec,
+  //    "No out mppframes to request!");
+  spacemitdec->downstream_flow_ret = GST_FLOW_OK;
+  goto done;
+}
+
+fill_buffer_err:
+{
+  GST_ERROR_OBJECT (spacemitdec,
+      "fill buffer err in dec loop, flow status: %d!", flow_status);
+  spacemitdec->downstream_flow_ret = flow_status;
+  gst_video_codec_frame_unref (frame);
+  goto done;
+}
+
+finish_work:
+{
+  GST_DEBUG_OBJECT (spacemitdec,
+      "Get eos, Finished work and paused task!");
+  spacemitdec->downstream_flow_ret = GST_FLOW_EOS;
+
+  goto done;
+
+}
+fream_null:
+{
+  GST_ERROR_OBJECT (spacemitdec, "get oldest frame fail!");
+  spacemitdec->downstream_flow_ret = GST_FLOW_ERROR;
+  goto done;
+}
+
+sending_state:
+{
+  spacemitdec->downstream_flow_ret = flow_status;
+  if (flow_status == GST_FLOW_EOS) {
+    GST_DEBUG_OBJECT (spacemitdec,
+        "Get eos, Finished work!");
+  } else if (flow_status == GST_FLOW_ERROR) {
+    GST_ERROR_OBJECT (spacemitdec,
+        "send error and paused task!");
+  } else if (flow_status == GST_FLOW_FLUSHING) {
+    spacemitdec->flushing = TRUE;
+    GST_DEBUG_OBJECT (spacemitdec,
+        "Get GST_FLOW_FLUSHING from finish frame!");
+
+    goto flushing;
+  } else {
+    GST_ERROR_OBJECT (spacemitdec,
+        "Get an unsupport flow status return after finish frame!");
+  }
+  goto done;
+}
+
+}
+static gboolean
+gst_spacemitdec_pool_set_active(GstVideoDecoder * decoder)
+{
+  GstSpacemitDec *spacemitdec = GST_SPACEMITDEC (decoder);
+  GST_ERROR_OBJECT (spacemitdec, "@@@ ZRong ------------------------- in spacemitdec pool_set_active!");
+  GstVideoCodecState *state;
+  GstBufferPool *pool;
+  guint size, min, max, i;
+  GstStructure *config;
+  GstCaps *caps = NULL;
+  GstVideoInfo vinfo;
+/*
+  i = 0;
+  while (i < gst_query_get_n_allocation_pools (query)) {
+    gst_query_parse_nth_allocation_pool (query, i, &pool, NULL, NULL, NULL);
+    i++;
+    if (pool) {
+      GST_DEBUG_OBJECT (spacemitdec,
+          "upstream provides pool: %" GST_PTR_FORMAT, pool);
+      gst_object_unref (pool);
+    }
+  }
+
+  gst_query_parse_allocation (query, &caps, NULL);
+*/
+
+  pool = gst_video_decoder_get_buffer_pool (GST_VIDEO_DECODER (spacemitdec));
+
+  if (pool) {
+    config = gst_buffer_pool_get_config (pool);
+    if (!gst_buffer_pool_config_get_params (config, &caps, NULL, &min, &max)) {
+      GST_ERROR_OBJECT (spacemitdec, "Can't get buffer pool params");
+      gst_structure_free (config);
+      return FALSE;
+    }
+    gst_structure_free (config);
+  }
+
+  if (caps) {
+    spacemitdec->pool = gst_spacemit_buffer_pool_new ();
+    config = gst_buffer_pool_get_config (spacemitdec->pool);
+    gst_buffer_pool_config_add_option (config,
+        GST_BUFFER_POOL_OPTION_VIDEO_META);
+
+    gst_video_info_init (&vinfo);
+    gst_video_info_from_caps (&vinfo, caps);
+    min = MAX (min, 8);
+
+    gst_buffer_pool_config_set_params (config, caps,
+        vinfo.size, min, max);
+    if (!gst_buffer_pool_set_config (spacemitdec->pool, config)) {
+      GST_ERROR_OBJECT (spacemitdec, "Failed to set config on spacemit pool");
+      gst_object_unref (spacemitdec->pool);
+      spacemitdec->pool = NULL;
+      return FALSE;
+    }
+    if (!gst_buffer_pool_set_active (spacemitdec->pool, TRUE)) {
+      GST_ERROR_OBJECT (spacemitdec, "Failed to activate internal pool");
+      gst_object_unref (spacemitdec->pool);
+      spacemitdec->pool = NULL;
+      return FALSE;
+    }
+    GST_DEBUG_OBJECT (spacemitdec,
+        "use spacemit bufferpool: %" GST_PTR_FORMAT, spacemitdec->pool);
+
+    pool = gst_video_decoder_get_buffer_pool (decoder);
+    if(!gst_buffer_pool_set_active (pool, FALSE))
+      GST_ERROR_OBJECT (spacemitdec, "Failed to set acitve false on pool %" GST_PTR_FORMAT, pool);
+    gst_object_unref (pool);
+    gst_caps_unref (caps);
+  } else {
+    GST_ERROR_OBJECT (spacemitdec, "Can't get pool caps params");
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
+static gboolean
+gst_spacemitdec_set_src_caps (GstSpacemitDec * thiz)
+{
+  GstVideoCodecState *output_state;
+  GstVideoInfo *vinfo;
+  GstVideoFormat format;
+  guint width, height;
+
+  width = thiz->ctx->stVdecPara.nWidth;
+  height = thiz->ctx->stVdecPara.nHeight;
+
+  format = gst_mpp_format_change(thiz->eOutputPixelFormat);
+  if (format == GST_VIDEO_FORMAT_UNKNOWN) {
+    GST_ERROR_OBJECT (thiz, "Failed to find a valid video format");
+    return FALSE;
+  }
+
+  output_state =
+      gst_video_decoder_set_output_state (GST_VIDEO_DECODER (thiz),
+      format, width, height, thiz->input_state);
+  vinfo = &output_state->info;
+  output_state->caps = gst_video_info_to_caps (vinfo);
+
+  if (srcpad_can_dmabuf (thiz)) {
+    gst_caps_set_features (output_state->caps, 0,
+        gst_caps_features_new (GST_CAPS_FEATURE_MEMORY_DMABUF, NULL));
+    GST_DEBUG_OBJECT (thiz, "set DMABUF feature to spacemitdec src cap %" GST_PTR_FORMAT, output_state->caps);
+  }
+
+  thiz->width = width;
+  thiz->height = height;
+
+  return TRUE;
+}
+
+/* function: 
+ *    Receive the data stream of upstream for decoder
+ */
+static GstFlowReturn
+gst_spacemitdec_handle_frame (GstVideoDecoder * decoder,
+    GstVideoCodecFrame * frame)
+{
+  GstSpacemitDec *spacemitdec = GST_SPACEMITDEC (decoder);
+  GstMapInfo map_info;
+  GstClockTime pts;
+  GstFlowReturn flow_status;
+  GstVideoFrame video_frame;
+  guint actual_width, actual_height;
+  guint8 *p;
+  guint component_width, component_height;
+  GstFlowReturn ret;
+  GstVideoFormat format;
+  GstVideoInfo *vinfo;
+
+  if (G_UNLIKELY (spacemitdec->flushing))
+    goto flushing;
+
+#ifndef SINGLE_THREAD_DOWNSTREAM_POOL_TEST
+  if (G_UNLIKELY (!gst_pad_get_task_state ((decoder)->srcpad) == GST_TASK_STARTED)) {
+    GST_DEBUG_OBJECT (spacemitdec, "@@@ ZRong ------------------------- starting decoding thread");
+
+    gst_pad_start_task (decoder->srcpad,
+        (GstTaskFunction) gst_st_mpp_dec_loop, decoder, NULL);
+  }
+#endif
+  if (G_UNLIKELY(spacemitdec->downstream_flow_ret != GST_FLOW_OK))
+    goto downstream_err;
+
+  if (G_LIKELY(frame)) {
+    spacemitdec->cur_frame_number = frame->system_frame_number;
+    GST_DEBUG_OBJECT (spacemitdec, "@@@ ZRong ------------------------- in handle frame!");
+
+    GST_VIDEO_DECODER_STREAM_UNLOCK (decoder);
+    if (!gst_buffer_map (frame->input_buffer, &map_info, GST_MAP_READ))
+      goto map_err;
+
+    PACKET_SetDataPointer(spacemitdec->mpppacket, map_info.data);
+    PACKET_SetLength(spacemitdec->mpppacket, map_info.size);
+    MppData * tmp = PACKET_GetBaseData(spacemitdec->mpppacket);
+    tmp->bEos = 0;
+
+    ret = VDEC_Decode(spacemitdec->ctx, PACKET_GetBaseData(spacemitdec->mpppacket));
+
+    gst_buffer_unmap (frame->input_buffer, &map_info);
+
+    GST_VIDEO_DECODER_STREAM_LOCK (decoder);
+
+    if (ret) {
+      GST_ERROR_OBJECT (spacemitdec, "VDEC_Decode return error! (%d)", ret);
+      ret = gst_video_decoder_drop_frame (decoder, frame);
+      goto out;
+    }
+    gst_video_codec_frame_unref (frame);
+   } else {
+    GST_VIDEO_DECODER_STREAM_UNLOCK (decoder);
+    int count=3;
+    while(count>0)
+    {
+      MppData * tmp = PACKET_GetBaseData(spacemitdec->mpppacket);
+      tmp->bEos = 1;
+      PACKET_SetLength(spacemitdec->mpppacket, 0);
+      ret = VDEC_Decode(spacemitdec->ctx, PACKET_GetBaseData(spacemitdec->mpppacket));
+
+      GST_DEBUG_OBJECT (spacemitdec, "@@@ ZRong ------------------------- in handle else, %d!", ret);
+      count--;
+    }
+    spacemitdec->cur_frame_number = -1;
+    ret = GST_FLOW_EOS;
+    GST_VIDEO_DECODER_STREAM_LOCK (decoder);
+
+    goto out;
+  }
+  actual_width = spacemitdec->ctx->stVdecPara.nWidth;
+  actual_height = spacemitdec->ctx->stVdecPara.nHeight;
+
+  if (!gst_pad_has_current_caps (GST_VIDEO_DECODER_SRC_PAD (spacemitdec))
+      || actual_width != spacemitdec->width
+      || actual_height != spacemitdec->height) {
+
+    if (!gst_spacemitdec_set_src_caps (spacemitdec))
+      goto not_negotiated_err;
+
+    GST_DEBUG_OBJECT (spacemitdec, "@@@ ZRong ------------------------- bf decoder_negotiate, %d, %d, (%d %d)!", actual_width, actual_height, format, spacemitdec->eOutputPixelFormat);
+
+    if (!gst_video_decoder_negotiate (decoder))
+      goto not_negotiated_err;
+
+#if !defined(MULTI_THREAD_DOWNSTREAM_POOL_TEST) && !defined(SINGLE_THREAD_DOWNSTREAM_POOL_TEST)
+    if (!gst_buffer_pool_set_active (spacemitdec->pool, TRUE))
+      goto acitve_fail;
+
+ //   if (!gst_spacemitdec_pool_set_active(decoder))
+//      goto acitve_fail;
+#endif
+  }
+
+#ifdef SINGLE_THREAD_DOWNSTREAM_POOL_TEST
+  GST_DEBUG_OBJECT (spacemitdec, "@@@ ZRong 555, %d", ret);
+  MppFrame *mppframe = NULL;
+
+  frame = gst_video_decoder_get_oldest_frame (decoder);
+  if (frame == NULL) {
+    GST_DEBUG_OBJECT (spacemitdec, "@@@ ZRong errrrrrrrrrrrrrrrrrrrrr");
+    ret = GST_FLOW_OK;
+    goto out;
+  } else {
+    flow_status = gst_video_decoder_allocate_output_frame (decoder, frame);
+    if (flow_status != GST_FLOW_OK) {
+      GST_DEBUG_OBJECT (spacemitdec, "@@@ ZRong errrrrrrrrrrrrrrrrrrrrr");
+      ret = GST_FLOW_OK;
+      goto out;
+    }
+
+    GST_DEBUG_OBJECT (spacemitdec, "@@@ ZRong 333, %d, %d", frame->ref_count, flow_status);
+
+    int rett;
+    rett = VDEC_RequestOutputFrame_2 (spacemitdec->ctx, (MppData **)&mppframe);
+    if (rett == MPP_CODER_NO_DATA || mppframe == NULL) {
+      GST_DEBUG_OBJECT (spacemitdec, "@@@ ZRong errrrrrrrrrrrrrrrrrrrrr");
+      ret = GST_FLOW_OK;
+      goto out;
+    }
+
+    spacemitdec->mppframe = mppframe;
+    flow_status = gst_spacemitdec_fill_output_buffer (decoder, &frame->output_buffer);
+    if (flow_status != GST_FLOW_OK) {
+      GST_DEBUG_OBJECT (spacemitdec, "@@@ ZRong errrrrrrrrrrrrrrrrrrrrr");
+      ret = GST_FLOW_OK;
+      goto out;
+    }
+    VDEC_ReturnOutputFrame(spacemitdec->ctx, FRAME_GetBaseData(spacemitdec->mppframe));
+
+    flow_status = gst_video_decoder_finish_frame(decoder, frame);
+    spacemitdec->downstream_flow_ret = flow_status;
+  }
+#endif
+  GST_DEBUG_OBJECT (spacemitdec, "@@@ ZRong ------------------------- af current_caps, %d", spacemitdec->downstream_flow_ret);
+  ret = spacemitdec->downstream_flow_ret;
+
+out:
+  if (spacemitdec->downstream_flow_ret == GST_FLOW_FLUSHING)
+    ret = GST_FLOW_FLUSHING;
+  return ret;
+
+out_clked:
+  GST_VIDEO_DECODER_STREAM_LOCK (decoder);
+  return ret;
+
+not_negotiated_err:
+{
+  GST_ERROR_OBJECT (spacemitdec,
+      "Failed to negotiate with downstream elements");
+  ret = GST_FLOW_NOT_NEGOTIATED;
+  goto out;
+}
+
+acitve_fail:
+{
+  GST_ERROR_OBJECT (spacemitdec, "acitve spacemit pool fail!");
+  gst_object_unref (spacemitdec->pool);
+  ret = GST_FLOW_ERROR;
+  goto out;
+}
+
+map_err:
+{
+  GST_ERROR_OBJECT (spacemitdec, "Cannot map input buffer!");
+  gst_video_codec_frame_unref (frame);
+  ret = GST_FLOW_ERROR;
+  goto out_clked;
+}
+
+downstream_err:
+{
+  GST_ERROR_OBJECT (spacemitdec, "Downstream returned %s",
+      gst_flow_get_name (spacemitdec->downstream_flow_ret));
+  ret = spacemitdec->downstream_flow_ret;
+  goto out;
+}
+flushing:
+{
+  GST_WARNING_OBJECT (spacemitdec, "flushing");
+  ret = GST_FLOW_FLUSHING;
+  gst_video_decoder_release_frame (decoder, frame);
+  goto out;
+}
+}
+/* function: 
+ *    Receive event GST_EVENT_SEGMENT_DONE，GST_EVENT_EOS or reverse playback,
+ *    ask the subclass to process the remaining data in the decoder. After this
+ *    operation, the subclass can refuse to decode the new data
+ * called time:
+ *    in gst_video_decoder_drain_out、gst_video_decoder_flush_parse
+ *    need to modify.................................
+ */
+static GstFlowReturn gst_spacemitdec_finish(GstVideoDecoder *decoder)
+{
+  GstSpacemitDec *spacemitdec = GST_SPACEMITDEC(decoder);
+
+  GST_DEBUG_OBJECT(spacemitdec, "finish");
+
+  /* Decoder not negotiated yet */
+  if (spacemitdec->width == 0)
+    return GST_FLOW_OK;
+  GST_DEBUG_OBJECT(spacemitdec, "finish test1");
+
+  /* Drain all pending frames */
+  while ((gst_spacemitdec_handle_frame (decoder, NULL)) == GST_FLOW_OK);
+
+  GST_DEBUG_OBJECT(spacemitdec, "finish test3");
+  spacemitdec->at_eos = TRUE;
+
+  GST_VIDEO_DECODER_STREAM_UNLOCK (decoder);
+
+  /* Wait for task thread to pause */
+  GstTask *task = decoder->srcpad->task;
+  if (task) {
+    //GST_OBJECT_LOCK (task);
+    while (GST_TASK_STATE (task) == GST_TASK_STARTED) {
+      GST_DEBUG_OBJECT(spacemitdec, "finish test4");
+      g_usleep(400 * 1000);
+      //GST_TASK_WAIT (task);
+    }
+    GST_DEBUG_OBJECT(spacemitdec, "finish test5");
+    //GST_OBJECT_UNLOCK (task);
+  }
+  gst_pad_stop_task (decoder->srcpad);
+  GST_VIDEO_DECODER_STREAM_LOCK (decoder);
+
+  GST_DEBUG_OBJECT(spacemitdec, "finish test2");
+
+  return GST_FLOW_OK;
+}
+
+static GstBufferPool *
+gst_spacemitdec_create_buffer_pool (GstSpacemitDec * thiz, GstVideoInfo * info,
+    guint num_buffers)
+{
+  GstBufferPool *pool = NULL;
+  GstAllocator *allocator = NULL;
+  GstStructure *config;
+  GstCaps *caps = NULL;
+  GstVideoAlignment align;
+
+  pool = gst_spacemit_buffer_pool_new ();
+  if (!pool)
+    goto error_no_pool;
+
+  allocator = gst_spacemit_allocator_new ();
+  if (!allocator)
+    goto error_no_allocator;
+
+  gst_spacemit_allocator_configure(allocator, info, thiz->use_dmabuf);
+
+  caps = gst_video_info_to_caps (info);
+
+  config = gst_buffer_pool_get_config (GST_BUFFER_POOL_CAST (pool));
+  gst_buffer_pool_config_set_params (config, caps,
+      GST_VIDEO_INFO_SIZE (info), num_buffers, num_buffers);
+  gst_buffer_pool_config_add_option (config, GST_BUFFER_POOL_OPTION_VIDEO_META);
+  gst_buffer_pool_config_add_option (config,
+      GST_BUFFER_POOL_OPTION_VIDEO_ALIGNMENT);
+  gst_caps_unref (caps);
+
+  if (thiz->use_dmabuf)
+    gst_buffer_pool_config_add_option (config,
+        GST_BUFFER_POOL_OPTION_SPM_USE_DMABUF);
+
+  gst_buffer_pool_config_set_video_alignment (config, &align);
+  gst_buffer_pool_config_set_allocator (config, allocator, NULL);
+  gst_object_unref (allocator);
+
+  if (!gst_buffer_pool_set_config (pool, config))
+    goto error_pool_config;
+
+  return pool;
+
+error_no_pool:
+  {
+    GST_ERROR_OBJECT (thiz, "failed to create spacemitdec bufferpool");
+    return NULL;
+  }
+error_no_allocator:
+  {
+    GST_ERROR_OBJECT (thiz, "failed to create allocator");
+    gst_object_unref (pool);
+    return NULL;
+  }
+error_pool_config:
+  {
+    GST_ERROR_OBJECT (thiz, "failed to set config");
+    gst_object_unref (pool);
+    gst_object_unref (allocator);
+    return NULL;
+  }
+}
+
+/* function: 
+ *    Set the parameters of the allocator that allocates the output buffer.
+ *    The incoming query parameter contains information about the allocator
+ *    of downstream components. The default implementation of the parent class
+ *    needs to be called in the subclass implementation
+ */
+static gboolean gst_spacemitdec_decide_allocation(GstVideoDecoder *decoder, GstQuery *query)
+{
+	GstSpacemitDec *spacemitdec = GST_SPACEMITDEC(decoder);
+  GST_ERROR_OBJECT (spacemitdec, "@@@ ZRong ------------------------- in spacemitdec decide_allocation!");
+  GstBufferPool *pool;
+  guint size, min, max, i;
+  GstStructure *pool_config;
+  GstCaps *caps = NULL;
+  GstVideoInfo vinfo;
+
+  if (!GST_VIDEO_DECODER_CLASS(gst_spacemitdec_parent_class)->decide_allocation(decoder, query))
+    return FALSE;
+
+  /* Get the buffer pool config decided on by the base class. The base
+     class ensures that there will always be at least a 0th pool in
+     the query. */
+  gst_query_parse_nth_allocation_pool(query, 0, &pool, &size, &min, &max);
+  pool_config = gst_buffer_pool_get_config(pool);
+  gst_buffer_pool_config_get_params (pool_config, &caps, &size,
+      &min, &max);
+
+  GST_DEBUG_OBJECT (decoder, "get pool caps: %" GST_PTR_FORMAT, caps);
+  if (_gst_caps_has_feature (caps, GST_CAPS_FEATURE_MEMORY_DMABUF)) {
+    GST_INFO_OBJECT (decoder, "This spacemit decoder uses DMABuf memory");
+    spacemitdec->use_dmabuf = TRUE;
+  }
+
+  /* Decoder always use its own pool. */
+  if (!spacemitdec->pool) {
+    GstVideoCodecState *output_state =
+        gst_video_decoder_get_output_state (GST_VIDEO_DECODER (spacemitdec));
+    gst_clear_object (&spacemitdec->pool);
+    GST_INFO_OBJECT (decoder, "create new spacemitdec bufferpool");
+    spacemitdec->pool =
+      gst_spacemitdec_create_buffer_pool(spacemitdec, &output_state->info, (4 > min) ? 4 : min);
+    gst_video_codec_state_unref (output_state);
+    if (!spacemitdec->pool) {
+      GST_ERROR_OBJECT (decoder, "failed to create new pool");
+      goto failed_to_create_pool;
+    }
+  }
+  GST_DEBUG_OBJECT (spacemitdec,
+      "upstream provides the pool is: %" GST_PTR_FORMAT, pool);
+
+  /* If downstream supports video meta and video alignment,
+   * we can replace with our own spacemit bufferpool and use it
+   */
+#if 0
+  if (gst_buffer_pool_has_option (pool,
+          GST_BUFFER_POOL_OPTION_VIDEO_META)) {
+    GstStructure *config;
+    GstAllocator *allocator;
+
+    /* Remove downstream's pool */
+    gst_structure_free (pool_config);
+    gst_object_unref (pool);
+
+    pool = gst_object_ref (spacemitdec->pool);
+    /* Set the allocator of new spacemitdec bufferpool */
+    config = gst_buffer_pool_get_config (GST_BUFFER_POOL_CAST (pool));
+
+    if (gst_buffer_pool_config_get_allocator (config, &allocator, NULL))
+      gst_query_set_nth_allocation_param (query, 0, allocator, NULL);
+    gst_structure_free (config);
+
+    gst_query_set_nth_allocation_pool (query, 0, pool, size, min,
+        max);
+  } else {
+    goto no_support;
+  }
+#endif
+  if (pool)
+    gst_object_unref (pool);
+
+	return TRUE;
+
+failed_to_create_pool:
+  GST_ERROR_OBJECT (decoder, "failed to set buffer pool config");
+  if (pool)
+    gst_object_unref (pool);
+  return FALSE;
+
+no_support:
+  GST_ERROR_OBJECT (spacemitdec,
+      "error! upstream provides the strange pool: %" GST_PTR_FORMAT, pool);
+  if (pool)
+    gst_object_unref (pool);
+  return FALSE;
+}
+
+static GstStateChangeReturn
+gst_spacemitdec_dec_change_state (GstElement * element, GstStateChange transition)
+{
+  GstVideoDecoder *decoder = GST_VIDEO_DECODER (element);
+	GST_DEBUG("ZRong ------------------ in spacemitdec change state, %x", transition);
+
+  if (transition == GST_STATE_CHANGE_PAUSED_TO_READY) {
+    GST_VIDEO_DECODER_STREAM_LOCK (decoder);
+    if (!(gst_pad_get_task_state ((decoder)->srcpad) == GST_TASK_STARTED))
+      return TRUE;
+    
+    GST_DEBUG_OBJECT (decoder, "stopping decoding thread");
+    gst_pad_stop_task (decoder->srcpad);
+    GST_VIDEO_DECODER_STREAM_UNLOCK (decoder);
+  }
+
+  return GST_ELEMENT_CLASS (parent_class)->change_state (element, transition);
+}
+
+gboolean
+gst_spacemitdec_register (GstPlugin * plugin, guint rank)
+{
+  GST_DEBUG_CATEGORY_INIT (gst_spacemitdec_debug_category, "spacemitdec", 0,
+    "debug category for spacemitdec element");
+
+  return gst_element_register (plugin, "spacemitdec", rank,
+      GST_TYPE_SPACEMITDEC);
+}
+
diff --git a/ext/spacemit/spacemitcodec/gstspacemitenc.c b/ext/spacemit/spacemitcodec/gstspacemitenc.c
new file mode 100755
index 0000000..c1f2085
--- /dev/null
+++ b/ext/spacemit/spacemitcodec/gstspacemitenc.c
@@ -0,0 +1,862 @@
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+#include <stdio.h>
+
+#include "gstspacemitenc.h"
+
+#include <gst/gst.h>
+#include <gst/base/base.h>
+#include <gst/video/video.h>
+#include <gst/video/gstvideoencoder.h>
+#include <string.h>
+#define SPM_PENDING_MAX 5       /* Max number of MPP pending frame */
+
+GST_DEBUG_CATEGORY_STATIC (gst_spacemitenc_debug_category);
+#define GST_CAT_DEFAULT gst_spacemitenc_debug_category
+
+/* prototypes */
+static void gst_spacemitenc_set_property (GObject * object,
+    guint property_id, const GValue * value, GParamSpec * pspec);
+static void gst_spacemitenc_get_property (GObject * object,
+    guint property_id, GValue * value, GParamSpec * pspec);
+static void gst_spacemitenc_finalize (GObject * object);
+static gboolean gst_spacemitenc_start (GstVideoEncoder * encoder);
+static gboolean gst_spacemitenc_stop (GstVideoEncoder * encoder);
+static gboolean gst_spacemitenc_set_format (GstVideoEncoder * encoder,
+    GstVideoCodecState * state);
+static GstFlowReturn gst_spacemitenc_handle_frame (GstVideoEncoder * encoder,
+    GstVideoCodecFrame * frame);
+static GstFlowReturn gst_spacemitenc_finish (GstVideoEncoder * encoder);
+static gboolean gst_spacemitenc_propose_allocation (GstVideoEncoder * encoder,
+    GstQuery * query);
+
+#define DEFAULT_BITRATE            (128000)
+#define DEFAULT_GOP_SIZE           (90)
+#define DEFAULT_MAX_SLICE_SIZE     (1500000)
+#define START_FRAMERATE            30
+#define DEFAULT_MULTI_THREAD       0
+#define DEFAULT_ENABLE_DENOISE     FALSE
+#define DEFAULT_ENABLE_FRAME_SKIP  FALSE
+#define DEFAULT_BACKGROUND_DETECTION TRUE
+#define DEFAULT_ADAPTIVE_QUANTIZATION TRUE
+#define DEFAULT_SCENE_CHANGE_DETECTION TRUE
+#define DEFAULT_SLICE_MODE      GST_SPACEMIT_SLICE_MODE_N_SLICES
+#define DEFAULT_NUM_SLICES      1
+#define DEFAULT_QP_MIN             0
+#define DEFAULT_QP_MAX             51
+
+#define GST_SPM_ENC_EVENT_MUTEX(encoder) (&GST_SPACEMITENC (encoder)->event_mutex)
+#define GST_SPM_ENC_EVENT_COND(encoder) (&GST_SPACEMITENC (encoder)->event_cond)
+
+#define GST_SPM_ENC_BROADCAST(encoder) \
+  g_mutex_lock (GST_SPM_ENC_EVENT_MUTEX (encoder)); \
+  g_cond_broadcast (GST_SPM_ENC_EVENT_COND (encoder)); \
+  g_mutex_unlock (GST_SPM_ENC_EVENT_MUTEX (encoder));
+
+#define GST_SPM_ENC_WAIT(encoder, condition) \
+  g_mutex_lock (GST_SPM_ENC_EVENT_MUTEX (encoder)); \
+  while (!(condition)) \
+    g_cond_wait (GST_SPM_ENC_EVENT_COND (encoder), \
+        GST_SPM_ENC_EVENT_MUTEX (encoder)); \
+  g_mutex_unlock (GST_SPM_ENC_EVENT_MUTEX (encoder));
+
+enum
+{
+  PROP_0,
+  PROP_BITRATE,
+  PROP_MAX_BITRATE,
+  PROP_GOP_SIZE,
+  PROP_MAX_SLICE_SIZE,
+  PROP_MULTI_THREAD,
+  PROP_ENABLE_DENOISE,
+  PROP_ENABLE_FRAME_SKIP,
+  PROP_BACKGROUND_DETECTION,
+  PROP_ADAPTIVE_QUANTIZATION,
+  PROP_SCENE_CHANGE_DETECTION,
+  PROP_NUM_SLICES,
+  PROP_QP_MIN,
+  PROP_QP_MAX,
+  PROP_CODING_WIDTH,
+  PROP_CODING_HIGHT,
+  PROP_CODING_TYPE,
+  PROP_CODE_TYPE,
+  PROP_CODE_YUV_FORMAT,
+  N_PROPERTIES
+};
+
+/* pad templates */
+
+static GstStaticPadTemplate gst_spacemitenc_sink_template =
+GST_STATIC_PAD_TEMPLATE ("sink",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS (GST_VIDEO_CAPS_MAKE ("{I420, NV12, NV21}"))
+    );
+
+static GstStaticPadTemplate gst_spacemitenc_src_template =
+GST_STATIC_PAD_TEMPLATE ("src",
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS
+    (
+    "video/x-h264,"
+    "stream-format = (string) byte-stream,"
+    "alignment = (string)au,"
+    "width=(int) [1,MAX], " "height=(int) [1,MAX]"
+    ));
+
+/* class initialization */
+G_DEFINE_TYPE(GstSpacemitEnc, gst_spacemitenc, GST_TYPE_VIDEO_ENCODER);
+
+static void
+gst_spacemitenc_class_init (GstSpacemitEncClass * klass)
+{
+  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
+  GstVideoEncoderClass *video_encoder_class = GST_VIDEO_ENCODER_CLASS (klass);
+
+  gst_element_class_add_static_pad_template (GST_ELEMENT_CLASS (klass),
+      &gst_spacemitenc_src_template);
+  gst_element_class_add_static_pad_template (GST_ELEMENT_CLASS (klass),
+      &gst_spacemitenc_sink_template);
+
+  gst_element_class_set_static_metadata (GST_ELEMENT_CLASS (klass),
+      "Spacemit video encoder", "Encoder/Video", "Spacemit video encoder",
+      "ZRong, zhirong.li@spacemit.com");
+
+  gobject_class->set_property = gst_spacemitenc_set_property;
+  gobject_class->get_property = gst_spacemitenc_get_property;
+  gobject_class->finalize = gst_spacemitenc_finalize;
+  video_encoder_class->start = GST_DEBUG_FUNCPTR (gst_spacemitenc_start);
+  video_encoder_class->stop = GST_DEBUG_FUNCPTR (gst_spacemitenc_stop);
+  video_encoder_class->set_format =
+      GST_DEBUG_FUNCPTR (gst_spacemitenc_set_format);
+  video_encoder_class->handle_frame =
+      GST_DEBUG_FUNCPTR (gst_spacemitenc_handle_frame);
+  video_encoder_class->propose_allocation =
+      GST_DEBUG_FUNCPTR (gst_spacemitenc_propose_allocation);
+  video_encoder_class->finish = GST_DEBUG_FUNCPTR (gst_spacemitenc_finish);
+
+  /* define properties */
+  g_object_class_install_property (gobject_class, PROP_CODING_TYPE,
+      g_param_spec_uint ("coding-type", "coding type",
+          "Format to encode",
+          CODING_H264, CODING_FWHT, CODING_H264,
+          (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
+  g_object_class_install_property (gobject_class, PROP_CODE_TYPE,
+      g_param_spec_uint ("code-type", "code type",
+          "Codec selection to work",
+          CODEC_OPENH264, CODEC_V4L2, CODEC_SFOMX,
+          (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
+  g_object_class_install_property (gobject_class, PROP_CODING_WIDTH,
+      g_param_spec_uint ("coding-width", "coding width",
+          "image width to encode",
+          0, 3840, 1280,
+          (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
+  g_object_class_install_property (gobject_class, PROP_CODING_HIGHT,
+      g_param_spec_uint ("code-hight", "code hight",
+          "image hight to encode",
+          0, 2160, 720,
+          (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
+  g_object_class_install_property (gobject_class, PROP_CODE_YUV_FORMAT,
+      g_param_spec_uint ("code-yuv-format", "code yuv format",
+          "ENcode the yuv format",
+          PIXEL_FORMAT_UNKNOWN, PIXEL_FORMAT_MAX - 1, PIXEL_FORMAT_I420,
+          (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
+}
+
+static void
+gst_spacemitenc_init (GstSpacemitEnc * thiz)
+{
+  thiz->width = 1280;
+  thiz->height = 720;
+  thiz->eCodecType = CODEC_SFOMX;
+  thiz->eCodingType = CODING_H264;
+  thiz->PixelFormat = PIXEL_FORMAT_I420;
+  thiz->gop_size = DEFAULT_GOP_SIZE;
+  thiz->multi_thread = DEFAULT_MULTI_THREAD;
+  thiz->max_slice_size = DEFAULT_MAX_SLICE_SIZE;
+  thiz->bitrate = DEFAULT_BITRATE;
+  thiz->qp_min = DEFAULT_QP_MIN;
+  thiz->qp_max = DEFAULT_QP_MAX;
+  thiz->framerate = START_FRAMERATE;
+  thiz->input_state = NULL;
+  thiz->time_per_frame = GST_SECOND / thiz->framerate;
+  thiz->frame_count = 0;
+  thiz->previous_timestamp = 0;
+  thiz->enable_denoise = DEFAULT_ENABLE_DENOISE;
+  thiz->enable_frame_skip = DEFAULT_ENABLE_FRAME_SKIP;
+  thiz->background_detection = DEFAULT_BACKGROUND_DETECTION;
+  thiz->adaptive_quantization = DEFAULT_ADAPTIVE_QUANTIZATION;
+  thiz->scene_change_detection = DEFAULT_SCENE_CHANGE_DETECTION;
+  thiz->slice_mode = DEFAULT_SLICE_MODE;
+  thiz->num_slices = DEFAULT_NUM_SLICES;
+  thiz->bitrate_changed = FALSE;
+  thiz->max_bitrate_changed = FALSE;
+
+  thiz->ctx = NULL;
+  thiz->para = NULL;
+  thiz->mppframe = NULL;
+  thiz->mpppacket = NULL;
+}
+
+void
+gst_spacemitenc_set_property (GObject * object, guint property_id,
+    const GValue * value, GParamSpec * pspec)
+{
+  GstSpacemitEnc *thiz = GST_SPACEMITENC (object);
+
+  GST_DEBUG_OBJECT (thiz, "ZRong ------------------- set_property: %d", property_id);
+
+  switch (property_id) {
+    case PROP_BITRATE:
+      GST_OBJECT_LOCK (thiz);
+      if (thiz->bitrate != g_value_get_uint (value)) {
+        thiz->bitrate = g_value_get_uint (value);
+        thiz->bitrate_changed = TRUE;
+      }
+      GST_OBJECT_UNLOCK (thiz);
+      break;
+
+    case PROP_MAX_BITRATE:
+      GST_OBJECT_LOCK (thiz);
+      if (thiz->max_bitrate != g_value_get_uint (value)) {
+        thiz->max_bitrate = g_value_get_uint (value);
+        thiz->max_bitrate_changed = TRUE;
+      }
+      GST_OBJECT_UNLOCK (thiz);
+      break;
+
+    case PROP_QP_MIN:
+      thiz->qp_min = g_value_get_uint (value);
+      break;
+
+    case PROP_QP_MAX:
+      thiz->qp_max = g_value_get_uint (value);
+      break;
+
+    case PROP_MULTI_THREAD:
+      thiz->multi_thread = g_value_get_uint (value);
+      break;
+    case PROP_ENABLE_DENOISE:
+      thiz->enable_denoise = g_value_get_boolean (value);
+      break;
+
+    case PROP_ENABLE_FRAME_SKIP:
+      thiz->enable_frame_skip = g_value_get_boolean (value);
+      break;
+    case PROP_GOP_SIZE:
+      thiz->gop_size = g_value_get_uint (value);
+      GST_DEBUG_OBJECT (thiz, "ZRong ------------------- set_property: %d", thiz->gop_size);
+      break;
+
+    case PROP_MAX_SLICE_SIZE:
+      thiz->max_slice_size = g_value_get_uint (value);
+      break;
+    case PROP_BACKGROUND_DETECTION:
+      thiz->background_detection = g_value_get_boolean (value);
+      break;
+
+    case PROP_ADAPTIVE_QUANTIZATION:
+      thiz->adaptive_quantization = g_value_get_boolean (value);
+      break;
+
+    case PROP_SCENE_CHANGE_DETECTION:
+      thiz->scene_change_detection = g_value_get_boolean (value);
+      break;
+    case PROP_NUM_SLICES:
+      thiz->num_slices = g_value_get_uint (value);
+      break;
+    case PROP_CODING_WIDTH:
+      thiz->width = g_value_get_uint (value);
+      break;
+    case PROP_CODING_HIGHT:
+      thiz->height = g_value_get_uint (value);
+      break;
+    case PROP_CODING_TYPE:
+      thiz->eCodingType = g_value_get_uint (value);
+      break;    
+    case PROP_CODE_TYPE:
+      thiz->eCodecType = g_value_get_uint (value);
+      break;
+    case PROP_CODE_YUV_FORMAT:
+      thiz->PixelFormat = g_value_get_uint (value);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+      break;
+  }
+}
+
+void
+gst_spacemitenc_get_property (GObject * object, guint property_id,
+    GValue * value, GParamSpec * pspec)
+{
+  GstSpacemitEnc *thiz = GST_SPACEMITENC (object);
+
+  GST_DEBUG_OBJECT (thiz, "ZRong ------------------- get_property: %d", property_id);
+
+  switch (property_id) {
+    case PROP_BITRATE:
+      g_value_set_uint (value, thiz->bitrate);
+      break;
+
+    case PROP_MAX_BITRATE:
+      g_value_set_uint (value, thiz->max_bitrate);
+      break;
+
+    case PROP_QP_MIN:
+      g_value_set_uint (value, thiz->qp_min);
+      break;
+
+    case PROP_QP_MAX:
+      g_value_set_uint (value, thiz->qp_max);
+      break;
+
+    case PROP_ENABLE_DENOISE:
+      g_value_set_boolean (value, thiz->enable_denoise);
+      break;
+
+    case PROP_ENABLE_FRAME_SKIP:
+      g_value_set_boolean (value, thiz->enable_frame_skip);
+      break;
+
+    case PROP_MULTI_THREAD:
+      g_value_set_uint (value, thiz->multi_thread);
+      break;
+
+    case PROP_GOP_SIZE:
+      GST_DEBUG_OBJECT (thiz, "ZRong ------------------- gop_size: %d", thiz->gop_size);
+      g_value_set_uint (value, thiz->gop_size);
+      break;
+    case PROP_MAX_SLICE_SIZE:
+      g_value_set_uint (value, thiz->max_slice_size);
+      break;
+    case PROP_BACKGROUND_DETECTION:
+      g_value_set_boolean (value, thiz->background_detection);
+      break;
+    case PROP_ADAPTIVE_QUANTIZATION:
+      g_value_set_boolean (value, thiz->adaptive_quantization);
+      break;
+    case PROP_SCENE_CHANGE_DETECTION:
+      g_value_set_boolean (value, thiz->scene_change_detection);
+      break;
+    case PROP_NUM_SLICES:
+      g_value_set_uint (value, thiz->num_slices);
+      break;
+    case PROP_CODING_WIDTH:
+      g_value_set_uint (value, thiz->width);
+      break;
+    case PROP_CODING_HIGHT:
+      g_value_set_uint (value, thiz->height);
+      break;
+    case PROP_CODING_TYPE:
+      g_value_set_uint (value, thiz->eCodingType);
+      break;    
+    case PROP_CODE_TYPE:
+      g_value_set_uint (value, thiz->eCodecType);
+      break;
+    case PROP_CODE_YUV_FORMAT:
+      g_value_set_uint (value, thiz->PixelFormat);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+      break;
+  }
+}
+
+void
+gst_spacemitenc_finalize (GObject * object)
+{
+  GstSpacemitEnc *thiz = GST_SPACEMITENC (object);
+
+  GST_DEBUG_OBJECT (thiz, "finalize");
+
+  /* clean up object here */
+  if (thiz->input_state)
+    gst_video_codec_state_unref (thiz->input_state);
+
+  thiz->input_state = NULL;
+
+  G_OBJECT_CLASS (gst_spacemitenc_parent_class)->finalize (object);
+}
+FILE *fbbb;
+
+static gboolean
+gst_spacemitenc_start (GstVideoEncoder * encoder)
+{
+  int ret = 0;
+  GstSpacemitEnc *thiz = GST_SPACEMITENC (encoder);
+  GST_DEBUG_OBJECT (thiz, "start");
+
+  if(thiz->ctx)
+	{
+		VENC_DestoryChannel(thiz->ctx);
+		thiz->ctx = NULL;
+	}
+	thiz->ctx = VENC_CreateChannel();
+  thiz->ctx->eCodecType = thiz->eCodecType;
+
+  thiz->mpppacket = PACKET_Create ();
+  if (!thiz->mpppacket)
+    goto alloc_err;
+
+  thiz->mppframe = FRAME_Create ();
+  if (!thiz->mppframe)
+    goto alloc_err;
+
+  GST_ERROR_OBJECT (thiz, "ZRong ------------------------- finish start!!!");
+  g_mutex_init (&thiz->event_mutex);
+  g_cond_init (&thiz->event_cond);
+  thiz->pending_frames = 0;
+  fbbb = fopen("/tmp/out.yuv", "ab+");
+
+  return TRUE;
+
+alloc_err:
+  GST_ERROR_OBJECT (thiz, "can not alloc for mpp structure, please check !");
+  return FALSE;
+}
+
+static gboolean
+gst_spacemitenc_stop (GstVideoEncoder * encoder)
+{
+  GstSpacemitEnc *thiz = GST_SPACEMITENC (encoder);
+
+    GST_ERROR_OBJECT (thiz, "xxxxxxxxxxxxxx stop start");
+    fclose(fbbb);
+
+  if(thiz->ctx)
+	{
+		VENC_DestoryChannel(thiz->ctx);
+		thiz->ctx = NULL;
+	}
+  FRAME_Destory(thiz->mppframe);
+  PACKET_Destory(thiz->mpppacket);
+  VENC_DestoryChannel(thiz->ctx);
+
+  if (thiz->input_state) {
+    gst_video_codec_state_unref (thiz->input_state);
+  }
+  thiz->input_state = NULL;
+  if (!(gst_pad_get_task_state ((encoder)->srcpad) == GST_TASK_STARTED))
+    return TRUE;
+
+  GST_DEBUG_OBJECT (thiz, "spacemit_enc_stop called");
+
+  gst_pad_stop_task (encoder->srcpad);
+  g_cond_clear (&thiz->event_cond);
+  g_mutex_clear (&thiz->event_mutex);
+
+  return TRUE;
+}
+static void
+gst_spacemitenc_loop (GstVideoEncoder * encoder)
+{
+  GstVideoCodecFrame * frame = NULL;
+  GstSpacemitEnc *thiz = GST_SPACEMITENC (encoder);
+  int ret;
+  GstFlowReturn flow_status;
+  GstMapInfo map;
+  static int lenght = 0;
+
+  GST_SPM_ENC_WAIT (encoder, thiz->pending_frames || thiz->at_eos);
+  GST_VIDEO_ENCODER_STREAM_LOCK (encoder);
+
+  ret = VENC_RequestOutputStreamBuffer(thiz->ctx, PACKET_GetBaseData(thiz->mpppacket));
+  if (ret == MPP_CODER_NO_DATA)
+    goto sf_no_frame;
+  else if (ret == MPP_CODER_EOS)
+    goto finish_work;
+
+  frame = gst_video_encoder_get_oldest_frame (encoder);
+  if (!frame) {
+    GST_ERROR_OBJECT (thiz, "ZRong ------------------- finish last frame");
+    thiz->downstream_flow_ret = GST_FLOW_EOS;
+    GstBuffer *buffer;
+    buffer =
+        gst_buffer_new_wrapped (g_memdup (PACKET_GetDataPointer(thiz->mpppacket),
+            PACKET_GetLength(thiz->mpppacket)), PACKET_GetLength(thiz->mpppacket));
+    flow_status = gst_pad_push (GST_VIDEO_ENCODER_SRC_PAD (thiz), buffer);
+    GST_ERROR_OBJECT (thiz, "ZRong ------------------- finish last frame %d", flow_status);
+
+    VENC_ReturnOutputStreamBuffer (thiz->ctx, PACKET_GetBaseData(thiz->mpppacket));
+    goto done;
+  }
+  thiz->pending_frames--;
+  GST_SPM_ENC_BROADCAST (encoder);
+
+  //if (videoFrameTypeIDR == frame_info.eFrameType) {
+  //  GST_VIDEO_CODEC_FRAME_SET_SYNC_POINT (frame);
+  //} else {
+    GST_VIDEO_CODEC_FRAME_UNSET_SYNC_POINT (frame);
+  //}
+  frame->output_buffer =
+      gst_video_encoder_allocate_output_buffer (encoder, PACKET_GetLength(thiz->mpppacket));
+  gst_buffer_map (frame->output_buffer, &map, GST_MAP_WRITE);
+
+  lenght += PACKET_GetLength(thiz->mpppacket);
+  GST_ERROR_OBJECT (thiz, "ZRong ------------------- finish one frame, %d, %d", lenght, PACKET_GetLength(thiz->mpppacket));
+  memcpy (map.data, PACKET_GetDataPointer(thiz->mpppacket), PACKET_GetLength(thiz->mpppacket));
+
+  gst_buffer_unmap (frame->output_buffer, &map);
+  VENC_ReturnOutputStreamBuffer (thiz->ctx, PACKET_GetBaseData(thiz->mpppacket));
+
+  thiz->downstream_flow_ret = gst_video_encoder_finish_frame (encoder, frame);
+done:
+  GST_VIDEO_ENCODER_STREAM_UNLOCK (encoder);
+  return;
+
+sf_no_frame:
+{
+  GST_LOG_OBJECT (thiz,
+      "No out frame to request%d!", thiz->pending_frames);
+  thiz->downstream_flow_ret = GST_FLOW_OK;
+  goto done;
+}
+finish_work:
+{
+  GST_DEBUG_OBJECT (thiz,
+      "Get eos, Finished work and paused task!");
+  gst_pad_pause_task (GST_VIDEO_ENCODER_SRC_PAD (thiz));
+  thiz->downstream_flow_ret = GST_FLOW_EOS;
+  goto done;
+}
+
+}
+
+static MppPixelFormat gst_change_to_mpp_format(GstVideoFormat format)
+{
+  MppPixelFormat pixel;
+
+  switch (format) {
+    case GST_VIDEO_FORMAT_I420:
+      pixel = PIXEL_FORMAT_I420;
+      break;
+    case GST_VIDEO_FORMAT_NV21:
+      pixel = PIXEL_FORMAT_NV21;
+      break;
+    case GST_VIDEO_FORMAT_NV12:
+      pixel = PIXEL_FORMAT_NV12;
+      break;
+    default:
+      pixel = PIXEL_FORMAT_UNKNOWN;
+      break;
+  }
+  return pixel;
+}
+
+static MppCodingType
+gst_change_mpp_ecoding_type (GstStructure * s)
+{
+  if (gst_structure_has_name (s, "video/x-h264"))
+    return CODING_H264;
+
+  if (gst_structure_has_name (s, "video/x-h265"))
+    return CODING_H265;
+
+  return CODING_UNKNOWN;
+}
+static gboolean
+gst_spacemitenc_init_encoder (GstSpacemitEnc * thiz,
+  GstVideoCodecState * state, GstCaps *caps)
+{
+  guint width, height, fps_n, fps_d;
+  int stride0, stride1, stride2;
+  GstStructure *structure;
+  GstVideoFormat fmt;
+  gboolean ret = TRUE;
+
+  width = GST_VIDEO_INFO_WIDTH (&state->info);
+  height = GST_VIDEO_INFO_HEIGHT (&state->info);
+  fps_n = GST_VIDEO_INFO_FPS_N (&state->info);
+  fps_d = GST_VIDEO_INFO_FPS_D (&state->info);
+  stride0 = GST_VIDEO_INFO_PLANE_STRIDE (&state->info, 0);
+  stride1 = GST_VIDEO_INFO_PLANE_STRIDE (&state->info, 1);
+  stride2 = GST_VIDEO_INFO_PLANE_STRIDE (&state->info, 2);
+  fmt = GST_VIDEO_INFO_FORMAT (&state->info);
+
+  structure = gst_caps_get_structure (caps, 0);
+  thiz->eCodingType = gst_change_mpp_ecoding_type (structure);
+  if (thiz->eCodingType == CODING_UNKNOWN) {
+    GST_ERROR_OBJECT(thiz, "no support this eCodingType");
+    return FALSE;
+  }
+  thiz->PixelFormat = gst_change_to_mpp_format(fmt);
+  if(thiz->PixelFormat == PIXEL_FORMAT_UNKNOWN) {
+    GST_ERROR_OBJECT(thiz, "no support this PixelFormat output");
+    return FALSE;
+  }
+  GST_ERROR_OBJECT (thiz, "ZRong -------------------- init_encoder %d, %d (%d %d) (%d, %d)",
+    width, height, fps_n, fps_d, thiz->eCodingType, thiz->PixelFormat);
+
+  thiz->ctx->stVencPara.eCodingType = thiz->eCodingType;
+  thiz->ctx->stVencPara.nWidth = width;
+  thiz->ctx->stVencPara.nHeight = height;
+  thiz->ctx->stVencPara.PixelFormat = thiz->PixelFormat;
+  thiz->ctx->stVencPara.nBitrate = 5000000;
+  thiz->ctx->stVencPara.nFrameRate = fps_n;
+  thiz->ctx->stVencPara.nStride = width;
+
+  ret = VENC_Init(thiz->ctx);
+  if (ret)
+    goto init_err;
+
+  VENC_SetParam(thiz->ctx, &(thiz->ctx->stVencPara));
+
+  GST_ERROR_OBJECT (thiz, "ZRong ----------------------- set format %u, (%d %d %d) %s",
+    fmt, stride0, stride1, stride2, gst_video_format_to_string (fmt));
+
+  return TRUE;
+  
+init_err:
+  GST_ERROR_OBJECT (thiz, "Mpp vnec init error, please check !");
+  return FALSE;
+}
+
+
+static gboolean
+gst_spacemitenc_set_format (GstVideoEncoder * encoder,
+    GstVideoCodecState * state)
+{
+  GstSpacemitEnc *thiz = GST_SPACEMITENC (encoder);
+  GstCaps *outcaps;
+  GstCaps *caps;
+
+  GST_DEBUG_OBJECT (thiz, "ZRong ------------------------- start set format: %s",
+      gst_caps_to_string (state->caps));
+
+  if (thiz->input_state)
+    gst_video_codec_state_unref (thiz->input_state);
+
+  thiz->frame_count = 0;
+  thiz->input_state = gst_video_codec_state_ref (state);
+  outcaps =
+      gst_caps_copy (gst_static_pad_template_get_caps
+      (&gst_spacemitenc_src_template));
+
+  caps = gst_pad_peer_query_caps (encoder->srcpad, outcaps);
+  GST_DEBUG_OBJECT (thiz, "Returning caps %" GST_PTR_FORMAT, caps);
+
+  if (!gst_spacemitenc_init_encoder(thiz, state, caps))
+    return FALSE;
+
+  if (!gst_video_encoder_set_output_state (encoder, outcaps, state))
+    return FALSE;
+
+  if (!gst_video_encoder_negotiate (encoder))
+    return FALSE;    
+
+  if (!gst_pad_get_task_state ((encoder)->srcpad) == GST_TASK_STARTED) {
+    GST_DEBUG_OBJECT (thiz, "ZRong ------------------------- start enc thread");
+    gst_pad_start_task (encoder->srcpad,
+        (GstTaskFunction) gst_spacemitenc_loop, encoder, NULL);
+  }
+
+  return TRUE;
+}
+
+static gboolean
+gst_spacemitenc_propose_allocation (GstVideoEncoder * encoder, GstQuery * query)
+{
+  gst_query_add_allocation_meta (query, GST_VIDEO_META_API_TYPE, NULL);
+
+  return
+      GST_VIDEO_ENCODER_CLASS
+      (gst_spacemitenc_parent_class)->propose_allocation (encoder, query);
+}
+
+static GstFlowReturn
+gst_spacemitenc_handle_frame (GstVideoEncoder * encoder,
+    GstVideoCodecFrame * frame)
+{
+  GstSpacemitEnc *thiz = GST_SPACEMITENC (encoder);
+  GstVideoFrame video_frame;
+  gboolean force_keyframe;
+  gint ret;
+  gfloat fps;
+  gint i, j;
+  gsize buf_length = 0;
+  GstFlowReturn flow_ret;
+  GST_DEBUG_OBJECT (thiz, "ZRong ------------- start handle frame");
+
+  if (thiz->downstream_flow_ret != GST_FLOW_OK) {
+    goto downstream_err;
+  }
+
+  GST_OBJECT_LOCK (thiz);
+  if (thiz->bitrate_changed || thiz->max_bitrate_changed) {
+    GST_WARNING_OBJECT (thiz,
+        "Error need to support this cases");
+  }
+  GST_OBJECT_UNLOCK (thiz);
+
+  if (frame) {
+    thiz->frame_count++;
+    gst_video_frame_map (&video_frame, &thiz->input_state->info,
+        frame->input_buffer, GST_MAP_READ);
+    if (thiz->PixelFormat == PIXEL_FORMAT_I420) {
+      FRAME_SetDataUsedNum(thiz->mppframe, 3);
+      FRAME_SetDataPointer(thiz->mppframe, 0, GST_VIDEO_FRAME_PLANE_DATA (&video_frame, 0));
+      FRAME_SetDataPointer(thiz->mppframe, 1, GST_VIDEO_FRAME_PLANE_DATA (&video_frame, 1));
+      FRAME_SetDataPointer(thiz->mppframe, 2, GST_VIDEO_FRAME_PLANE_DATA (&video_frame, 2));
+    } else {
+      GST_DEBUG_OBJECT (thiz, "ZRong ------------- be save %s, %d, (%d, %d, %d)",
+        gst_video_format_to_string(GST_VIDEO_FRAME_FORMAT(&video_frame)),
+        GST_VIDEO_FRAME_N_PLANES(&video_frame), GST_VIDEO_FRAME_SIZE(&video_frame),
+        GST_VIDEO_FRAME_WIDTH(&video_frame), GST_VIDEO_FRAME_HEIGHT(&video_frame));
+
+      FRAME_SetDataUsedNum(thiz->mppframe, 2);
+      FRAME_SetDataPointer(thiz->mppframe, 0, GST_VIDEO_FRAME_PLANE_DATA (&video_frame, 0));
+      FRAME_SetDataPointer(thiz->mppframe, 1, GST_VIDEO_FRAME_PLANE_DATA (&video_frame, 1));
+#if 0
+      //SF_OMX_BUF_INFO *pBufInfo = pOMXBuffer->pOutputPortPrivate;
+      //LOG(SF_LOG_INFO, "%p %d %p\r\n", pOMXBuffer->pBuffer, pOMXBuffer->nFilledLen, pBufInfo->remap_vaddr);
+
+      fwrite(GST_VIDEO_FRAME_COMP_DATA (&video_frame, 0), 1, 1280*720, fbbb);
+      fwrite(GST_VIDEO_FRAME_COMP_DATA (&video_frame, 1), 1, 1280*720/2, fbbb);
+
+#endif
+
+    }
+  } else {
+    FRAME_SetEos(thiz->mppframe, 1);
+  }
+  GST_VIDEO_ENCODER_STREAM_UNLOCK (encoder);
+  ret = VENC_Encode(thiz->ctx, FRAME_GetBaseData(thiz->mppframe));
+  GST_VIDEO_ENCODER_STREAM_LOCK (encoder);
+  if (ret != 0) {
+    GST_ELEMENT_ERROR (thiz, STREAM, ENCODE,
+        ("Could not encode frame"), ("Spacemit returned %d", ret));
+    flow_ret = GST_FLOW_ERROR;
+    if (frame)
+      goto release_frame;
+    else
+      goto done;
+  }
+  if (!frame) 
+    goto flow_eos;
+
+  /* Avoid holding too much frames */
+  GST_VIDEO_ENCODER_STREAM_UNLOCK (encoder);
+  GST_SPM_ENC_WAIT (encoder, 
+    thiz->pending_frames < SPM_PENDING_MAX);
+  GST_VIDEO_ENCODER_STREAM_LOCK (encoder);
+  thiz->pending_frames++;
+  GST_SPM_ENC_BROADCAST (encoder);
+
+  flow_ret = thiz->downstream_flow_ret;
+  GST_DEBUG_OBJECT (thiz, "ZRong ------------- handle frame start: %d, %d", thiz->pending_frames, thiz->frame_count);
+
+  if (frame)
+    goto release_frame;
+
+done:
+  return flow_ret;
+downstream_err:
+{
+  GST_ERROR_OBJECT (thiz, "Downstream returned %s",
+      gst_flow_get_name (thiz->downstream_flow_ret));
+  flow_ret = thiz->downstream_flow_ret;
+  goto done;
+}
+release_frame:
+{
+  gst_video_frame_unmap (&video_frame);
+  gst_video_codec_frame_unref (frame);
+  goto done;
+}
+flow_eos:
+{
+  GST_DEBUG_OBJECT (thiz, "Get an eos, exit handle");
+  flow_ret = GST_FLOW_EOS;
+  goto done;
+}
+#if 0
+  /* FIXME: spacemit has no way for us to get a connection
+   * between the input and output frames, we just have to
+   * guess based on the input */
+  frame = gst_video_encoder_get_oldest_frame (encoder);
+  if (!frame) {
+    GST_ELEMENT_ERROR (thiz, STREAM, ENCODE,
+        ("Could not encode frame"), ("thiz returned %d", ret));
+    gst_video_codec_frame_unref (frame);
+    return GST_FLOW_ERROR;
+  }
+  ret = VENC_RequestOutputStreamBuffer(thiz->ctx, PACKET_GetBaseData(thiz->mpppacket));
+  if (ret) {
+    GST_ELEMENT_ERROR (thiz, STREAM, ENCODE,
+        ("Could not encode frame"), ("thiz returned %d", ret));
+    gst_video_codec_frame_unref (frame);
+    return GST_FLOW_ERROR;
+  }
+
+  if (videoFrameTypeIDR == frame_info.eFrameType) {
+    GST_VIDEO_CODEC_FRAME_SET_SYNC_POINT (frame);
+  } else {
+    GST_VIDEO_CODEC_FRAME_UNSET_SYNC_POINT (frame);
+  }
+
+  frame->output_buffer =
+      gst_video_encoder_allocate_output_buffer (encoder, PACKET_GetLength(thiz->mpppacket));
+  gst_buffer_map (frame->output_buffer, &map, GST_MAP_WRITE);
+
+  memcpy (map.data, PACKET_GetDataPointer(thiz->mpppacket), PACKET_GetLength(thiz->mpppacket));
+
+  gst_buffer_unmap (frame->output_buffer, &map);
+  VENC_ReturnOutputStreamBuffer (thiz->ctx, PACKET_GetBaseData(thiz->mpppacket));
+
+  GstFlowReturn flow_status = gst_video_encoder_finish_frame (encoder, frame);
+
+  GST_ERROR_OBJECT (thiz, "ZRong ----------------------- handle frame finish");
+
+  return flow_status;
+#endif
+}
+
+static GstFlowReturn
+gst_spacemitenc_finish (GstVideoEncoder * encoder)
+{
+  GstSpacemitEnc *thiz = GST_SPACEMITENC (encoder);
+
+  if (thiz->frame_count == 0)
+    return GST_FLOW_OK;
+
+  /* Drain encoder */
+  while ((gst_spacemitenc_handle_frame (encoder, NULL)) == GST_FLOW_OK);
+
+  GST_DEBUG_OBJECT(thiz, "finish test3");
+  thiz->at_eos = TRUE;
+
+  GST_SPM_ENC_BROADCAST (encoder);
+
+  GST_VIDEO_ENCODER_STREAM_UNLOCK (encoder);
+  /* Wait for task thread to pause */
+  GstTask *task = encoder->srcpad->task;
+  if (task) {
+    //GST_OBJECT_LOCK (task);
+    while (GST_TASK_STATE (task) == GST_TASK_STARTED) {
+      GST_DEBUG_OBJECT(thiz, "finish test4");
+      g_usleep(400 * 1000);
+      //GST_TASK_WAIT (task);
+    }
+    GST_DEBUG_OBJECT(thiz, "finish test5");
+    //GST_OBJECT_UNLOCK (task);
+  }
+  GST_VIDEO_ENCODER_STREAM_LOCK (encoder);
+
+  GST_DEBUG_OBJECT(thiz, "finish test2");
+
+  return GST_FLOW_OK;
+}
+
+gboolean
+gst_spacemitenc_register (GstPlugin * plugin, guint rank)
+{
+  GST_DEBUG_CATEGORY_INIT (gst_spacemitenc_debug_category, "spacemitenc", 0,
+          "debug category for spacemitenc element");
+
+  return gst_element_register (plugin, "spacemitenc", rank,
+      GST_TYPE_SPACEMITENC);
+}
+
diff --git a/ext/spacemit/spacemitcodec/gstspacemitenc.h b/ext/spacemit/spacemitcodec/gstspacemitenc.h
new file mode 100755
index 0000000..ef19791
--- /dev/null
+++ b/ext/spacemit/spacemitcodec/gstspacemitenc.h
@@ -0,0 +1,105 @@
+
+/*
+ * GstSpacemitEnc
+*/
+
+#ifndef _GST_SPACEMITENC_H_
+#define _GST_SPACEMITENC_H_
+
+#include <gst/video/video.h>
+#include <gst/video/gstvideoencoder.h>
+
+//#include <wels/codec_api.h>
+//#include <wels/codec_app_def.h>
+//#include <wels/codec_def.h>
+//#include <wels/codec_ver.h>
+
+#include <venc.h>
+
+G_BEGIN_DECLS
+
+typedef enum _GstSpacemitencDeblockingMode
+{
+  GST_SPACEMIT_DEBLOCKING_ON = 0,
+  GST_SPACEMIT_DEBLOCKING_OFF = 1,
+  GST_SPACEMIT_DEBLOCKING_NOT_SLICE_BOUNDARIES = 2
+} GstSpacemitencDeblockingMode;
+
+typedef enum
+{
+  GST_SPACEMIT_SLICE_MODE_N_SLICES = 1,  /* SM_FIXEDSLCNUM_SLICE */
+  GST_SPACEMIT_SLICE_MODE_AUTO = 5       /* former SM_AUTO_SLICE */
+} GstSpacemitEncSliceMode;
+
+#define GST_TYPE_SPACEMITENC          (gst_spacemitenc_get_type())
+#define GST_SPACEMITENC(obj)          (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SPACEMITENC,GstSpacemitEnc))
+#define GST_SPACEMITENC_CLASS(klass)  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SPACEMITENC,GstSpacemitEncClass))
+#define GST_IS_SPACEMITENC(obj)       (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SPACEMITENC))
+#define GST_IS_SPACEMITENC_CLASS(obj) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SPACEMITENC))
+
+//#define GST_MPP_ENC(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj), \
+//    GST_TYPE_SPACEMITENC, GstSpacemitEnc))
+
+typedef struct _GstSpacemitEnc GstSpacemitEnc;
+typedef struct _GstSpacemitEncClass GstSpacemitEncClass;
+
+struct _GstSpacemitEnc
+{
+  GstVideoEncoder base_spacemitenc;
+
+  /*< private >*/
+  //ISVCEncoder *encoder;
+//  EUsageType usage_type;
+  guint gop_size;
+//  RC_MODES rate_control;
+  guint max_slice_size;
+  guint bitrate;
+  guint max_bitrate;
+  guint qp_min;
+  guint qp_max;
+  guint framerate;
+  guint multi_thread;
+  gboolean enable_denoise;
+  gboolean enable_frame_skip;
+  GstVideoCodecState *input_state;
+  guint64 time_per_frame;
+  guint64 frame_count;
+  guint64 previous_timestamp;
+  GstSpacemitencDeblockingMode deblocking_mode;
+  gboolean background_detection;
+  gboolean adaptive_quantization;
+  gboolean scene_change_detection;
+  GstSpacemitEncSliceMode slice_mode;
+  guint num_slices;
+//  ECOMPLEXITY_MODE complexity;
+  gboolean bitrate_changed;
+  gboolean max_bitrate_changed;
+
+//  GMutex mutex;
+	guint width;
+  guint height;
+	guint eCodecType;
+  guint eCodingType;
+  GMutex event_mutex;
+  GCond event_cond;
+  MppPixelFormat  PixelFormat;
+  GstFlowReturn downstream_flow_ret;
+  guint pending_frames;
+  gboolean at_eos;
+  MppVencCtx *ctx;
+	MppVencPara *para;
+	MppPacket *mpppacket;
+	MppFrame *mppframe;
+};
+
+struct _GstSpacemitEncClass
+{
+    GstVideoEncoderClass base_spacemitenc_class;
+};
+
+GType gst_spacemitenc_get_type(void);
+gboolean
+gst_spacemitenc_register (GstPlugin * plugin, guint rank);
+
+G_END_DECLS
+#endif
diff --git a/ext/spacemit/spacemitcodec/gstspacemitenc_bak.c b/ext/spacemit/spacemitcodec/gstspacemitenc_bak.c
new file mode 100755
index 0000000..dff86f9
--- /dev/null
+++ b/ext/spacemit/spacemitcodec/gstspacemitenc_bak.c
@@ -0,0 +1,1022 @@
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+#include <stdio.h>
+
+#include "gstspacemitenc.h"
+
+#include <gst/gst.h>
+#include <gst/base/base.h>
+#include <gst/video/video.h>
+#include <gst/video/gstvideoencoder.h>
+#include <string.h>
+#define SPM_PENDING_MAX 8       /* Max number of MPP pending frame */
+
+GST_DEBUG_CATEGORY_STATIC (gst_spacemitenc_debug_category);
+#define GST_CAT_DEFAULT gst_spacemitenc_debug_category
+
+/* FIXME: we should not really directly use the enums from the spacemit API
+ * here, since it might change or be removed */
+/*
+#define GST_TYPE_USAGE_TYPE (gst_spacemitenc_usage_type_get_type ())
+static GType
+gst_spacemitenc_usage_type_get_type (void)
+{
+  static GType usage_type = 0;
+
+  if (!usage_type) {
+    static const GEnumValue usage_types[] = {
+      {CAMERA_VIDEO_REAL_TIME, "video from camera", "camera"},
+      {SCREEN_CONTENT_REAL_TIME, "screen content", "screen"},
+      {0, NULL, NULL},
+    };
+
+    usage_type = g_enum_register_static ("EUsageType", usage_types);
+  }
+
+  return usage_type;
+}
+*/
+/*
+#define GST_TYPE_RC_MODES (gst_spacemitenc_rc_modes_get_type ())
+static GType
+gst_spacemitenc_rc_modes_get_type (void)
+{
+  static GType rc_modes_type = 0;
+
+  if (!rc_modes_type) {
+    static const GEnumValue rc_modes_types[] = {
+      {RC_QUALITY_MODE, "Quality mode", "quality"},
+      {RC_BITRATE_MODE, "Bitrate mode", "bitrate"},
+      {RC_BUFFERBASED_MODE, "No bitrate control, just using buffer status",
+          "buffer"},
+      {RC_OFF_MODE, "Rate control off mode", "off"},
+      {0, NULL, NULL},
+    };
+
+    rc_modes_type = g_enum_register_static ("RC_MODES", rc_modes_types);
+  }
+
+  return rc_modes_type;
+}
+*/
+/*
+#define GST_TYPE_SPACEMITENC_DEBLOCKING_MODE (gst_spacemitenc_deblocking_mode_get_type ())
+static GType
+gst_spacemitenc_deblocking_mode_get_type (void)
+{
+  static const GEnumValue types[] = {
+    {GST_SPACEMIT_DEBLOCKING_ON, "Deblocking on", "on"},
+    {GST_SPACEMIT_DEBLOCKING_OFF, "Deblocking off", "off"},
+    {GST_SPACEMIT_DEBLOCKING_NOT_SLICE_BOUNDARIES,
+        "Deblocking on, except for slice boundaries", "not-slice-boundaries"},
+    {0, NULL, NULL},
+  };
+  static gsize id = 0;
+
+  if (g_once_init_enter (&id)) {
+    GType _id = g_enum_register_static ("GstSpacemitencDeblockingModes", types);
+    g_once_init_leave (&id, _id);
+  }
+
+  return (GType) id;
+}
+*/
+/*
+#define GST_TYPE_SPACEMITENC_SLICE_MODE (gst_spacemitenc_slice_mode_get_type ())
+static GType
+gst_spacemitenc_slice_mode_get_type (void)
+{
+  static const GEnumValue types[] = {
+    {GST_SPACEMIT_SLICE_MODE_N_SLICES, "Fixed number of slices", "n-slices"},
+    {GST_SPACEMIT_SLICE_MODE_AUTO,
+        "Number of slices equal to number of threads", "auto"},
+    {0, NULL, NULL},
+  };
+  static gsize id = 0;
+
+  if (g_once_init_enter (&id)) {
+    GType _id = g_enum_register_static ("GstSpacemitEncSliceModes", types);
+    g_once_init_leave (&id, _id);
+  }
+
+  return (GType) id;
+}
+*/
+/*
+#define GST_TYPE_SPACEMITENC_COMPLEXITY (gst_spacemitenc_complexity_get_type ())
+static GType
+gst_spacemitenc_complexity_get_type (void)
+{
+  static const GEnumValue types[] = {
+    {LOW_COMPLEXITY, "Low complexity / high speed encoding", "low"},
+    {MEDIUM_COMPLEXITY, "Medium complexity / medium speed encoding", "medium"},
+    {HIGH_COMPLEXITY, "High complexity / low speed encoding", "high"},
+    {0, NULL, NULL},
+  };
+  static gsize id = 0;
+
+  if (g_once_init_enter (&id)) {
+    GType _id = g_enum_register_static ("GstSpacemitencComplexity", types);
+    g_once_init_leave (&id, _id);
+  }
+
+  return (GType) id;
+}
+*/
+/* prototypes */
+
+static void gst_spacemitenc_set_property (GObject * object,
+    guint property_id, const GValue * value, GParamSpec * pspec);
+static void gst_spacemitenc_get_property (GObject * object,
+    guint property_id, GValue * value, GParamSpec * pspec);
+static void gst_spacemitenc_finalize (GObject * object);
+static gboolean gst_spacemitenc_start (GstVideoEncoder * encoder);
+static gboolean gst_spacemitenc_stop (GstVideoEncoder * encoder);
+static gboolean gst_spacemitenc_set_format (GstVideoEncoder * encoder,
+    GstVideoCodecState * state);
+static GstFlowReturn gst_spacemitenc_handle_frame (GstVideoEncoder * encoder,
+    GstVideoCodecFrame * frame);
+static GstFlowReturn gst_spacemitenc_finish (GstVideoEncoder * encoder);
+static gboolean gst_spacemitenc_propose_allocation (GstVideoEncoder * encoder,
+    GstQuery * query);
+
+#define DEFAULT_BITRATE            (128000)
+//#define DEFAULT_MAX_BITRATE        (UNSPECIFIED_BIT_RATE)
+#define DEFAULT_GOP_SIZE           (90)
+#define DEFAULT_MAX_SLICE_SIZE     (1500000)
+#define START_FRAMERATE            30
+//#define DEFAULT_USAGE_TYPE         CAMERA_VIDEO_REAL_TIME
+//#define DEFAULT_RATE_CONTROL       RC_QUALITY_MODE
+#define DEFAULT_MULTI_THREAD       0
+#define DEFAULT_ENABLE_DENOISE     FALSE
+#define DEFAULT_ENABLE_FRAME_SKIP  FALSE
+//#define DEFAULT_DEBLOCKING_MODE GST_SPACEMIT_DEBLOCKING_ON
+#define DEFAULT_BACKGROUND_DETECTION TRUE
+#define DEFAULT_ADAPTIVE_QUANTIZATION TRUE
+#define DEFAULT_SCENE_CHANGE_DETECTION TRUE
+#define DEFAULT_SLICE_MODE      GST_SPACEMIT_SLICE_MODE_N_SLICES
+#define DEFAULT_NUM_SLICES      1
+//#define DEFAULT_COMPLEXITY      MEDIUM_COMPLEXITY
+#define DEFAULT_QP_MIN             0
+#define DEFAULT_QP_MAX             51
+
+#define GST_SPM_ENC_EVENT_MUTEX(encoder) (&GST_SPACEMITENC (encoder)->event_mutex)
+#define GST_SPM_ENC_EVENT_COND(encoder) (&GST_SPACEMITENC (encoder)->event_cond)
+
+#define GST_SPM_ENC_BROADCAST(encoder) \
+  g_mutex_lock (GST_SPM_ENC_EVENT_MUTEX (encoder)); \
+  g_cond_broadcast (GST_SPM_ENC_EVENT_COND (encoder)); \
+  g_mutex_unlock (GST_SPM_ENC_EVENT_MUTEX (encoder));
+
+#define GST_SPM_ENC_WAIT(encoder, condition) \
+  g_mutex_lock (GST_SPM_ENC_EVENT_MUTEX (encoder)); \
+  while (!(condition)) \
+    g_cond_wait (GST_SPM_ENC_EVENT_COND (encoder), \
+        GST_SPM_ENC_EVENT_MUTEX (encoder)); \
+  g_mutex_unlock (GST_SPM_ENC_EVENT_MUTEX (encoder));
+
+enum
+{
+  PROP_0,
+  //PROP_USAGE_TYPE,
+  PROP_BITRATE,
+  PROP_MAX_BITRATE,
+  PROP_GOP_SIZE,
+  PROP_MAX_SLICE_SIZE,
+  //PROP_RATE_CONTROL,
+  PROP_MULTI_THREAD,
+  PROP_ENABLE_DENOISE,
+  PROP_ENABLE_FRAME_SKIP,
+  //PROP_DEBLOCKING_MODE,
+  PROP_BACKGROUND_DETECTION,
+  PROP_ADAPTIVE_QUANTIZATION,
+  PROP_SCENE_CHANGE_DETECTION,
+  //PROP_SLICE_MODE,
+  PROP_NUM_SLICES,
+  //PROP_COMPLEXITY,
+  PROP_QP_MIN,
+  PROP_QP_MAX,
+  PROP_CODING_WIDTH,
+  PROP_CODING_HIGHT,
+  PROP_CODING_TYPE,
+  PROP_CODE_TYPE,
+  PROP_CODE_YUV_FORMAT,
+  N_PROPERTIES
+};
+
+/* pad templates */
+
+static GstStaticPadTemplate gst_spacemitenc_sink_template =
+GST_STATIC_PAD_TEMPLATE ("sink",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS (GST_VIDEO_CAPS_MAKE ("{I420, NV12, NV21}"))
+    );
+#if 0
+static GstStaticPadTemplate gst_spacemitenc_src_template =
+GST_STATIC_PAD_TEMPLATE ("src",
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS
+    ("video/x-h264, stream-format=(string)\"byte-stream\", alignment=(string)\"au\", profile=(string)\"baseline\""
+    ";"
+    "video/x-h265,"
+    "stream-format = (string) byte-stream,"
+    "alignment = (string)au,"
+    "width=(int) [1,MAX], " "height=(int) [1,MAX]"
+    ));
+#else
+static GstStaticPadTemplate gst_spacemitenc_src_template =
+GST_STATIC_PAD_TEMPLATE ("src",
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS
+    (
+    "video/x-h265,"
+    "stream-format = (string) byte-stream,"
+    "alignment = (string)au,"
+    "width=(int) [1,MAX], " "height=(int) [1,MAX]"
+    ));
+
+#endif
+/* class initialization */
+
+G_DEFINE_TYPE_WITH_CODE (GstSpacemitEnc, gst_spacemitenc,
+    GST_TYPE_VIDEO_ENCODER,
+    G_IMPLEMENT_INTERFACE (GST_TYPE_PRESET, NULL);
+    GST_DEBUG_CATEGORY_INIT (gst_spacemitenc_debug_category, "spacemitenc", 0,
+        "debug category for spacemitenc element"));
+
+static void
+gst_spacemitenc_class_init (GstSpacemitEncClass * klass)
+{
+  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
+  GstVideoEncoderClass *video_encoder_class = GST_VIDEO_ENCODER_CLASS (klass);
+
+  /* Setting up pads and setting metadata should be moved to
+     base_class_init if you intend to subclass this class. */
+  gst_element_class_add_static_pad_template (GST_ELEMENT_CLASS (klass),
+      &gst_spacemitenc_src_template);
+  gst_element_class_add_static_pad_template (GST_ELEMENT_CLASS (klass),
+      &gst_spacemitenc_sink_template);
+
+  gst_element_class_set_static_metadata (GST_ELEMENT_CLASS (klass),
+      "Spacemit video encoder", "Encoder/Video", "Spacemit video encoder",
+      "David, qiang.fu@spacemit.com");
+
+  gobject_class->set_property = gst_spacemitenc_set_property;
+  gobject_class->get_property = gst_spacemitenc_get_property;
+  gobject_class->finalize = gst_spacemitenc_finalize;
+  video_encoder_class->start = GST_DEBUG_FUNCPTR (gst_spacemitenc_start);
+  video_encoder_class->stop = GST_DEBUG_FUNCPTR (gst_spacemitenc_stop);
+  video_encoder_class->set_format =
+      GST_DEBUG_FUNCPTR (gst_spacemitenc_set_format);
+  video_encoder_class->handle_frame =
+      GST_DEBUG_FUNCPTR (gst_spacemitenc_handle_frame);
+  video_encoder_class->propose_allocation =
+      GST_DEBUG_FUNCPTR (gst_spacemitenc_propose_allocation);
+  video_encoder_class->finish = GST_DEBUG_FUNCPTR (gst_spacemitenc_finish);
+
+  /* define properties */
+  g_object_class_install_property (gobject_class, PROP_GOP_SIZE,
+      g_param_spec_uint ("gop-size", "GOP size",
+          "Number of frames between intra frames",
+          0, G_MAXUINT, DEFAULT_GOP_SIZE,
+          (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
+  g_object_class_install_property (gobject_class, PROP_CODING_TYPE,
+      g_param_spec_uint ("coding-type", "coding type",
+          "Format to encode",
+          CODING_H264, CODING_FWHT, CODING_H264,
+          (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
+  g_object_class_install_property (gobject_class, PROP_CODE_TYPE,
+      g_param_spec_uint ("code-type", "code type",
+          "Codec selection to work",
+          CODEC_OPENH264, CODEC_V4L2, CODEC_SFOMX,
+          (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
+  g_object_class_install_property (gobject_class, PROP_CODING_WIDTH,
+      g_param_spec_uint ("coding-width", "coding width",
+          "image width to encode",
+          0, 3840, 1280,
+          (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
+  g_object_class_install_property (gobject_class, PROP_CODING_HIGHT,
+      g_param_spec_uint ("code-hight", "code hight",
+          "image hight to encode",
+          0, 2160, 720,
+          (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
+  g_object_class_install_property (gobject_class, PROP_CODE_YUV_FORMAT,
+      g_param_spec_uint ("code-yuv-format", "code yuv format",
+          "ENcode the yuv format",
+          PIXEL_FORMAT_DEFAULT, PIXEL_FORMAT_UNKNOWN-1, PIXEL_FORMAT_I420,
+          (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
+}
+
+static void
+gst_spacemitenc_init (GstSpacemitEnc * spacemitenc)
+{
+  spacemitenc->width = 1280;
+  spacemitenc->height = 720;
+  spacemitenc->eCodecType = CODEC_SFOMX;
+  spacemitenc->eCodingType = CODING_H264;
+  spacemitenc->PixelFormat = PIXEL_FORMAT_I420;
+  spacemitenc->gop_size = DEFAULT_GOP_SIZE;
+//  spacemitenc->usage_type = DEFAULT_USAGE_TYPE;
+//  spacemitenc->rate_control = DEFAULT_RATE_CONTROL;
+  spacemitenc->multi_thread = DEFAULT_MULTI_THREAD;
+  spacemitenc->max_slice_size = DEFAULT_MAX_SLICE_SIZE;
+  spacemitenc->bitrate = DEFAULT_BITRATE;
+//  spacemitenc->max_bitrate = DEFAULT_MAX_BITRATE;
+  spacemitenc->qp_min = DEFAULT_QP_MIN;
+  spacemitenc->qp_max = DEFAULT_QP_MAX;
+  spacemitenc->framerate = START_FRAMERATE;
+  spacemitenc->input_state = NULL;
+  spacemitenc->time_per_frame = GST_SECOND / spacemitenc->framerate;
+  spacemitenc->frame_count = 0;
+  spacemitenc->previous_timestamp = 0;
+  spacemitenc->enable_denoise = DEFAULT_ENABLE_DENOISE;
+  spacemitenc->enable_frame_skip = DEFAULT_ENABLE_FRAME_SKIP;
+//  spacemitenc->deblocking_mode = DEFAULT_DEBLOCKING_MODE;
+  spacemitenc->background_detection = DEFAULT_BACKGROUND_DETECTION;
+  spacemitenc->adaptive_quantization = DEFAULT_ADAPTIVE_QUANTIZATION;
+  spacemitenc->scene_change_detection = DEFAULT_SCENE_CHANGE_DETECTION;
+  spacemitenc->slice_mode = DEFAULT_SLICE_MODE;
+  spacemitenc->num_slices = DEFAULT_NUM_SLICES;
+  //spacemitenc->encoder = NULL;
+//  spacemitenc->complexity = DEFAULT_COMPLEXITY;
+  spacemitenc->bitrate_changed = FALSE;
+  spacemitenc->max_bitrate_changed = FALSE;
+
+  spacemitenc->ctx = NULL;
+  spacemitenc->para = NULL;
+  spacemitenc->mppframe = NULL;
+  spacemitenc->mpppacket = NULL;
+
+//  gst_spacemitenc_set_usage_type (spacemitenc, CAMERA_VIDEO_REAL_TIME);
+//  gst_spacemitenc_set_rate_control (spacemitenc, RC_QUALITY_MODE);
+}
+
+void
+gst_spacemitenc_set_property (GObject * object, guint property_id,
+    const GValue * value, GParamSpec * pspec)
+{
+  GstSpacemitEnc *spacemitenc = GST_SPACEMITENC (object);
+
+  GST_DEBUG_OBJECT (spacemitenc, "ZRong ------------------- set_property: %d", property_id);
+
+  switch (property_id) {
+    case PROP_BITRATE:
+      GST_OBJECT_LOCK (spacemitenc);
+      if (spacemitenc->bitrate != g_value_get_uint (value)) {
+        spacemitenc->bitrate = g_value_get_uint (value);
+        spacemitenc->bitrate_changed = TRUE;
+      }
+      GST_OBJECT_UNLOCK (spacemitenc);
+      break;
+
+    case PROP_MAX_BITRATE:
+      GST_OBJECT_LOCK (spacemitenc);
+      if (spacemitenc->max_bitrate != g_value_get_uint (value)) {
+        spacemitenc->max_bitrate = g_value_get_uint (value);
+        spacemitenc->max_bitrate_changed = TRUE;
+      }
+      GST_OBJECT_UNLOCK (spacemitenc);
+      break;
+
+    case PROP_QP_MIN:
+      spacemitenc->qp_min = g_value_get_uint (value);
+      break;
+
+    case PROP_QP_MAX:
+      spacemitenc->qp_max = g_value_get_uint (value);
+      break;
+
+    case PROP_MULTI_THREAD:
+      spacemitenc->multi_thread = g_value_get_uint (value);
+      break;
+/*
+    case PROP_USAGE_TYPE:
+      gst_spacemitenc_set_usage_type (spacemitenc, g_value_get_enum (value));
+      break;
+*/
+    case PROP_ENABLE_DENOISE:
+      spacemitenc->enable_denoise = g_value_get_boolean (value);
+      break;
+
+    case PROP_ENABLE_FRAME_SKIP:
+      spacemitenc->enable_frame_skip = g_value_get_boolean (value);
+      break;
+/*
+    case PROP_RATE_CONTROL:
+      gst_spacemitenc_set_rate_control (spacemitenc, g_value_get_enum (value));
+      break;
+*/
+    case PROP_GOP_SIZE:
+      spacemitenc->gop_size = g_value_get_uint (value);
+      GST_DEBUG_OBJECT (spacemitenc, "ZRong ------------------- set_property: %d", spacemitenc->gop_size);
+      break;
+
+    case PROP_MAX_SLICE_SIZE:
+      spacemitenc->max_slice_size = g_value_get_uint (value);
+      break;
+/*
+    case PROP_DEBLOCKING_MODE:
+      spacemitenc->deblocking_mode =
+          (GstSpacemitencDeblockingMode) g_value_get_enum (value);
+      break;
+*/
+    case PROP_BACKGROUND_DETECTION:
+      spacemitenc->background_detection = g_value_get_boolean (value);
+      break;
+
+    case PROP_ADAPTIVE_QUANTIZATION:
+      spacemitenc->adaptive_quantization = g_value_get_boolean (value);
+      break;
+
+    case PROP_SCENE_CHANGE_DETECTION:
+      spacemitenc->scene_change_detection = g_value_get_boolean (value);
+      break;
+/*
+    case PROP_SLICE_MODE:
+      spacemitenc->slice_mode =
+          (GstSpacemitEncSliceMode) g_value_get_enum (value);
+      break;
+*/
+    case PROP_NUM_SLICES:
+      spacemitenc->num_slices = g_value_get_uint (value);
+      break;
+    case PROP_CODING_WIDTH:
+      spacemitenc->width = g_value_get_uint (value);
+      break;
+    case PROP_CODING_HIGHT:
+      spacemitenc->height = g_value_get_uint (value);
+      break;
+    case PROP_CODING_TYPE:
+      spacemitenc->eCodingType = g_value_get_uint (value);
+      break;    
+    case PROP_CODE_TYPE:
+      spacemitenc->eCodecType = g_value_get_uint (value);
+      break;
+    case PROP_CODE_YUV_FORMAT:
+      spacemitenc->PixelFormat = g_value_get_uint (value);
+      break;
+
+/*
+    case PROP_COMPLEXITY:
+      spacemitenc->complexity = (ECOMPLEXITY_MODE) g_value_get_enum (value);
+      break;
+*/
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+      break;
+  }
+}
+
+void
+gst_spacemitenc_get_property (GObject * object, guint property_id,
+    GValue * value, GParamSpec * pspec)
+{
+  GstSpacemitEnc *spacemitenc = GST_SPACEMITENC (object);
+
+  GST_DEBUG_OBJECT (spacemitenc, "ZRong ------------------- get_property: %d", property_id);
+
+  switch (property_id) {
+    /*
+    case PROP_USAGE_TYPE:
+      g_value_set_enum (value, spacemitenc->usage_type);
+      break;
+    */
+    /*
+    case PROP_RATE_CONTROL:
+      g_value_set_enum (value, spacemitenc->rate_control);
+      break;
+    */
+    case PROP_BITRATE:
+      g_value_set_uint (value, spacemitenc->bitrate);
+      break;
+
+    case PROP_MAX_BITRATE:
+      g_value_set_uint (value, spacemitenc->max_bitrate);
+      break;
+
+    case PROP_QP_MIN:
+      g_value_set_uint (value, spacemitenc->qp_min);
+      break;
+
+    case PROP_QP_MAX:
+      g_value_set_uint (value, spacemitenc->qp_max);
+      break;
+
+    case PROP_ENABLE_DENOISE:
+      g_value_set_boolean (value, spacemitenc->enable_denoise);
+      break;
+
+    case PROP_ENABLE_FRAME_SKIP:
+      g_value_set_boolean (value, spacemitenc->enable_frame_skip);
+      break;
+
+    case PROP_MULTI_THREAD:
+      g_value_set_uint (value, spacemitenc->multi_thread);
+      break;
+
+    case PROP_GOP_SIZE:
+      GST_DEBUG_OBJECT (spacemitenc, "ZRong ------------------- gop_size: %d", spacemitenc->gop_size);
+      g_value_set_uint (value, spacemitenc->gop_size);
+      break;
+
+    case PROP_MAX_SLICE_SIZE:
+      g_value_set_uint (value, spacemitenc->max_slice_size);
+      break;
+    /*
+    case PROP_DEBLOCKING_MODE:
+      g_value_set_enum (value, spacemitenc->deblocking_mode);
+      break;
+    */
+    case PROP_BACKGROUND_DETECTION:
+      g_value_set_boolean (value, spacemitenc->background_detection);
+      break;
+
+    case PROP_ADAPTIVE_QUANTIZATION:
+      g_value_set_boolean (value, spacemitenc->adaptive_quantization);
+      break;
+
+    case PROP_SCENE_CHANGE_DETECTION:
+      g_value_set_boolean (value, spacemitenc->scene_change_detection);
+      break;
+    /*
+    case PROP_SLICE_MODE:
+      g_value_set_enum (value, spacemitenc->slice_mode);
+      break;
+    */
+    case PROP_NUM_SLICES:
+      g_value_set_uint (value, spacemitenc->num_slices);
+      break;
+    case PROP_CODING_WIDTH:
+      g_value_set_uint (value, spacemitenc->width);
+      break;
+    case PROP_CODING_HIGHT:
+      g_value_set_uint (value, spacemitenc->height);
+      break;
+    case PROP_CODING_TYPE:
+      g_value_set_uint (value, spacemitenc->eCodingType);
+      break;    
+    case PROP_CODE_TYPE:
+      g_value_set_uint (value, spacemitenc->eCodecType);
+      break;
+    case PROP_CODE_YUV_FORMAT:
+      g_value_set_uint (value, spacemitenc->PixelFormat);
+      break;
+
+    /*
+    case PROP_COMPLEXITY:
+      g_value_set_enum (value, spacemitenc->complexity);
+      break;
+    */
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+      break;
+  }
+}
+
+void
+gst_spacemitenc_finalize (GObject * object)
+{
+  GstSpacemitEnc *spacemitenc = GST_SPACEMITENC (object);
+
+  GST_DEBUG_OBJECT (spacemitenc, "finalize");
+
+  /* clean up object here */
+
+  if (spacemitenc->input_state) {
+    gst_video_codec_state_unref (spacemitenc->input_state);
+  }
+  spacemitenc->input_state = NULL;
+
+  G_OBJECT_CLASS (gst_spacemitenc_parent_class)->finalize (object);
+}
+FILE *fbbb;
+
+
+static gboolean
+gst_spacemitenc_start (GstVideoEncoder * encoder)
+{
+  int ret = 0;
+  GstSpacemitEnc *spacemitenc = GST_SPACEMITENC (encoder);
+  GST_DEBUG_OBJECT (spacemitenc, "start");
+
+  if(spacemitenc->ctx)
+	{
+		VENC_DestoryChannel(spacemitenc->ctx);
+		spacemitenc->ctx = NULL;
+	}
+	spacemitenc->ctx = VENC_CreateChannel();
+
+  spacemitenc->ctx->stVencPara.eCodingType = spacemitenc->eCodingType;
+  spacemitenc->ctx->stVencPara.nWidth = spacemitenc->width;
+  spacemitenc->ctx->stVencPara.nHeight = spacemitenc->height;
+  spacemitenc->ctx->stVencPara.PixelFormat = spacemitenc->PixelFormat;
+  spacemitenc->ctx->eCodecType = spacemitenc->eCodecType;
+
+  ret = VENC_Init(spacemitenc->ctx);
+  if (ret)
+    goto init_err;
+
+  spacemitenc->mpppacket = PACKET_Create ();
+  if (!spacemitenc->mpppacket)
+    goto alloc_err;
+
+  spacemitenc->mppframe = FRAME_Create ();
+  if (!spacemitenc->mppframe)
+    goto alloc_err;
+//  FRAME_Alloc(spacemitenc->mppframe, 1, 1280, 720);
+
+  GST_ERROR_OBJECT (spacemitenc, "ZRong ------------------------- finish start!!!");
+  g_mutex_init (&spacemitenc->event_mutex);
+  g_cond_init (&spacemitenc->event_cond);
+  spacemitenc->pending_frames = 0;
+  fbbb = fopen("/tmp/out.yuv", "ab+");
+
+  return TRUE;
+
+alloc_err:
+  GST_ERROR_OBJECT (spacemitenc, "can not alloc for mpp structure, please check !");
+  return FALSE;
+
+init_err:
+  GST_ERROR_OBJECT (spacemitenc, "Mpp vnec init error, please check !");
+  return FALSE;
+}
+
+static gboolean
+gst_spacemitenc_stop (GstVideoEncoder * encoder)
+{
+  GstSpacemitEnc *spacemitenc = GST_SPACEMITENC (encoder);
+
+    GST_ERROR_OBJECT (spacemitenc, "xxxxxxxxxxxxxx stop start");
+    fclose(fbbb);
+
+  if(spacemitenc->ctx)
+	{
+		VENC_DestoryChannel(spacemitenc->ctx);
+		spacemitenc->ctx = NULL;
+	}
+  FRAME_Destory(spacemitenc->mppframe);
+  PACKET_Destory(spacemitenc->mpppacket);
+  VENC_DestoryChannel(spacemitenc->ctx);
+
+  if (spacemitenc->input_state) {
+    gst_video_codec_state_unref (spacemitenc->input_state);
+  }
+  spacemitenc->input_state = NULL;
+  if (!(gst_pad_get_task_state ((encoder)->srcpad) == GST_TASK_STARTED))
+    return TRUE;
+
+  GST_DEBUG_OBJECT (spacemitenc, "spacemit_enc_stop called");
+
+  gst_pad_stop_task (encoder->srcpad);
+  g_cond_clear (&spacemitenc->event_cond);
+  g_mutex_clear (&spacemitenc->event_mutex);
+
+  return TRUE;
+}
+static void
+gst_st_mpp_enc_loop (GstVideoEncoder * encoder)
+{
+    GstVideoCodecFrame * frame = NULL;
+    GstSpacemitEnc *spacemitenc = GST_SPACEMITENC (encoder);
+    int ret;
+    GstFlowReturn flow_status;
+    GstMapInfo map;
+    static int lenght = 0;
+
+    GST_SPM_ENC_WAIT (encoder, spacemitenc->pending_frames >= 4 || spacemitenc->at_eos);
+    GST_VIDEO_ENCODER_STREAM_LOCK (encoder);
+
+    ret = VENC_RequestOutputStreamBuffer(spacemitenc->ctx, PACKET_GetBaseData(spacemitenc->mpppacket));
+    if (ret == MPP_CODER_NO_DATA)
+      goto sf_no_frame;
+    else if (ret == MPP_CODER_EOS)
+      goto finish_work;
+
+    frame = gst_video_encoder_get_oldest_frame (encoder);
+    if (!frame) {
+      GST_ERROR_OBJECT (spacemitenc, "ZRong ------------------- finish last frame");
+      spacemitenc->downstream_flow_ret = GST_FLOW_EOS;
+      GstBuffer *buffer;
+      buffer =
+          gst_buffer_new_wrapped (g_memdup (PACKET_GetDataPointer(spacemitenc->mpppacket),
+              PACKET_GetLength(spacemitenc->mpppacket)), PACKET_GetLength(spacemitenc->mpppacket));
+      flow_status = gst_pad_push (GST_VIDEO_ENCODER_SRC_PAD (spacemitenc), buffer);
+      GST_ERROR_OBJECT (spacemitenc, "ZRong ------------------- finish last frame %d", flow_status);
+
+      VENC_ReturnOutputStreamBuffer (spacemitenc->ctx, PACKET_GetBaseData(spacemitenc->mpppacket));
+      goto done;
+    }
+    spacemitenc->pending_frames--;
+    GST_SPM_ENC_BROADCAST (encoder);
+
+    //if (videoFrameTypeIDR == frame_info.eFrameType) {
+    //  GST_VIDEO_CODEC_FRAME_SET_SYNC_POINT (frame);
+    //} else {
+      GST_VIDEO_CODEC_FRAME_UNSET_SYNC_POINT (frame);
+    //}
+    frame->output_buffer =
+        gst_video_encoder_allocate_output_buffer (encoder, PACKET_GetLength(spacemitenc->mpppacket));
+    gst_buffer_map (frame->output_buffer, &map, GST_MAP_WRITE);
+
+    lenght += PACKET_GetLength(spacemitenc->mpppacket);
+    GST_ERROR_OBJECT (spacemitenc, "ZRong ------------------- finish one frame, %d, %d", lenght, PACKET_GetLength(spacemitenc->mpppacket));
+    memcpy (map.data, PACKET_GetDataPointer(spacemitenc->mpppacket), PACKET_GetLength(spacemitenc->mpppacket));
+  
+    gst_buffer_unmap (frame->output_buffer, &map);
+    VENC_ReturnOutputStreamBuffer (spacemitenc->ctx, PACKET_GetBaseData(spacemitenc->mpppacket));
+
+    spacemitenc->downstream_flow_ret = gst_video_encoder_finish_frame (encoder, frame);
+done:
+  GST_VIDEO_ENCODER_STREAM_UNLOCK (encoder);
+  return;
+
+sf_no_frame:
+{
+  GST_LOG_OBJECT (spacemitenc,
+      "No out frame to request%d!", spacemitenc->pending_frames);
+  spacemitenc->downstream_flow_ret = GST_FLOW_OK;
+  goto done;
+}
+finish_work:
+{
+  GST_DEBUG_OBJECT (spacemitenc,
+      "Get eos, Finished work and paused task!");
+  gst_pad_pause_task (GST_VIDEO_ENCODER_SRC_PAD (spacemitenc));
+  spacemitenc->downstream_flow_ret = GST_FLOW_EOS;
+  goto done;
+}
+
+}
+
+
+static gboolean
+gst_spacemitenc_set_format (GstVideoEncoder * encoder,
+    GstVideoCodecState * state)
+{
+  GstSpacemitEnc *spacemitenc = GST_SPACEMITENC (encoder);
+  gchar *debug_caps;
+  guint width, height, fps_n, fps_d;
+  guint n_slices = 1;
+  gint ret;
+  GstCaps *outcaps;
+  GstVideoCodecState *output_state;
+  spacemitenc->frame_count = 0;
+  int stride0, stride1, stride2;
+  GstVideoFormat fmt;
+
+  debug_caps = gst_caps_to_string (state->caps);
+  GST_DEBUG_OBJECT (spacemitenc, "gst_e26d4_enc_set_format called, caps: %s",
+      debug_caps);
+  g_free (debug_caps);
+
+  if (spacemitenc->input_state) {
+    gst_video_codec_state_unref (spacemitenc->input_state);
+  }
+  spacemitenc->input_state = gst_video_codec_state_ref (state);
+
+  width = GST_VIDEO_INFO_WIDTH (&state->info);
+  height = GST_VIDEO_INFO_HEIGHT (&state->info);
+  fps_n = GST_VIDEO_INFO_FPS_N (&state->info);
+  fps_d = GST_VIDEO_INFO_FPS_D (&state->info);
+  stride0 = GST_VIDEO_INFO_PLANE_STRIDE (&state->info, 0);
+  stride1 = GST_VIDEO_INFO_PLANE_STRIDE (&state->info, 1);
+  stride2 = GST_VIDEO_INFO_PLANE_STRIDE (&state->info, 2);
+  fmt = GST_VIDEO_INFO_FORMAT (&state->info);
+
+  spacemitenc->para = (MppVencPara*)malloc(sizeof(MppVencPara));
+  memset(spacemitenc->para, 0, sizeof(MppVencPara));
+  spacemitenc->para->nBitrate = 5000000;
+  spacemitenc->para->nFrameRate = 30;
+  spacemitenc->para->nHeight = spacemitenc->height;
+  spacemitenc->para ->nWidth = spacemitenc->width;
+  spacemitenc->para->nStride = spacemitenc->width;
+  VENC_SetParam(spacemitenc->ctx, spacemitenc->para);
+
+  outcaps =
+      gst_caps_copy (gst_static_pad_template_get_caps
+      (&gst_spacemitenc_src_template));
+
+  output_state = gst_video_encoder_set_output_state (encoder, outcaps, state);
+  gst_video_codec_state_unref (output_state);
+
+  GST_ERROR_OBJECT (spacemitenc, "ZRong -------------------- set format finish, %d, %d (%d %d)", width, height, fps_n, fps_d);
+  GST_ERROR_OBJECT (spacemitenc, "ZRong ----------------------- set format finish, %u, (%d %d %d) %s", fmt, stride0, stride1, stride2, gst_video_format_to_string (fmt));
+
+  if (!gst_video_encoder_negotiate (encoder))
+    return FALSE;    
+
+  if (G_UNLIKELY (!gst_pad_get_task_state ((encoder)->srcpad) == GST_TASK_STARTED)) {
+    GST_DEBUG_OBJECT (spacemitenc, "@@@ ZRong ------------------------- starting encoding thread");
+    gst_pad_start_task (encoder->srcpad,
+        (GstTaskFunction) gst_st_mpp_enc_loop, encoder, NULL);
+  }
+  return TRUE;
+
+}
+
+static gboolean
+gst_spacemitenc_propose_allocation (GstVideoEncoder * encoder, GstQuery * query)
+{
+  gst_query_add_allocation_meta (query, GST_VIDEO_META_API_TYPE, NULL);
+
+  return
+      GST_VIDEO_ENCODER_CLASS
+      (gst_spacemitenc_parent_class)->propose_allocation (encoder, query);
+}
+
+static GstFlowReturn
+gst_spacemitenc_handle_frame (GstVideoEncoder * encoder,
+    GstVideoCodecFrame * frame)
+{
+  GstSpacemitEnc *spacemitenc = GST_SPACEMITENC (encoder);
+  GstVideoFrame video_frame;
+  gboolean force_keyframe;
+  gint ret;
+  gfloat fps;
+  gint i, j;
+  gsize buf_length = 0;
+  GstFlowReturn flow_ret;
+  GST_ERROR_OBJECT (spacemitenc, "ZRong ------------- handle frame start");
+
+  if (spacemitenc->downstream_flow_ret != GST_FLOW_OK) {
+    goto downstream_err;
+  }
+
+  GST_OBJECT_LOCK (spacemitenc);
+  if (spacemitenc->bitrate_changed || spacemitenc->max_bitrate_changed) {
+      GST_WARNING_OBJECT (spacemitenc,
+          "Error need to support this cases");
+  }
+  GST_OBJECT_UNLOCK (spacemitenc);
+
+  if (frame) {
+    spacemitenc->frame_count++;
+    gst_video_frame_map (&video_frame, &spacemitenc->input_state->info,
+        frame->input_buffer, GST_MAP_READ);
+    if (spacemitenc->PixelFormat == PIXEL_FORMAT_I420) {
+      FRAME_SetDataUsedNum(spacemitenc->mppframe, 3);
+      FRAME_SetDataPointer(spacemitenc->mppframe, 0, GST_VIDEO_FRAME_PLANE_DATA (&video_frame, 0));
+      FRAME_SetDataPointer(spacemitenc->mppframe, 1, GST_VIDEO_FRAME_PLANE_DATA (&video_frame, 1));
+      FRAME_SetDataPointer(spacemitenc->mppframe, 2, GST_VIDEO_FRAME_PLANE_DATA (&video_frame, 2));
+    } else {
+      GST_ERROR_OBJECT (spacemitenc, "ZRong ------------- be save %s, %d, (%d, %d, %d)",
+        gst_video_format_to_string(GST_VIDEO_FRAME_FORMAT(&video_frame)),
+        GST_VIDEO_FRAME_N_PLANES(&video_frame), GST_VIDEO_FRAME_SIZE(&video_frame),
+        GST_VIDEO_FRAME_WIDTH(&video_frame), GST_VIDEO_FRAME_HEIGHT(&video_frame));
+
+      FRAME_SetDataUsedNum(spacemitenc->mppframe, 2);
+      FRAME_SetDataPointer(spacemitenc->mppframe, 0, GST_VIDEO_FRAME_PLANE_DATA (&video_frame, 0));
+      FRAME_SetDataPointer(spacemitenc->mppframe, 1, GST_VIDEO_FRAME_PLANE_DATA (&video_frame, 1));
+#if 0
+      //SF_OMX_BUF_INFO *pBufInfo = pOMXBuffer->pOutputPortPrivate;
+      //LOG(SF_LOG_INFO, "%p %d %p\r\n", pOMXBuffer->pBuffer, pOMXBuffer->nFilledLen, pBufInfo->remap_vaddr);
+
+      fwrite(GST_VIDEO_FRAME_COMP_DATA (&video_frame, 0), 1, 1280*720, fbbb);
+      fwrite(GST_VIDEO_FRAME_COMP_DATA (&video_frame, 1), 1, 1280*720/2, fbbb);
+
+#endif
+
+    }
+  } else {
+    MppData * tmp = FRAME_GetBaseData(spacemitenc->mppframe);
+    tmp->bEos = 1;
+  }
+  GST_VIDEO_ENCODER_STREAM_UNLOCK (encoder);
+  ret = VENC_Encode(spacemitenc->ctx, FRAME_GetBaseData(spacemitenc->mppframe));
+  GST_VIDEO_ENCODER_STREAM_LOCK (encoder);
+  if (ret != 0) {
+    GST_ELEMENT_ERROR (spacemitenc, STREAM, ENCODE,
+        ("Could not encode frame"), ("Spacemit returned %d", ret));
+    flow_ret = GST_FLOW_ERROR;
+    if (frame)
+      goto release_res;
+    else
+      goto done;
+  }
+  if (!frame) 
+    goto flow_eos;
+  /* Avoid holding too much frames */
+  GST_VIDEO_ENCODER_STREAM_UNLOCK (encoder);
+  GST_SPM_ENC_WAIT (encoder, 
+    spacemitenc->pending_frames < SPM_PENDING_MAX);
+  GST_VIDEO_ENCODER_STREAM_LOCK (encoder);
+  spacemitenc->pending_frames++;
+  GST_SPM_ENC_BROADCAST (encoder);
+
+  flow_ret = spacemitenc->downstream_flow_ret;
+  GST_ERROR_OBJECT (spacemitenc, "ZRong ------------- handle frame start: %d, %d", spacemitenc->pending_frames, spacemitenc->frame_count);
+
+  if (frame)
+    goto release_res;
+
+done:
+  return flow_ret;
+downstream_err:
+{
+  GST_ERROR_OBJECT (spacemitenc, "Downstream returned %s",
+      gst_flow_get_name (spacemitenc->downstream_flow_ret));
+  flow_ret = spacemitenc->downstream_flow_ret;
+  goto done;
+}
+release_res:
+{
+  gst_video_frame_unmap (&video_frame);
+  gst_video_codec_frame_unref (frame);
+  goto done;
+}
+flow_eos:
+{
+  GST_DEBUG_OBJECT (spacemitenc, "Get an eos, exit handle");
+  flow_ret = GST_FLOW_EOS;
+  goto done;
+}
+#if 0
+  /* FIXME: spacemit has no way for us to get a connection
+   * between the input and output frames, we just have to
+   * guess based on the input */
+  frame = gst_video_encoder_get_oldest_frame (encoder);
+  if (!frame) {
+    GST_ELEMENT_ERROR (spacemitenc, STREAM, ENCODE,
+        ("Could not encode frame"), ("spacemitenc returned %d", ret));
+    gst_video_codec_frame_unref (frame);
+    return GST_FLOW_ERROR;
+  }
+  ret = VENC_RequestOutputStreamBuffer(spacemitenc->ctx, PACKET_GetBaseData(spacemitenc->mpppacket));
+  if (ret) {
+    GST_ELEMENT_ERROR (spacemitenc, STREAM, ENCODE,
+        ("Could not encode frame"), ("spacemitenc returned %d", ret));
+    gst_video_codec_frame_unref (frame);
+    return GST_FLOW_ERROR;
+  }
+
+  if (videoFrameTypeIDR == frame_info.eFrameType) {
+    GST_VIDEO_CODEC_FRAME_SET_SYNC_POINT (frame);
+  } else {
+    GST_VIDEO_CODEC_FRAME_UNSET_SYNC_POINT (frame);
+  }
+
+  frame->output_buffer =
+      gst_video_encoder_allocate_output_buffer (encoder, PACKET_GetLength(spacemitenc->mpppacket));
+  gst_buffer_map (frame->output_buffer, &map, GST_MAP_WRITE);
+
+  memcpy (map.data, PACKET_GetDataPointer(spacemitenc->mpppacket), PACKET_GetLength(spacemitenc->mpppacket));
+
+  gst_buffer_unmap (frame->output_buffer, &map);
+  VENC_ReturnOutputStreamBuffer (spacemitenc->ctx, PACKET_GetBaseData(spacemitenc->mpppacket));
+
+  GstFlowReturn flow_status = gst_video_encoder_finish_frame (encoder, frame);
+
+  GST_ERROR_OBJECT (spacemitenc, "ZRong ----------------------- handle frame finish");
+
+  return flow_status;
+#endif
+}
+
+static GstFlowReturn
+gst_spacemitenc_finish (GstVideoEncoder * encoder)
+{
+  GstSpacemitEnc *spacemitenc = GST_SPACEMITENC (encoder);
+
+  if (spacemitenc->frame_count == 0)
+    return GST_FLOW_OK;
+
+  /* Drain encoder */
+  while ((gst_spacemitenc_handle_frame (encoder, NULL)) == GST_FLOW_OK);
+
+  GST_DEBUG_OBJECT(spacemitenc, "finish test3");
+  spacemitenc->at_eos = TRUE;
+
+  GST_SPM_ENC_BROADCAST (encoder);
+
+  GST_VIDEO_ENCODER_STREAM_UNLOCK (encoder);
+  /* Wait for task thread to pause */
+  GstTask *task = encoder->srcpad->task;
+  if (task) {
+    //GST_OBJECT_LOCK (task);
+    while (GST_TASK_STATE (task) == GST_TASK_STARTED) {
+      GST_DEBUG_OBJECT(spacemitenc, "finish test4");
+      g_usleep(400 * 1000);
+      //GST_TASK_WAIT (task);
+    }
+    GST_DEBUG_OBJECT(spacemitenc, "finish test5");
+    //GST_OBJECT_UNLOCK (task);
+  }
+  GST_VIDEO_ENCODER_STREAM_LOCK (encoder);
+
+  GST_DEBUG_OBJECT(spacemitenc, "finish test2");
+
+  return GST_FLOW_OK;
+}
+
+gboolean
+gst_spacemitenc_register (GstPlugin * plugin, guint rank)
+{
+  return gst_element_register (plugin, "spacemitenc", rank,
+      GST_TYPE_SPACEMITENC);
+}
+
diff --git a/ext/spacemit/spacemitcodec/gstspacemitplugin.c b/ext/spacemit/spacemitcodec/gstspacemitplugin.c
new file mode 100755
index 0000000..d2d5e62
--- /dev/null
+++ b/ext/spacemit/spacemitcodec/gstspacemitplugin.c
@@ -0,0 +1,29 @@
+
+/*
+ * Spacemit GStreamer plugin
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <gst/gst.h>
+
+#include "gstspacemitdec.h"
+#include "gstspacemitenc.h"
+
+static gboolean plugin_init(GstPlugin *plugin)
+{
+  gboolean ret = FALSE;
+
+  ret |= gst_spacemitdec_register (plugin, GST_RANK_PRIMARY + 1);
+	ret |= gst_spacemitenc_register (plugin, GST_RANK_PRIMARY + 1);
+
+	return ret;
+}
+
+GST_PLUGIN_DEFINE(GST_VERSION_MAJOR,
+	GST_VERSION_MINOR,
+	spacemitcodec,
+	"Spacemit encoder/decoder plugin",
+	plugin_init, VERSION, "LGPL", GST_PACKAGE_NAME, GST_PACKAGE_ORIGIN)
diff --git a/ext/spacemit/spacemitcodec/gstspmdmabufallocator.c b/ext/spacemit/spacemitcodec/gstspmdmabufallocator.c
new file mode 100755
index 0000000..86efd37
--- /dev/null
+++ b/ext/spacemit/spacemitcodec/gstspmdmabufallocator.c
@@ -0,0 +1,310 @@
+/* GStreamer
+ *
+ * Copyright (C) 2016 Igalia
+ *
+ * Authors:
+ *  Víctor Manuel Jáquez Leal <vjaquez@igalia.com>
+ *  Javier Martin <javiermartin@by.com.es>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "gstspmdmabufallocator.h"
+
+#define GST_CAT_DEFAULT spmdmabufallocator_debug_category
+GST_DEBUG_CATEGORY_STATIC (GST_CAT_DEFAULT);
+
+#define GST_SPM_DMABUF_MEMORY_TYPE "SpmDmaBufMemory"
+
+#define parent_class gst_spm_dmabuf_allocator_parent_class
+
+G_DEFINE_TYPE_WITH_CODE (GstSpmDmaBufAllocator, gst_spm_dmabuf_allocator,
+    GST_TYPE_DMABUF_ALLOCATOR,
+    GST_DEBUG_CATEGORY_INIT (GST_CAT_DEFAULT, "spmdmabufallocator", 0,
+    "SPM DMABUF allocator"));
+
+gboolean
+gst_is_spm_dmabuf_memory (GstMemory * base_mem)
+{
+  return gst_memory_is_type (base_mem, GST_SPM_DMABUF_MEMORY_NAME);
+}
+
+static void
+gst_spm_dmabuf_allocator_free (GstAllocator * allocator, GstMemory * base_mem)
+{
+  GstSpmDmaBufMemory *mem = (GstSpmDmaBufMemory *) base_mem;
+  GST_DEBUG ("ZRong ------------------- spacemit free dma mem");
+
+  g_warn_if_fail (!mem->acquired);
+
+  g_slice_free (GstSpmDmaBufMemory, mem);
+}
+
+static void
+gst_unref_spm_dmabuf_mem (gpointer key, gpointer value, gpointer user_data)
+{
+  GstMemory *mem = (GstMemory *)value;
+
+  GST_DEBUG ("ZRong ------------------- spacemit dmabuf allocator finalize %d", mem->mini_object.refcount);
+  gst_memory_unref (value);
+}
+
+static void
+gst_spm_dmabuf_allocator_finalize (GObject * obj)
+{
+  GstSpmDmaBufAllocator *alloc = GST_SPM_DMABUF_ALLOCATOR (obj);
+  GST_DEBUG_OBJECT (alloc, "ZRong ------------------- spacemit dma allocator finalize");
+
+  G_OBJECT_CLASS (parent_class)->finalize (obj);
+}
+
+/* installed as the GstMiniObject::dispose function of the acquired GstMemory */
+static gboolean
+gst_spm_dmabuf_allocator_memory_dispose (GstMemory * base_mem)
+{
+  GstSpmDmaBufMemory *mem;
+  GstSpmDmaBufAllocator *allocator;
+
+  mem = (GstSpmDmaBufMemory *) base_mem;
+  base_mem->size = mem->memsize;
+  allocator = GST_SPM_DMABUF_ALLOCATOR (GST_MEMORY_CAST (mem)->allocator);
+
+  if (mem->acquired) 
+  {
+    VDEC_ReturnOutputFrame(mem->ctx, FRAME_GetBaseData(mem->mppframe));
+    FRAME_Destory(mem->mppframe);
+    mem->ctx = NULL;
+    mem->mppframe = NULL;
+
+    /* keep the memory alive */
+    gst_memory_ref (base_mem);
+    GST_DEBUG ("ZRong ------------------- spacemit memory_dispose (%d, %d), push mem: %d, %d", mem->memsize, base_mem->size, mem->num, base_mem->mini_object.refcount);
+
+    mem->acquired = FALSE;
+
+    return FALSE;
+  }
+  GST_DEBUG ("ZRong ------------------- spacemit memory_dispose222 (%d, %d), push mem: %d, %d", mem->memsize, base_mem->size, mem->num, base_mem->mini_object.refcount);
+
+  return TRUE;
+}
+
+static GstSpmDmaBufMemory *
+gst_spm_dmabuf_memory_new (GstSpmDmaBufAllocator * allocator, gsize maxsize,
+    GstMemoryFlags flags, GstMemory * parent, gssize offset, gssize size)
+{
+  GstSpmDmaBufMemory *mem;
+  gint align;
+
+  /* GStreamer uses a bitmask for the alignment while
+   * OMX uses the alignment itself. So we have to convert
+   * here */
+  align = 0;
+
+  if (size == -1) {
+    size = maxsize - offset;
+  }
+
+  mem = g_slice_new0 (GstSpmDmaBufMemory);
+  gst_memory_init (GST_MEMORY_CAST (mem), flags, (GstAllocator *) allocator,
+      parent, maxsize, align, offset, size);
+
+  return mem;
+}
+
+static inline void
+install_dmabuf_mem_dispose (GstSpmDmaBufMemory * mem)
+{
+  GstMemory *base_mem = (GstMemory *) mem;
+
+  GST_MINI_OBJECT_CAST (base_mem)->dispose =
+      (GstMiniObjectDisposeFunction) gst_spm_dmabuf_allocator_memory_dispose;
+}
+
+GstAllocator *
+gst_spm_dmabuf_allocator_new (void)
+{
+  GstSpmDmaBufAllocator *allocator;
+
+  allocator = g_object_new (GST_TYPE_SPM_DMABUF_ALLOCATOR, NULL);
+  if (!allocator)
+    return NULL;
+
+  allocator->id = 888;
+
+  return GST_ALLOCATOR_CAST (allocator);
+}
+GstMemory *
+gst_spm_dmabuf_allocator_alloc (GstSpmDmaBufAllocator * allocator, gsize size,
+    gint32 fd)
+{
+  GstSpmDmaBufMemory *mem;
+  guint8 *data;
+  static guint8 i = 0;
+
+  GST_DEBUG_OBJECT (allocator, "ZRong ------------------- spacemit allocator alloc %d.%d %p", size, allocator->id, allocator->memories);
+
+  //mem = gst_spm_dmabuf_memory_new (allocator, size, 0, NULL, 0, size);
+  mem = gst_dmabuf_allocator_alloc (allocator, fd, size);
+
+  mem->memsize = size;
+
+  install_dmabuf_mem_dispose (mem);
+  mem->num = i;
+  i++;
+  mem->acquired = FALSE;
+
+  GST_DEBUG_OBJECT (allocator, "ZRong ------------------- af spacemit allocator alloc %d", i);
+
+  return (GstMemory *) mem;
+}
+
+
+GstFlowReturn
+gst_spm_dmabuf_allocator_acquire (GstAllocator * base_allocator, GstMemory ** memory)
+{
+  GstMemory *base_mem;
+  GstSpmDmaBufMemory *mem;
+  GstSpmDmaBufAllocator *allocator = GST_SPM_DMABUF_ALLOCATOR (base_allocator);
+
+  base_mem = (GstMemory *) g_hash_table_lookup (allocator->memories, GINT_TO_POINTER(allocator->mppframe_id));
+  if (!base_mem) {
+    base_mem = gst_spm_dmabuf_allocator_alloc (allocator, allocator->info.size, allocator->dmabuf_fd);
+    GST_DEBUG_OBJECT (allocator, "insert id%d fd%d to memories hash", allocator->mppframe_id, allocator->dmabuf_fd);
+    g_hash_table_insert(allocator->memories, GINT_TO_POINTER(allocator->mppframe_id), base_mem);
+  }
+  mem = (GstSpmDmaBufMemory *)base_mem;
+  mem->acquired = TRUE;
+  *memory = base_mem;
+
+  GST_DEBUG_OBJECT (allocator, "ZRong ------------------- acquire mem (%d, %d) %d, pop mem: %d", (*memory)->size, (*memory)->offset, allocator->mppframe_id, mem->num);
+  return GST_FLOW_OK;
+}
+
+gboolean
+gst_spm_dmabuf_allocator_configure (GstAllocator * base_allocator, GstVideoInfo * info)
+{
+  GstSpmDmaBufAllocator *allocator = GST_SPM_DMABUF_ALLOCATOR (base_allocator);
+
+  if (!info) {
+    GST_ERROR_OBJECT (allocator, "error, get a NULL info to allocator!");
+    return FALSE;
+  }
+
+  allocator->info = *info;
+  return TRUE;
+}
+
+gboolean
+gst_spm_dmabuf_allocator_set_active (GstSpmDmaBufAllocator * allocator, gboolean active)
+{
+  gboolean changed = FALSE;
+
+  g_mutex_lock (&allocator->lock);
+
+  if (allocator->active != active)
+    changed = TRUE;
+
+  GST_DEBUG_OBJECT (allocator, "ZRong ------------------- allocator_set_active(%d %d)", allocator->active, active);
+
+  if (changed) {
+    if (active) {
+
+    } else {
+      g_hash_table_foreach (allocator->memories, gst_unref_spm_dmabuf_mem, NULL);
+      g_hash_table_remove_all (allocator->memories);
+
+    }
+  }
+
+  allocator->active = active;
+  g_mutex_unlock (&allocator->lock);
+
+  return changed;
+}
+
+
+static gpointer
+gst_spm_dmabuf_memory_map (GstMemory * base_mem, gsize maxsize, GstMapFlags flags)
+{
+  GstSpmDmaBufMemory *mem = (GstSpmDmaBufMemory *) base_mem;
+  GST_DEBUG ("ZRong ------------------- af memory_map (%d, %d)", maxsize, mem->num);
+
+  return FRAME_GetDataPointer(mem->mppframe, 0);
+}
+static void
+gst_spm_dmabuf_memory_unmap (GstMemory * base_mem)
+{
+}
+
+void
+gst_spm_dmabuf_allocator_mppframe_id (GstAllocator * base_allocator, gint32 id, gint32 fd)
+{
+  GstSpmDmaBufAllocator *allocator = GST_SPM_DMABUF_ALLOCATOR (base_allocator);
+
+  if (id < 0 || fd < 0)
+    GST_ERROR_OBJECT (allocator, "error, get a invaild id/fd (%d,%d)!", id, fd);
+
+  allocator->mppframe_id = id;
+  allocator->dmabuf_fd = fd;
+}
+
+void
+gst_spm_set_dmabuf_mem (GstMemory * base_mem, MppFrame *mppframe, MppVdecCtx *ctx)
+{
+  GstSpmDmaBufMemory *mem = (GstSpmDmaBufMemory *) base_mem;
+
+  mem->mppframe = mppframe;
+  mem->ctx = ctx;
+}
+
+static void
+gst_spm_dmabuf_allocator_class_init (GstSpmDmaBufAllocatorClass * klass)
+{
+  GObjectClass *gobject_class;
+  GstAllocatorClass *allocator_class;
+
+  allocator_class = GST_ALLOCATOR_CLASS (klass);
+  gobject_class = G_OBJECT_CLASS (klass);
+
+  allocator_class->alloc = NULL;
+  allocator_class->free = gst_spm_dmabuf_allocator_free;
+
+  gobject_class->finalize = gst_spm_dmabuf_allocator_finalize;
+}
+
+static void
+gst_spm_dmabuf_allocator_init (GstSpmDmaBufAllocator * allocator)
+{
+  GstAllocator *alloc = GST_ALLOCATOR_CAST (allocator);
+
+  alloc->mem_type = GST_SPM_DMABUF_MEMORY_NAME;
+  alloc->mem_map = gst_spm_dmabuf_memory_map;
+  alloc->mem_unmap = gst_spm_dmabuf_memory_unmap;
+
+  allocator->memories = g_hash_table_new (g_direct_hash, g_direct_equal);
+  allocator->mppframe_id = -1;
+  allocator->active = FALSE;
+  g_mutex_init (&allocator->lock);
+
+  GST_OBJECT_FLAG_SET (allocator, GST_ALLOCATOR_FLAG_CUSTOM_ALLOC);
+}
+
diff --git a/ext/spacemit/spacemitcodec/gstspmdmabufallocator.h b/ext/spacemit/spacemitcodec/gstspmdmabufallocator.h
new file mode 100755
index 0000000..d9d290a
--- /dev/null
+++ b/ext/spacemit/spacemitcodec/gstspmdmabufallocator.h
@@ -0,0 +1,123 @@
+/* GStreamer
+ *
+ * Copyright (C) 2016 Igalia
+ *
+ * Authors:
+ *  Víctor Manuel Jáquez Leal <vjaquez@igalia.com>
+ *  Javier Martin <javiermartin@by.com.es>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ *
+ */
+
+#ifndef __GST_SPM_DMABUF_ALLOCATOR_H__
+#define __GST_SPM_DMABUF_ALLOCATOR_H__
+
+#include <gst/gst.h>
+#include <gst/video/video.h>
+#include <vdec.h>
+#include <gst/allocators/gstdmabuf.h>
+
+G_BEGIN_DECLS
+
+/* ---------------------------------------------------------------------*/
+/* GstSpmDmaBufMemory                                                   */
+/* ---------------------------------------------------------------------*/
+
+typedef struct _GstSpmDmaBufAllocator GstSpmDmaBufAllocator;
+typedef struct _GstSpmDmaBufAllocatorClass GstSpmDmaBufAllocatorClass;
+typedef struct _GstSpmDmaBufMemory GstSpmDmaBufMemory;
+
+#define GST_SPM_DMABUF_MEMORY_NAME             "GstSpmDmaBufMemory"
+
+#define GST_SPM_DMABUF_ALLOCATOR_CAST(allocator) \
+  ((GstSpmDmaBufAllocator *) (allocator))
+
+#define GST_TYPE_SPM_DMABUF_ALLOCATOR \
+  (gst_spm_dmabuf_allocator_get_type ())
+#define GST_SPM_DMABUF_ALLOCATOR(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_SPM_DMABUF_ALLOCATOR, \
+      GstSpmDmaBufAllocator))
+#define GST_IS_SPM_DMABUF_ALLOCATOR(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_SPM_DMABUF_ALLOCATOR))
+
+
+struct _GstSpmDmaBufMemory
+{
+  GstMemory parent;
+
+  gboolean acquired;
+  MppFrame *mppframe;
+  gpointer ptr;
+
+  MppVdecCtx *ctx;
+  guint32 num;
+  guint32 memsize;
+  gint32 mppframe_id;
+
+  guint32 fd;
+};
+
+/*
+ * GstSpmDmaBufAllocator:
+ *
+ * A SPM DMABuf memory allocator object.
+ */
+struct _GstSpmDmaBufAllocator
+{
+  GstDmaBufAllocator parent_instance;
+  gboolean active;
+  GMutex lock;
+
+  GHashTable *memories;
+  gint32 mppframe_id;
+  gint32 dmabuf_fd;
+  guint32 id;
+  GstVideoInfo info;
+};
+
+/*
+ * GstSpmDmaBufAllocatorClass:
+ *
+ * A SPM DMABuf memory allocator class.
+ */
+struct _GstSpmDmaBufAllocatorClass
+{
+  GstDmaBufAllocatorClass parent_class;
+};
+GstAllocator *
+gst_spm_dmabuf_allocator_new (void);
+gboolean gst_is_spm_dmabuf_memory (GstMemory *mem);
+GstMemory *
+gst_spm_dmabuf_allocator_alloc (GstSpmDmaBufAllocator * allocator, gsize size,
+    GstAllocationParams * params);
+GstFlowReturn
+gst_spm_dmabuf_allocator_acquire (GstAllocator * base_allocator, GstMemory ** memory);
+gboolean
+gst_spm_dmabuf_allocator_configure (GstAllocator * base_allocator, GstVideoInfo * info);
+gboolean
+gst_spm_dmabuf_allocator_set_active (GstSpmDmaBufAllocator * allocator, gboolean active);
+
+void
+gst_spm_dmabuf_allocator_mppframe_id (GstAllocator * base_allocator, gint32 id);
+void
+gst_spm_set_dmabuf_mem (GstMemory * base_mem, MppFrame *mppframe, MppVdecCtx *ctx);
+
+GType gst_spm_dmabuf_allocator_get_type (void);
+
+G_END_DECLS
+
+#endif /* __GST_SPM_DMABUF_ALLOCATOR_H__ */
diff --git a/ext/spacemit/spacemitcodec/meson.build b/ext/spacemit/spacemitcodec/meson.build
new file mode 100755
index 0000000..c6ed6c3
--- /dev/null
+++ b/ext/spacemit/spacemitcodec/meson.build
@@ -0,0 +1,22 @@
+spacemitcodec_sources = [
+  'gstspacemitallocator.c',
+  'gstspacemitbufferpool.c',
+  'gstspacemitenc.c',
+  'gstspacemitdec.c',
+  'gstspacemitplugin.c',
+]
+
+spacemitmpp_dep = dependency('spacemit_mpp', version : '>= 0.0.0', required : false)
+
+if spacemitmpp_dep.found()
+	gstspacemitcodec = library('gstspacemitcodec',
+		spacemitcodec_sources,
+		c_args : gst_plugins_bad_args,
+		link_args : noseh_link_args,
+		include_directories : [configinc],
+		dependencies : [gstvideo_dep, spacemitmpp_dep, gstallocators_dep],
+		install : true,
+		install_dir : plugins_install_dir,
+	)
+	plugins += [gstspacemitcodec]
+endif
diff --git a/ext/spacemit/spacemitsrc/gstspacemitsrc.c b/ext/spacemit/spacemitsrc/gstspacemitsrc.c
new file mode 100755
index 0000000..f1bb069
--- /dev/null
+++ b/ext/spacemit/spacemitsrc/gstspacemitsrc.c
@@ -0,0 +1,807 @@
+/* GStreamer
+ * Copyright (C) 2021 FIXME <fixme@example.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Suite 500,
+ * Boston, MA 02110-1335, USA.
+ */
+/**
+ * SECTION:element-gstspacemitsrc
+ *
+ * The spacemitsrc element is a source for k1x cameras like the Retiga 2000R
+ *
+ * <refsect2>
+ * <title>Example launch line</title>
+ * |[
+ * gst-launch -v spacemitsrc ! videoconvert ! autovideosink
+ * ]|
+ * Shows video from the default k1x camera device
+ * </refsect2>
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <gst/gst.h>
+#include <gst/base/gstpushsrc.h>
+#include <gst/video/video.h>
+#include "gstspacemitsrc.h"
+
+GST_DEBUG_CATEGORY_STATIC (gst_spacemitsrc_debug);
+#define GST_CAT_DEFAULT gst_spacemitsrc_debug
+
+/* prototypes */
+static void gst_spacemitsrc_set_property (GObject * object,
+    guint property_id, const GValue * value, GParamSpec * pspec);
+static void gst_spacemitsrc_get_property (GObject * object,
+    guint property_id, GValue * value, GParamSpec * pspec);
+static void gst_spacemitsrc_dispose (GObject * object);
+static void gst_spacemitsrc_finalize (GObject * object);
+
+static gboolean gst_spacemitsrc_start (GstBaseSrc * src);
+static gboolean gst_spacemitsrc_stop (GstBaseSrc * src);
+static GstCaps *gst_spacemitsrc_get_caps (GstBaseSrc * src, GstCaps * filter);
+static gboolean gst_spacemitsrc_set_caps (GstBaseSrc * src, GstCaps * caps);
+static gboolean gst_spacemitsrc_unlock (GstBaseSrc * src);
+static gboolean gst_spacemitsrc_unlock_stop (GstBaseSrc * src);
+static gboolean gst_spacemitsrc_decide_allocation (GstBaseSrc * bsrc, GstQuery * query);
+static GstFlowReturn gst_spacemitsrc_create (GstPushSrc * src, GstBuffer ** buf);
+
+static void gst_spacemitsrc_frame_callback (void *userPtr, unsigned long userData,
+    int errcode, unsigned long flags);
+
+enum
+{
+  PROP_0,
+  PROP_LOCATION,
+  PROP_DEVICE_INDEX,
+  PROP_NUM_CAPTURE_BUFFERS,
+  PROP_TIMEOUT,
+  PROP_EXPOSURE,
+  PROP_GAIN,
+  PROP_OFFSET,
+  PROP_FORMAT,
+  PROP_X,
+  PROP_Y,
+  PROP_WIDTH,
+  PROP_HEIGHT,
+  PROP_BINNING
+};
+
+#define DEFAULT_PROP_DEVICE_INDEX 0
+#define DEFAULT_PROP_NUM_CAPTURE_BUFFERS 3
+#define DEFAULT_PROP_TIMEOUT 500
+#define DEFAULT_PROP_EXPOSURE 16384
+#define DEFAULT_PROP_GAIN 1.0
+#define DEFAULT_PROP_OFFSET 0
+//#define DEFAULT_PROP_FORMAT qfmtMono16
+#define DEFAULT_PROP_FORMAT 2
+#define DEFAULT_PROP_X 0
+#define DEFAULT_PROP_Y 0
+#define DEFAULT_PROP_WIDTH 0
+#define DEFAULT_PROP_HEIGHT 0
+#define DEFAULT_PROP_BINNING 1
+
+GHashTable *frame_hash;
+
+/* pad templates */
+static GstStaticPadTemplate gst_spacemitsrc_src_template =
+GST_STATIC_PAD_TEMPLATE ("src",
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS (SPM_SRC_CAPS_MAKE ("{" SPM_SRC_FORMATS "}") ";")
+    );
+
+/* class initialization */
+G_DEFINE_TYPE (GstSpacemitSrc, gst_spacemitsrc, GST_TYPE_PUSH_SRC);
+
+static int g_spacemitsrc_use_count = 0;
+
+static void
+gst_spacemitsrc_driver_ref ()
+{
+  if (g_spacemitsrc_use_count == 0) {
+    //SPACEMIT_LoadDriver ();
+  }
+  g_spacemitsrc_use_count++;
+}
+
+static void
+gst_spacemitsrc_driver_unref ()
+{
+  g_spacemitsrc_use_count--;
+  if (g_spacemitsrc_use_count == 0) {
+    //SPACEMIT_ReleaseDriver ();
+  }
+}
+
+static void
+gst_spacemitsrc_class_init (GstSpacemitSrcClass * klass)
+{
+  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
+  GstElementClass *gstelement_class = GST_ELEMENT_CLASS (klass);
+  GstBaseSrcClass *gstbasesrc_class = GST_BASE_SRC_CLASS (klass);
+  GstPushSrcClass *gstpushsrc_class = GST_PUSH_SRC_CLASS (klass);
+
+  GST_DEBUG_CATEGORY_INIT (GST_CAT_DEFAULT, "spacemitsrc", 0,
+      "k1x-cam Spacemitsrc source");
+
+  gobject_class->set_property = gst_spacemitsrc_set_property;
+  gobject_class->get_property = gst_spacemitsrc_get_property;
+  gobject_class->dispose = gst_spacemitsrc_dispose;
+  gobject_class->finalize = gst_spacemitsrc_finalize;
+
+  gst_element_class_add_pad_template (gstelement_class,
+      gst_static_pad_template_get (&gst_spacemitsrc_src_template));
+
+  gst_element_class_set_static_metadata (gstelement_class,
+      "k1x cam Video Source", "Source/Video",
+      "k1x cam spacemit video source", "zhirong.li@spacemit.com");
+
+  gstbasesrc_class->start = GST_DEBUG_FUNCPTR (gst_spacemitsrc_start);
+  gstbasesrc_class->stop = GST_DEBUG_FUNCPTR (gst_spacemitsrc_stop);
+  gstbasesrc_class->get_caps = GST_DEBUG_FUNCPTR (gst_spacemitsrc_get_caps);
+  gstbasesrc_class->set_caps = GST_DEBUG_FUNCPTR (gst_spacemitsrc_set_caps);
+  gstbasesrc_class->unlock = GST_DEBUG_FUNCPTR (gst_spacemitsrc_unlock);
+  gstbasesrc_class->unlock_stop = GST_DEBUG_FUNCPTR (gst_spacemitsrc_unlock_stop);
+  gstbasesrc_class->decide_allocation = GST_DEBUG_FUNCPTR (gst_spacemitsrc_decide_allocation);
+  gstpushsrc_class->create = GST_DEBUG_FUNCPTR (gst_spacemitsrc_create);
+
+  /* Install GObject properties */
+  g_object_class_install_property (gobject_class, PROP_LOCATION,
+      g_param_spec_string ("location", "File Location",
+          "Location of the file to read", NULL,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS |
+          GST_PARAM_MUTABLE_READY));
+  g_object_class_install_property (gobject_class, PROP_DEVICE_INDEX,
+      g_param_spec_int ("device-index", "Device index",
+          "Index of device, use -1 to enumerate all and select last", -1,
+          G_MAXINT, DEFAULT_PROP_DEVICE_INDEX,
+          (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
+  g_object_class_install_property (gobject_class, PROP_NUM_CAPTURE_BUFFERS,
+      g_param_spec_uint ("num-capture-buffers", "Number of capture buffers",
+          "Number of capture buffers", 1, G_MAXUINT,
+          DEFAULT_PROP_NUM_CAPTURE_BUFFERS,
+          (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
+  g_object_class_install_property (G_OBJECT_CLASS (klass), PROP_TIMEOUT,
+      g_param_spec_int ("timeout", "Timeout (ms)",
+          "Timeout in ms to wait for a frame beyond exposure time", 0, G_MAXINT,
+          DEFAULT_PROP_TIMEOUT,
+          (GParamFlags) (G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE)));
+  g_object_class_install_property (G_OBJECT_CLASS (klass), PROP_EXPOSURE,
+      g_param_spec_uint ("exposure", "Exposure (us)",
+          "Exposure time in microseconds", 0, G_MAXINT, DEFAULT_PROP_EXPOSURE,
+          (GParamFlags) (G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE)));
+  g_object_class_install_property (G_OBJECT_CLASS (klass), PROP_GAIN,
+      g_param_spec_double ("gain", "Normalized gain", "Normalized gain", 0,
+          1000, DEFAULT_PROP_GAIN,
+          (GParamFlags) (G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE)));
+  g_object_class_install_property (G_OBJECT_CLASS (klass), PROP_OFFSET,
+      g_param_spec_int ("offset", "Offset", "Absolute offset", -G_MAXINT,
+          G_MAXINT, DEFAULT_PROP_OFFSET,
+          (GParamFlags) (G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE)));
+  g_object_class_install_property (G_OBJECT_CLASS (klass), PROP_FORMAT,
+      g_param_spec_int ("format", "Image format",
+          "Image format (2=GRAY8, 3=GRAY16_LE)", 2, 3, DEFAULT_PROP_FORMAT,
+          (GParamFlags) (G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE)));
+  g_object_class_install_property (G_OBJECT_CLASS (klass), PROP_X,
+      g_param_spec_int ("x", "ROI x pixel", "ROI x pixel position", 0, G_MAXINT,
+          DEFAULT_PROP_X,
+          (GParamFlags) (G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE)));
+  g_object_class_install_property (G_OBJECT_CLASS (klass), PROP_Y,
+      g_param_spec_int ("y", "ROI y pixel", "ROI y pixel position", 0, G_MAXINT,
+          DEFAULT_PROP_Y,
+          (GParamFlags) (G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE)));
+  g_object_class_install_property (G_OBJECT_CLASS (klass), PROP_WIDTH,
+      g_param_spec_int ("width", "ROI width", "ROI width", 0, G_MAXINT,
+          DEFAULT_PROP_WIDTH,
+          (GParamFlags) (G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE)));
+  g_object_class_install_property (G_OBJECT_CLASS (klass), PROP_HEIGHT,
+      g_param_spec_int ("height", "ROI height", "ROI height", 0, G_MAXINT,
+          DEFAULT_PROP_HEIGHT,
+          (GParamFlags) (G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE)));
+  g_object_class_install_property (G_OBJECT_CLASS (klass), PROP_BINNING,
+      g_param_spec_int ("binning", "Binning", "Symmetrical binning", 1, 8,
+          DEFAULT_PROP_BINNING,
+          (GParamFlags) (G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE)));
+}
+
+static void
+gst_spacemitsrc_reset (GstSpacemitSrc * src)
+{
+//  src->handle = NULL;
+
+  src->exposure = DEFAULT_PROP_EXPOSURE;
+  src->gain = DEFAULT_PROP_GAIN;
+  src->offset = DEFAULT_PROP_OFFSET;
+  src->format = DEFAULT_PROP_FORMAT;
+  src->x = DEFAULT_PROP_X;
+  src->y = DEFAULT_PROP_Y;
+  src->width = DEFAULT_PROP_WIDTH;
+  src->height = DEFAULT_PROP_HEIGHT;
+  src->binning = DEFAULT_PROP_BINNING;
+
+  src->last_frame_count = 0;
+  src->total_dropped_frames = 0;
+
+  if (src->caps) {
+    gst_caps_unref (src->caps);
+    src->caps = NULL;
+  }
+
+  if (src->queue) {
+    // TODO: remove dangling buffers
+    g_async_queue_unref (src->queue);
+  }
+  src->queue = g_async_queue_new ();
+  g_async_queue_ref (src->queue);
+  GST_DEBUG_OBJECT (src, "new queue %p", src->queue);
+}
+
+static void
+gst_spacemitsrc_init (GstSpacemitSrc * src)
+{
+  GST_DEBUG_OBJECT (src, "Initialize instance");
+
+  gst_spacemitsrc_driver_ref ();
+
+  /* set source as live (no preroll) */
+  gst_base_src_set_live (GST_BASE_SRC (src), TRUE);
+
+  /* override default of BYTES to operate in time mode */
+  gst_base_src_set_format (GST_BASE_SRC (src), GST_FORMAT_TIME);
+
+  /* initialize member variables */
+  src->device_index = DEFAULT_PROP_DEVICE_INDEX;
+  src->num_capture_buffers = DEFAULT_PROP_NUM_CAPTURE_BUFFERS;
+  src->timeout = DEFAULT_PROP_TIMEOUT;
+
+  src->stop_requested = FALSE;
+  src->caps = NULL;
+  src->queue = NULL;
+
+  frame_hash = g_hash_table_new (g_direct_hash, g_direct_equal);
+  gst_spacemitsrc_reset (src);
+}
+
+
+static void
+gst_spacemitsrc_set_exposure (GstSpacemitSrc * src, unsigned long exposure)
+{
+  //SPACEMIT_SetParam (&src->qsettings, qprmExposure, exposure);
+}
+
+static void
+gst_spacemitsrc_set_gain (GstSpacemitSrc * src, float gain)
+{
+  //SPACEMIT_SetParam (&src->qsettings, qprmNormalizedGain,
+  //    (unsigned long) (gain * 1000000));
+}
+
+static void
+gst_spacemitsrc_set_offset (GstSpacemitSrc * src, long offset)
+{
+  //SPACEMIT_SetParamS32 (&src->qsettings, qprmS32AbsoluteOffset, offset);
+}
+static gboolean
+gst_spacemitsrc_set_location (GstSpacemitSrc *src, const gchar * location)
+{
+  g_free (src->filename);
+
+  /* clear the filename if we get a NULL */
+  if (location == NULL) {
+    src->filename = NULL;
+  } else {
+    /* we store the filename as received by the application. On Windows this
+     * should be UTF8 */
+    src->filename = g_strdup (location);
+    GST_INFO_OBJECT (src, "filename : %s", src->filename);
+  }
+
+  return 0;
+}
+
+void
+gst_spacemitsrc_set_property (GObject * object, guint property_id,
+    const GValue * value, GParamSpec * pspec)
+{
+  GstSpacemitSrc *src;
+
+  src = GST_SPACEMIT_SRC (object);
+
+  switch (property_id) {
+    case PROP_LOCATION:
+      gst_spacemitsrc_set_location (src, g_value_get_string (value));
+      break;
+    case PROP_DEVICE_INDEX:
+      src->device_index = g_value_get_int (value);
+      break;
+    case PROP_NUM_CAPTURE_BUFFERS:
+      src->num_capture_buffers = g_value_get_uint (value);
+      break;
+    case PROP_TIMEOUT:
+      src->timeout = g_value_get_int (value);
+      break;
+    case PROP_EXPOSURE:
+      src->exposure = g_value_get_uint (value);
+      src->send_settings = TRUE;
+      break;
+    case PROP_GAIN:
+      src->gain = g_value_get_double (value);
+      src->send_settings = TRUE;
+      break;
+    case PROP_OFFSET:
+      src->offset = g_value_get_int (value);
+      src->send_settings = TRUE;
+      break;
+    case PROP_FORMAT:
+      src->format = g_value_get_int (value);
+      break;
+    case PROP_X:
+      src->x = g_value_get_int (value);
+      break;
+    case PROP_Y:
+      src->y = g_value_get_int (value);
+      break;
+    case PROP_WIDTH:
+      src->width = GST_ROUND_DOWN_4 (g_value_get_int (value));
+      break;
+    case PROP_HEIGHT:
+      src->height = g_value_get_int (value);
+      break;
+    case PROP_BINNING:
+      src->binning = g_value_get_int (value);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+      break;
+  }
+}
+
+void
+gst_spacemitsrc_get_property (GObject * object, guint property_id,
+    GValue * value, GParamSpec * pspec)
+{
+  GstSpacemitSrc *src;
+
+  g_return_if_fail (GST_IS_SPACEMIT_SRC (object));
+  src = GST_SPACEMIT_SRC (object);
+
+  switch (property_id) {
+    case PROP_LOCATION:
+      g_value_set_string (value, src->filename);
+      break;
+    case PROP_DEVICE_INDEX:
+      g_value_set_int (value, src->device_index);
+      break;
+    case PROP_NUM_CAPTURE_BUFFERS:
+      g_value_set_uint (value, src->num_capture_buffers);
+      break;
+    case PROP_TIMEOUT:
+      g_value_set_int (value, src->timeout);
+      break;
+    case PROP_EXPOSURE:
+      g_value_set_uint (value, src->exposure);
+      break;
+    case PROP_GAIN:
+      g_value_set_double (value, src->gain);
+      break;
+    case PROP_OFFSET:
+      g_value_set_int (value, src->offset);
+      break;
+    case PROP_FORMAT:
+      g_value_set_int (value, src->format);
+      break;
+    case PROP_X:
+      g_value_set_int (value, src->x);
+      break;
+    case PROP_Y:
+      g_value_set_int (value, src->y);
+      break;
+    case PROP_WIDTH:
+      g_value_set_int (value, src->width);
+      break;
+    case PROP_HEIGHT:
+      g_value_set_int (value, src->height);
+      break;
+    case PROP_BINNING:
+      g_value_set_int (value, src->binning);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+      break;
+  }
+}
+
+void
+gst_spacemitsrc_dispose (GObject * object)
+{
+  GstSpacemitSrc *src;
+
+  g_return_if_fail (GST_IS_SPACEMIT_SRC (object));
+  src = GST_SPACEMIT_SRC (object);
+
+  /* clean up as possible.  may be called multiple times */
+
+  G_OBJECT_CLASS (gst_spacemitsrc_parent_class)->dispose (object);
+}
+
+void
+gst_spacemitsrc_finalize (GObject * object)
+{
+  GstSpacemitSrc *src;
+
+  g_return_if_fail (GST_IS_SPACEMIT_SRC (object));
+  src = GST_SPACEMIT_SRC (object);
+
+  /* clean up object here */
+
+  if (src->caps) {
+    gst_caps_unref (src->caps);
+    src->caps = NULL;
+  }
+
+  gst_spacemitsrc_driver_unref ();
+
+  G_OBJECT_CLASS (gst_spacemitsrc_parent_class)->finalize (object);
+}
+
+typedef struct
+{
+  gint fd;
+  IMAGE_BUFFER_S* outputBuf;
+  GstSpacemitSrc *src;
+  GstClockTime clock_time;
+  GstBuffer *gstbuf;
+} VideoFrame;
+
+static void
+video_frame_release (void *data)
+{
+  IMAGE_BUFFER_S* outputBuf = (IMAGE_BUFFER_S *) data;
+  {
+    VideoFrame * frame = (VideoFrame *) g_hash_table_lookup (frame_hash, outputBuf);
+    if (!frame) {
+      CLOG_ERROR("can't get a videoframe from key %p", outputBuf);
+    } else {
+      GST_DEBUG_OBJECT (frame->src, "get cpp output buffer %p back, the gstbuffer is %p", outputBuf, frame->gstbuf);
+    }
+    //List_Push out buffer to list
+    // List_Push(cpp_out_list[0], (void*)outputBuf);
+    gst_release_cpp_buffer(outputBuf);
+  }
+}
+
+static VideoFrame *
+video_frame_create (GstSpacemitSrc * src, IMAGE_BUFFER_S* buffer)
+{
+  VideoFrame *frame = g_new (VideoFrame, 1);
+
+  frame->src = src;
+  frame->outputBuf = buffer;
+  frame->fd = buffer->m.fd;
+
+  return frame;
+}
+
+static int gst_get_cpp_buf_callback(IMAGE_BUFFER_S* cpp_out_buffer)
+{
+  VideoFrame * frame = (VideoFrame *) g_hash_table_lookup (frame_hash, cpp_out_buffer);
+  if (!frame) {
+    CLOG_ERROR("can't get a videoframe from key %p", cpp_out_buffer);
+    return -EINVAL;
+  }
+  GstClock *clock = gst_element_get_clock (GST_ELEMENT (frame->src));
+  frame->clock_time = gst_clock_get_time (clock);
+  gst_object_unref (clock);
+  CLOG_INFO("PUSH a cpp output buffer to queue");
+
+  g_async_queue_push (frame->src->queue, cpp_out_buffer);
+  GST_DEBUG_OBJECT (frame->src, "PUSH a cpp output buffer %p to queue %p, now queue had %d buffer",
+    cpp_out_buffer, frame->src->queue, g_async_queue_length(frame->src->queue));
+
+  return 0;
+}
+
+static int gst_cpp_buf_prepare_callback(void *gst_buf_prepare_data, IMAGE_BUFFER_S* buffer)
+{
+  GstSpacemitSrc * src  = (GstSpacemitSrc *) gst_buf_prepare_data;
+
+  VideoFrame *frame = video_frame_create (src, buffer);
+  g_hash_table_insert(frame_hash, buffer, frame);
+
+  return 0;
+}
+
+static gboolean
+gst_spacemitsrc_setup_stream (GstSpacemitSrc * src)
+{
+  int ret = 0;
+  void* sensorHandle = NULL;
+  SENSOR_MODULE_INFO sensor_info;
+  int pipelineId = 0;
+  int firmwareId = 0;
+  int viChnId = 0;
+  int rawdumpChnId = 0;
+  IMAGE_INFO_S img_info = {};
+  struct tuning_objs_config tuning_cfg = {0};
+
+  GST_DEBUG_OBJECT (src, "start setup stream camera, json:%s", src->filename);
+  src->para.gst_get_cpp_buffer = gst_get_cpp_buf_callback;
+  src->para.gst_cpp_buf_prepare = gst_cpp_buf_prepare_callback;
+  src->para.gst_cpp_buf_prepare_data = src;
+  src->para.jsonfile = src->filename;
+
+  ret = gst_setup_camera_start (&src->para);
+  if (ret) {
+    GST_ERROR_OBJECT (src, "setup stream camera fail! ret: %d", ret);
+    return FALSE;
+  }
+
+  src->pipelineId = pipelineId;
+  src->firmwareId = firmwareId;
+  src->sensorHandle = sensorHandle;
+  src->sensorInfoId = sensor_info.sensorId;
+
+  GST_DEBUG_OBJECT (src, "sensor stream on");
+  {
+    GstStructure *structure;
+    GstCaps *caps;
+    caps = gst_caps_new_empty ();
+    structure = gst_structure_from_string ("video/x-raw", NULL);
+    const char *gst_format;
+    gst_format = "NV12";
+    gst_structure_set (structure,
+        "format", G_TYPE_STRING, gst_format,
+        "width", G_TYPE_INT, src->para.out_width,
+        "height", G_TYPE_INT, src->para.out_height,
+        "framerate", GST_TYPE_FRACTION, 30, 1, NULL);
+    gst_caps_append_structure (caps, structure);
+
+    if (src->caps) {
+      gst_caps_unref (src->caps);
+    }
+    gst_caps_set_features (caps, 0,
+      gst_caps_features_new (GST_CAPS_FEATURE_MEMORY_DMABUF, NULL));
+    GST_INFO_OBJECT (src, "set DMABUF feature to spacemitsrc src cap %" GST_PTR_FORMAT, caps);
+    src->caps = caps;
+    gst_base_src_set_caps (GST_BASE_SRC (src), src->caps);
+  }
+
+  GST_DEBUG_OBJECT (src, "finish setup stream camera");
+  return TRUE;
+}
+
+static gboolean
+gst_spacemitsrc_start (GstBaseSrc * bsrc)
+{
+  GstSpacemitSrc *src = GST_SPACEMIT_SRC (bsrc);
+
+  GST_DEBUG_OBJECT (src, "start");
+
+  if (!gst_spacemitsrc_setup_stream (src)) {
+    GST_ERROR_OBJECT (src, "setup stream error");
+    /* error already sent */
+    return FALSE;
+  }
+  GST_DEBUG_OBJECT (src, "finish start");
+  return TRUE;
+}
+
+static gboolean
+gst_spacemitsrc_stop (GstBaseSrc * bsrc)
+{
+  GstSpacemitSrc *src = GST_SPACEMIT_SRC (bsrc);
+  GST_DEBUG_OBJECT (src, "stop");
+
+  if (src->handle) {
+    //SPACEMIT_CloseCamera (src->handle);
+    src->handle = NULL;
+  }
+
+  gst_setup_camera_stop (&src->para);
+  GST_DEBUG_OBJECT (src, "sensor stream off");
+  gst_spacemitsrc_reset (src);
+
+  return TRUE;
+}
+
+static GstCaps *
+gst_spacemitsrc_get_caps (GstBaseSrc * bsrc, GstCaps * filter)
+{
+  GstSpacemitSrc *src = GST_SPACEMIT_SRC (bsrc);
+  GstCaps *caps;
+
+  if (src->caps == NULL) {
+    caps = gst_pad_get_pad_template_caps (GST_BASE_SRC_PAD (src));
+  } else {
+    caps = gst_caps_copy (src->caps);
+  }
+
+  GST_DEBUG_OBJECT (src, "The caps before filtering are %" GST_PTR_FORMAT,
+      caps);
+
+  if (filter && caps) {
+    GstCaps *tmp = gst_caps_intersect (caps, filter);
+    gst_caps_unref (caps);
+    caps = tmp;
+  }
+
+  GST_DEBUG_OBJECT (src, "The caps after filtering are %" GST_PTR_FORMAT, caps);
+
+  return caps;
+}
+
+static gboolean
+gst_spacemitsrc_set_caps (GstBaseSrc * bsrc, GstCaps * caps)
+{
+  GstSpacemitSrc *src = GST_SPACEMIT_SRC (bsrc);
+
+  GST_DEBUG_OBJECT (src, "The caps being set are %" GST_PTR_FORMAT, caps);
+
+  return TRUE;
+}
+
+static gboolean
+gst_spacemitsrc_unlock (GstBaseSrc * bsrc)
+{
+  GstSpacemitSrc *src = GST_SPACEMIT_SRC (bsrc);
+
+  GST_LOG_OBJECT (src, "unlock");
+
+  src->stop_requested = TRUE;
+
+  return TRUE;
+}
+
+static gboolean
+gst_spacemitsrc_unlock_stop (GstBaseSrc * bsrc)
+{
+  GstSpacemitSrc *src = GST_SPACEMIT_SRC (bsrc);
+
+  GST_LOG_OBJECT (src, "unlock_stop");
+
+  src->stop_requested = FALSE;
+
+  return TRUE;
+}
+
+static gboolean
+gst_spacemitsrc_decide_allocation (GstBaseSrc * bsrc, GstQuery * query)
+{
+  GstSpacemitSrc *src = GST_SPACEMIT_SRC (bsrc);
+  GstAllocator *allocator = NULL;
+  gint nallocator;
+  GstAllocationParams params;
+  GstBufferPool *pool = NULL;
+  guint size, min = 1, max = 0;
+
+  GST_DEBUG_OBJECT (src, "decide_allocation be params: %" GST_PTR_FORMAT, query);
+  allocator = gst_spacemit_src_allocator_new ();
+  if (!allocator)
+    goto error_no_allocator;
+
+  src->allocator = allocator;
+
+  while (gst_query_get_n_allocation_pools (query) > 0) {
+    // gst_query_parse_nth_allocation_pool (query, 0, &pool, &size, &min, &max);
+    GST_DEBUG_OBJECT (src, "------------------ 2222");
+
+    gst_query_remove_nth_allocation_pool (query, 0);
+    // gst_object_unref (pool);
+    pool = NULL;
+  }
+
+  while (gst_query_get_n_allocation_params (query) > 0) {
+    GST_DEBUG_OBJECT (src, "------------------ 3333");
+    gst_query_remove_nth_allocation_param (query, 0);
+  }
+
+  nallocator = gst_query_get_n_allocation_params (query);
+  if (nallocator > 0) {
+    GST_ERROR_OBJECT (src, "get %d allocators from query", nallocator);
+    return FALSE;
+  } else {
+    gst_allocation_params_init (&params);
+    gst_query_add_allocation_param (query, allocator, NULL);
+    gst_object_unref (allocator);
+  }
+
+  GST_DEBUG_OBJECT (src, "get %d allocators from query, dma allocator:%d",
+    nallocator, GST_IS_DMABUF_ALLOCATOR(src->allocator));
+
+  GST_DEBUG_OBJECT (src, "decide_allocation af params: %" GST_PTR_FORMAT, query);
+  if (!GST_BASE_SRC_CLASS(gst_spacemitsrc_parent_class)->decide_allocation(bsrc, query))
+    return FALSE;
+
+  return TRUE;
+
+error_no_allocator:
+{
+  GST_ERROR_OBJECT (src, "failed to create allocator");
+  return FALSE;
+}
+}
+
+static GstFlowReturn
+gst_spacemitsrc_create (GstPushSrc * psrc, GstBuffer ** buf)
+{
+  GstSpacemitSrc *src = GST_SPACEMIT_SRC (psrc);
+  VideoFrame *video_frame;
+  GST_DEBUG_OBJECT (src, "create");
+  IMAGE_BUFFER_S* outputBuf;
+
+  //wait queue and get cpp output buffer
+  outputBuf =
+      (IMAGE_BUFFER_S *) g_async_queue_timeout_pop (src->queue,
+      (guint64) 100 * 1000 * 1000);
+  if (!outputBuf) {
+      GST_ELEMENT_ERROR (src, RESOURCE, OPEN_READ,
+          ("Failed to get buffer in %d ms, queue %p had %d buffer", src->timeout, src->queue, g_async_queue_length(src->queue)), (NULL));
+      return GST_FLOW_ERROR;
+  }
+  GST_DEBUG_OBJECT (src, "pop a cpp output buffer %p", outputBuf);
+  video_frame = (VideoFrame *) g_hash_table_lookup (frame_hash, outputBuf);
+  if (!video_frame) {
+    CLOG_ERROR("can't get a videoframe from key %p", outputBuf);
+    return GST_FLOW_ERROR;
+  }
+
+  GstBuffer *newbuf;
+  GstMemory *mem;
+  newbuf = gst_buffer_new ();
+  mem = gst_dmabuf_allocator_alloc_with_flags (src->allocator, video_frame->fd,
+    src->para.out_width * src->para.out_height * 1.5, GST_FD_MEMORY_FLAG_DONT_CLOSE);
+  gst_mini_object_set_qdata (GST_MINI_OBJECT (mem), GST_SPACEMIT_SRC_DMABUF_MEMORY_QUARK, outputBuf,
+     video_frame_release);
+  gst_buffer_append_memory (newbuf, mem);
+
+  //bind release func to cpp output buffer 
+  // *buf = gst_buffer_new_wrapped_full ((GstMemoryFlags)
+  //     GST_MEMORY_FLAG_PHYSICALLY_CONTIGUOUS,
+  //     (gpointer) outputBuf->planes[0].virAddr, 640*480*1.5, 0,
+  //     640*480*1.5, outputBuf,
+  //     (GDestroyNotify) video_frame_release);
+
+  *buf = newbuf;
+  video_frame->gstbuf = *buf;
+  GST_BUFFER_TIMESTAMP (*buf) =
+      GST_CLOCK_DIFF (gst_element_get_base_time (GST_ELEMENT (src)),
+      video_frame->clock_time);
+  GST_DEBUG_OBJECT (src, "gst buffer %p reture from create, no close fd: %d ", *buf, video_frame->fd);
+
+  return GST_FLOW_OK;
+}
+
+static gboolean
+plugin_init (GstPlugin * plugin)
+{
+  GST_DEBUG_CATEGORY_INIT (GST_CAT_DEFAULT, "spacemitsrc", 0,
+      "debug category for spacemitsrc plugin");
+
+  if (!gst_element_register (plugin, "spacemitsrc", GST_RANK_NONE,
+          gst_spacemitsrc_get_type ())) {
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
+GST_PLUGIN_DEFINE (GST_VERSION_MAJOR,
+    GST_VERSION_MINOR,
+    spacemitsrc,
+    "spacemitsrc video element",
+    plugin_init, VERSION, "LGPL", GST_PACKAGE_NAME,
+    GST_PACKAGE_ORIGIN)
diff --git a/ext/spacemit/spacemitsrc/gstspacemitsrc.h b/ext/spacemit/spacemitsrc/gstspacemitsrc.h
new file mode 100755
index 0000000..5c657ca
--- /dev/null
+++ b/ext/spacemit/spacemitsrc/gstspacemitsrc.h
@@ -0,0 +1,99 @@
+/* GStreamerspacemitsrc
+ * Copyright (C) 2021 FIXME <fixme@example.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _GST_SPACEMIT_SRC_H_
+#define _GST_SPACEMIT_SRC_H_
+
+#include <gst/base/gstpushsrc.h>
+#include "gstspmsrcallocator.h"
+#include "gst_cam_api.h"
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_SPACEMIT_SRC   (gst_spacemitsrc_get_type())
+#define GST_SPACEMIT_SRC(obj)   (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SPACEMIT_SRC,GstSpacemitSrc))
+#define GST_SPACEMIT_SRC_CLASS(klass)   (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SPACEMIT_SRC,GstSpacemitSrcClass))
+#define GST_IS_SPACEMIT_SRC(obj)   (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SPACEMIT_SRC))
+#define GST_IS_SPACEMIT_SRC_CLASS(obj)   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SPACEMIT_SRC))
+
+#ifndef GST_CAPS_FEATURE_MEMORY_DMABUF
+#define GST_CAPS_FEATURE_MEMORY_DMABUF "memory:DMABuf"
+#endif
+
+#define SPM_SRC_OUT_FORMATS "I420, NV21, NV12"
+#define SPM_SRC_FORMATS SPM_SRC_OUT_FORMATS
+//#define SPM_DEC_CAPS_MAKE(fmts) \
+//    GST_VIDEO_CAPS_MAKE (fmts) ";"
+#define SPM_SRC_CAPS_MAKE(fmts) \
+    GST_VIDEO_CAPS_MAKE (fmts) ";" \
+    GST_VIDEO_CAPS_MAKE_WITH_FEATURES (GST_CAPS_FEATURE_MEMORY_DMABUF, fmts)
+
+typedef struct _GstSpacemitSrc GstSpacemitSrc;
+typedef struct _GstSpacemitSrcClass GstSpacemitSrcClass;
+
+struct _GstSpacemitSrc
+{
+  GstPushSrc base_spacemitsrc;
+
+  /* camera handle */
+  gboolean send_settings;
+  gint *handle;
+  /* properties */
+  gint device_index;
+  guint num_capture_buffers;
+  gint timeout;
+  guint exposure;
+  gdouble gain;
+  gint offset;
+  gint format;
+  gint x;
+  gint y;
+  gint width;
+  gint height;
+  gint binning;
+
+  GAsyncQueue *queue;
+  GstClockTime base_time;
+
+  guint32 last_frame_count;
+  guint32 total_dropped_frames;
+
+  GstCaps *caps;
+  gboolean stop_requested;
+
+  GstAllocator *allocator;
+  gchar *filename;
+
+  struct gstParam para;
+  gint sensorInfoId;
+  gint pipelineId;
+  gint firmwareId;
+  void* sensorHandle;
+};
+
+struct _GstSpacemitSrcClass
+{
+  GstPushSrcClass base_spacemitsrc_class;
+};
+
+GType gst_spacemitsrc_get_type (void);
+
+G_END_DECLS
+
+#endif
diff --git a/ext/spacemit/spacemitsrc/gstspmsrcallocator.c b/ext/spacemit/spacemitsrc/gstspmsrcallocator.c
new file mode 100755
index 0000000..28b4704
--- /dev/null
+++ b/ext/spacemit/spacemitsrc/gstspmsrcallocator.c
@@ -0,0 +1,143 @@
+/* GStreamer
+ *
+ * Copyright (C) 2016 Igalia
+ *
+ * Authors:
+ *  Víctor Manuel Jáquez Leal <vjaquez@igalia.com>
+ *  Javier Martin <javiermartin@by.com.es>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "gstspmsrcallocator.h"
+
+#define GST_CAT_DEFAULT spacemit_src_allocator_debug_category
+GST_DEBUG_CATEGORY_STATIC (GST_CAT_DEFAULT);
+
+#define GST_SPACEMIT_SRC_MEMORY_TYPE "SpaceMitSrcMemory"
+
+#define parent_class gst_spacemit_src_allocator_parent_class
+
+G_DEFINE_TYPE_WITH_CODE (GstSpaceMitSrcAllocator, gst_spacemit_src_allocator,
+    GST_TYPE_DMABUF_ALLOCATOR,
+    GST_DEBUG_CATEGORY_INIT (GST_CAT_DEFAULT, "spacemitsrcallocator", 0,
+    "Spacemit Src Dma allocator"));
+
+GQuark
+gst_spacemit_src_dmabuf_memory_quark (void)
+{
+  static GQuark quark = 0;
+
+  if (quark == 0)
+    quark = g_quark_from_static_string ("GstSpacemitSrcDmabufMemory");
+
+  return quark;
+}
+
+static void
+gst_spacemit_src_allocator_free (GstAllocator * allocator, GstMemory * base_mem)
+{
+  GST_DEBUG ("ZRong ------------------- spacemit free mem");
+
+}
+
+static void
+gst_spacemit_src_allocator_finalize (GObject * obj)
+{
+  GstSpaceMitSrcAllocator *alloc = GST_SPACEMIT_SRC_ALLOCATOR (obj);
+  GST_DEBUG_OBJECT (alloc, "ZRong ------------------- spacemit allocator finalize");
+
+  G_OBJECT_CLASS (parent_class)->finalize (obj);
+}
+
+// GstMemory *
+// gst_spacemit_src_allocator_alloc (GstSpaceMitSrcAllocator * allocator, gsize size)
+// {
+//   GST_DEBUG_OBJECT (allocator, "ZRong ------------------- spacemit allocator alloc");
+
+//   GstMemory *ret_mem = NULL;
+//   // GstSpaceMitMemory *mem;
+//   // guint8 *data;
+
+//   // GST_DEBUG_OBJECT (allocator, "allocator alloc paras, size: %d", size);
+
+//   // if (allocator->mode == GST_SPM_MEMORY_TYPE_SYSTEM) {
+//   //   mem = gst_spacemit_memory_new (allocator, size, 0, NULL, 0, size);
+//   //   install_mem_dispose (GST_MEMORY_CAST (mem));
+//   // } else {
+//   //   mem = g_slice_new0 (GstSpaceMitMemory);
+//   //   mem->memsize = size;
+//   //   mem->acquired = FALSE;
+//   //   mem->fd = allocator->dmabuf_fd;
+
+//   //   mem->foreign_mem =
+//   //       gst_fd_allocator_alloc (allocator->foreign_allocator, allocator->dmabuf_fd, size, GST_FD_MEMORY_FLAG_DONT_CLOSE);
+//   //   gst_mini_object_set_qdata (GST_MINI_OBJECT (mem->foreign_mem),
+//   //       GST_SPM_DMABUF_MEMORY_QUARK, mem, NULL);
+//   //   gst_mini_object_set_qdata (GST_MINI_OBJECT (mem->foreign_mem),
+//   //       GST_SPACEMIT_ALLOCATOR_QUARK, allocator, NULL);
+//   //   install_mem_dispose (mem->foreign_mem);
+//   // }
+
+//   // ret_mem = mem->foreign_mem ? mem->foreign_mem : (GstMemory *) mem;
+
+//   // GST_DEBUG_OBJECT (allocator, "allocator success alloc mem:%p, return mem:%p", mem, ret_mem);
+
+//   return ret_mem;
+// }
+
+GstAllocator *
+gst_spacemit_src_allocator_new (void)
+{
+  GstSpaceMitSrcAllocator *allocator;
+
+  allocator = g_object_new (GST_TYPE_SPACEMIT_SRC_ALLOCATOR, NULL);
+
+  return GST_ALLOCATOR_CAST (allocator);
+}
+
+static void
+gst_spacemit_src_allocator_class_init (GstSpaceMitSrcAllocatorClass * klass)
+{
+  GObjectClass *gobject_class;
+  GstAllocatorClass *allocator_class;
+
+  allocator_class = GST_ALLOCATOR_CLASS (klass);
+  gobject_class = G_OBJECT_CLASS (klass);
+
+  // allocator_class->alloc = gst_spacemit_src_allocator_alloc;
+  // allocator_class->free = gst_spacemit_src_allocator_free;
+
+  gobject_class->finalize = gst_spacemit_src_allocator_finalize;
+}
+
+static void
+gst_spacemit_src_allocator_init (GstSpaceMitSrcAllocator * allocator)
+{
+  GstAllocator *alloc = GST_ALLOCATOR_CAST (allocator);
+
+  alloc->mem_type = GST_SPACEMIT_SRC_MEMORY_TYPE;
+  // alloc->mem_map = gst_spacemit_memory_map;
+  // alloc->mem_unmap = gst_spacemit_memory_unmap;
+
+  // GST_OBJECT_FLAG_SET (allocator, GST_ALLOCATOR_FLAG_CUSTOM_ALLOC);
+}
+
diff --git a/ext/spacemit/spacemitsrc/gstspmsrcallocator.h b/ext/spacemit/spacemitsrc/gstspmsrcallocator.h
new file mode 100755
index 0000000..592df02
--- /dev/null
+++ b/ext/spacemit/spacemitsrc/gstspmsrcallocator.h
@@ -0,0 +1,131 @@
+/* GStreamer
+ *
+ * Copyright (C) 2016 Igalia
+ *
+ * Authors:
+ *  Víctor Manuel Jáquez Leal <vjaquez@igalia.com>
+ *  Javier Martin <javiermartin@by.com.es>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ *
+ */
+
+#ifndef __GST_SPACEMIT_SRC_ALLOCATOR_H__
+#define __GST_SPACEMIT_SRC_ALLOCATOR_H__
+
+#include <gst/gst.h>
+#include <gst/video/video.h>
+#include <gst/allocators/gstdmabuf.h>
+
+G_BEGIN_DECLS
+
+/* ---------------------------------------------------------------------*/
+/* GstSpmSystemoMemory                                                  */
+/* ---------------------------------------------------------------------*/
+
+#define GST_TYPE_SPACEMIT_SRC_ALLOCATOR	\
+   (gst_spacemit_src_allocator_get_type())
+#define GST_IS_SPACEMIT_SRC_ALLOCATOR(obj)				\
+   (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_SPACEMIT_SRC_ALLOCATOR))
+#define GST_IS_SPACEMIT_SRC_ALLOCATOR_CLASS(klass)			\
+   (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_SPACEMIT_SRC_ALLOCATOR))
+#define GST_SPACEMIT_SRC_ALLOCATOR_GET_CLASS(obj)			\
+   (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_SPACEMIT_SRC_ALLOCATOR, GstSpaceMitSrcAllocatorClass))
+#define GST_SPACEMIT_SRC_ALLOCATOR(obj)				\
+   (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_SPACEMIT_SRC_ALLOCATOR, GstSpaceMitSrcAllocator))
+#define GST_SPACEMIT_SRC_ALLOCATOR_CLASS(klass)			\
+   (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_SPACEMIT_SRC_ALLOCATOR, GstSpaceMitSrcAllocatorClass))
+
+typedef struct _GstSpaceMitSrcAllocator GstSpaceMitSrcAllocator;
+typedef struct _GstSpaceMitSrcAllocatorClass GstSpaceMitSrcAllocatorClass;
+typedef struct _GstSpaceMitSrcMemory GstSpaceMitSrcMemory;
+
+// typedef enum _GstSpmMemoryType
+// {
+//   GST_SPM_MEMORY_TYPE_SYSTEM,
+//   GST_SPM_MEMORY_TYPE_DMABUF,
+// } GstSpmMemoryType;
+
+struct _GstSpaceMitSrcMemory
+{
+  GstMemory parent;
+
+//   gboolean acquired;
+//   MppFrame *mppframe;
+//   gpointer ptr;
+
+//   MppVdecCtx *ctx;
+//   guint32 memsize;
+//   gint32 mppframe_id;
+//   GstMemory *foreign_mem;
+
+//   guint32 fd;
+//   /* the original dispose function of foreign_mem */
+//   GstMiniObjectDisposeFunction foreign_dispose;
+};
+
+struct _GstSpaceMitSrcAllocator
+{
+  GstDmaBufAllocator parent;
+//   gboolean active;
+//   GMutex lock;
+
+//   GHashTable *memories;
+//   gint32 mppframe_id;
+//   gint32 dmabuf_fd;
+//   guint32 id;
+//   GstVideoInfo info;
+//   GstAllocator *foreign_allocator;
+//   GstSpmMemoryType mode;
+//   gboolean mem_back;
+};
+
+struct _GstSpaceMitSrcAllocatorClass {
+  GstDmaBufAllocatorClass parent_class;
+};
+GQuark gst_spacemit_src_dmabuf_memory_quark (void);
+// GQuark gst_spacemit_allocator_quark (void);
+
+#define GST_SPACEMIT_SRC_DMABUF_MEMORY_QUARK gst_spacemit_src_dmabuf_memory_quark ()
+// #define GST_SPACEMIT_ALLOCATOR_QUARK gst_spacemit_allocator_quark ()
+
+// gboolean gst_is_spacemit_memory (GstMemory *mem);
+// GstAllocator *
+// gst_spacemit_allocator_new (void);
+// GstMemory *
+// gst_spacemit_allocator_alloc (GstSpaceMitAllocator * allocator, gsize size);
+// GstFlowReturn
+// gst_spacemit_allocator_acquire (GstAllocator * base_allocator, GstMemory ** memory);
+// gboolean
+// gst_spacemit_allocator_configure(GstAllocator * base_allocator, GstVideoInfo * info,  gboolean use_dmabuf);
+// gboolean
+// gst_spacemit_allocator_set_active (GstSpaceMitAllocator * allocator, gboolean active);
+
+// void
+// gst_spacemit_allocator_get_info (GstAllocator * base_allocator, gint32 id, gint32 fd);
+// void
+// gst_spacemit_set_mem (GstMemory * base_mem, MppFrame *mppframe, MppVdecCtx *ctx);
+// gboolean
+// gst_spacemit_allocator_wait_inactive (GstAllocator * base_allocator);
+
+GstAllocator *
+gst_spacemit_src_allocator_new (void);
+
+GType gst_spacemit_src_allocator_get_type (void) G_GNUC_CONST;
+
+G_END_DECLS
+
+#endif /* __GST_SPACEMIT_ALLOCATOR_H__ */
diff --git a/ext/spacemit/spacemitsrc/meson.build b/ext/spacemit/spacemitsrc/meson.build
new file mode 100755
index 0000000..cb7e251
--- /dev/null
+++ b/ext/spacemit/spacemitsrc/meson.build
@@ -0,0 +1,19 @@
+spacemitsrc_sources = [
+  'gstspacemitsrc.c',
+  'gstspmsrcallocator.c',
+]
+
+spacemitcam_dep = dependency('k1x-cam', version : '>= 0.0.0', required : false)
+
+if spacemitcam_dep.found()
+	gstspacemitsrc = library('gstspacemitsrc',
+		spacemitsrc_sources,
+		c_args : gst_plugins_bad_args,
+		link_args : noseh_link_args,
+		include_directories : [configinc],
+		dependencies : [gstvideo_dep, spacemitcam_dep, gstallocators_dep, gstbase_dep],
+		install : true,
+		install_dir : plugins_install_dir,
+	)
+	plugins += [gstspacemitsrc]
+endif
diff --git a/meson_options.txt b/meson_options.txt
index 6c8855a..654cd55 100644
--- a/meson_options.txt
+++ b/meson_options.txt
@@ -185,6 +185,7 @@ option('wpe', type : 'feature', value : 'auto', description : 'WPE Web browser p
 option('magicleap', type : 'feature', value : 'auto', description : 'Magic Leap platform support')
 option('v4l2codecs', type : 'feature', value : 'auto', description : 'Video4Linux Stateless CODECs support')
 option('isac', type : 'feature', value : 'auto', description : 'iSAC plugin')
+option('spacemit', type : 'feature', value : 'auto', description : 'Spacemit encoder/decoder plugin')
 
 # HLS plugin options
 option('hls', type : 'feature', value : 'auto', description : 'HTTP Live Streaming plugin')
-- 
2.25.1

